

----QUIT----(30 August 2020 19:10:58) CuisUniversity-4365.image priorSource: 12340405!

----STARTUP---- (30 August 2020 19:10:59) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-4365.image!


!testRun: #ArithmeticObjectIntervalStrategyTest #testSingleton stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAccessing stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAdd stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAddToCollection stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testAt stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testComparing stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testCopyAndGrowBy stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testDeepCopy stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testDo stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testFirst stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testHash stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testIncludes stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testInvalidAt stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testInvalidCreation stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testLast stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testReject stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testRemoveIfAbsent stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testReverse stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testReverseDo stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testSelect stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testShallowCopy stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testSize stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #ArithmeticObjectIntervalTest #testStoreOn stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testBetweenAndNotInclusive stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testHash stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testMax stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testMin stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testNotInclusiveBetweenAnd stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testNotInclusiveBetweenAndNotInclusive stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testTo stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testToBy stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testToByDo stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testToNegativeBy stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testToReverse stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #IntervalAwareMagnitudeTest #testToYourself stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #NumberToArithmeticObjectAdapterTest #testPrintString stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #UndefinedArithmeticObjectValueExceptionTest #testSignal stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testAccessing stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testConverging stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testEqual stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testGoing stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testHash stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testIsIncidentTo stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testPrintString stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #EdgeTest #testStarting stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphPathFinderTest #testGraphPathNotFoundException stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphPathFinderTest #testInvalidPath stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphPathFinderTest #testPathToFarAwayPlaces stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphPathFinderTest #testPathToNeighborPlace stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphPathFinderTest #testSamePlace stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphPathFinderTest #testWithLoops stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphTest #testAccessImmutability stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphTest #testApplyUsingDepthFistSearch stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphTest #testConvergingEdges stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphTest #testCreateGraphWithInvalidEdge stamp: 'HAW 8/30/2020 19:11:04'!
PASSED!

!testRun: #GraphTest #testCreateGraphWithUnconnectedNodes stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testCreateGraphWithoutEdges stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testCreationImmutability stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testEdgesConvergingToSelf stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testEqual stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testEqualsDifferentGraphs stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testGraphCreation stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testHash stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testIncludesNode stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testIsAcyclicWhenGraphIsAcyclic stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testIsAcyclicWhenGraphIsCyclic stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testIsEmpty stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testNodesAdjacentTo stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testNodesWithoutEdges stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testNotEmpty stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testRemoveNode stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testRemoveNodeWithInvalidNode stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testRemoveNodes stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testSameNodesAs stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #GraphTest #testStartingEdges stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #TopologicalSortTest #testCreateWithCyclicGraph stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #TopologicalSortTest #testValue stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #TopologicalSortTest #testValueWithAnotherGraph stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #TopologicalSortTest #testWithGraphWithoutEdges stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDenominator stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByDifferentDomainDerivedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByDivideUnitSameBaseUnitNumerator stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByDivideUnitSameDomainDerivedUnitNumerator stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByInfinity stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByMinusInfinity stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByNullUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideByNumber stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideBySameBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testDivideBySameDomainDerivedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testEqualDerivedSameBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testEqualDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testEqualDividedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testEqualMultipliedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testEqualNullUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testEqualSameBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testFloatDividedByUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testFloatDividedByUnitTwice stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testFloatMultipliedByUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testFloatMultipliedByUnitTwice stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testIntegerDividedByUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testIntegerDividedByUnitTwice stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testIntegerMultipliedByUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testIntegerMultipliedByUnitTwice stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMeasureCreation stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyByDividedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyByInfinity stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyByMinusInfinity stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyByNullUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyByNumber stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testMultiplyBySimpleUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testName stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNameFor stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNameForMany stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNameForOne stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNameForUndefinedAmount stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNothingAmount stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNullMeasure stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testNumerator stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testReciprocal stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsDerivedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsDerivedUnitOfOtherDomain stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsDividedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsMultipliedUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsNullUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSameDomainAsSameBaseUnit stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #BaseUnitTest #testSign stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #CircularReadStreamTest #testAtBegin stamp: 'HAW 8/30/2020 19:11:05'!
PASSED!

!testRun: #CircularReadStreamTest #testAtEnd stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testCurrent stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testDistanceFrom stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testDistanceFromTo stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testDistanceTo stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testDistanceToFrom stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testNext stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testNextANumberOfSomething stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testPrevious stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testPreviousANumberOfSomething stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CircularReadStreamTest #testRelativeDistanceFromTo stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAdd stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddAssociativity stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddBags stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddCommutativity stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddEquality stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddExistingUnit stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddFloatWithMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddFractionWithMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddImmutability stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddIntegerWithMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAddNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAtSameBaseUnitAsWithBaseUnits stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testAtSameBaseUnitAsWithDerivedUnits stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testCompoundMeasureImmutability stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testCreationWithMeasures stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testCreationWithMeasuresCopiesCollection stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivideByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivision stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionDistributivity stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionFloatByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionFractionByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testDivisionMeasureByCompoundMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testEqual stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualAllNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualNumber stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualOneNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualWithDifferentBagSizeButRepresentSameEntity stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testEqualWithDifferentBagSizeIsNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testHash stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testHashAllNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testHashOneNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testInvalidTruncated stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testIsCompoundMeasurement stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testIsFraction stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testIsNothing stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testLessThan stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMeasures stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testModulo stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloCompoundMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloFloatByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloFractionByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testModuloMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplication stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationByZero stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationCommutativity stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplicationDistributivity stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyFloatByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyFractionByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testMultiplyMeasureByCompoundMeasure stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testNegated stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testNegatedDistribution stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testNegatedZeroBag stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testNotEqual stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testNumberOfMeasures stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testPrintingForMany stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testPrintingForOne stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testRemFrom stamp: 'HAW 8/30/2020 19:11:06'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainder stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderCompoundMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderFloatByMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testRemainderMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testRoundTo stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtract stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractBags stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractEquality stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractExistingUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractFloatWithMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractFractionWithMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractIntegerWithMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractMeasureByCompoundMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testSubtractNothing stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testTheZeroOfTheDomainIsEqualToZero stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testTruncated stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testUnitNameOf stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testWithWithBaseUnits stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testWithWithDerivedUnits stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testZeroDivision stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #CompoundMeasureTest #testZeroEqualsTheZeroOfTheDomain stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testAccessing stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testAccessingImmutability stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testAddUnitConversionRule stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testBreakEquivalence stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testConvertsTo stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testDerivedUnitIsEquivalentTo stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testFromToUse stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testGraph stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testGraphChange stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testIsEquivalentTo stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testNoUnitConversionRule stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testRemove stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #ConversionTableTest #testUnitConversionRuleUniqueness stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDenominator stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDivideByDividedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDivideByFloat stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDivideByInfinity stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDivideByInteger stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDivideByMinusInfinity stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDivideBySimpleUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDividedByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testDividedByNullUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testEqualDividedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testEqualMultipliedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testEqualNullUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testEqualSimpleUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testFloatDividedByUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testFloatDividedByUnitTwice stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testFloatMultipliedByUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testFloatMultipliedByUnitTwice stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testIntegerDividedByUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testIntegerDividedByUnitTwice stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testIntegerMultipliedByUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testIntegerMultipliedByUnitTwice stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMeasureCreation stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByDividedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByFloat stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByInfinity stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByInteger stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByMinusInfinity stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyByNullUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testMultiplyBySimpleUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testName stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testNameForMany stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testNameForOne stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testNothingAmount stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testNullMeasure stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testNumerator stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testReciprocal stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testSameDomainAsDividedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testSameDomainAsMultipliedUnit stamp: 'HAW 8/30/2020 19:11:07'!
PASSED!

!testRun: #DividedUnitTest #testSameDomainAsNullUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #DividedUnitTest #testSameDomainAsSameSimpleUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #DividedUnitTest #testSign stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testAdd stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testDivide stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testIsCompoundMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testModulo stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testMultiply stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testNegated stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testRemainder stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testSubtract stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #EvaluationTest #testTruncated stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testCanConvertTo stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testCompoundMeasureConversion stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testConvertToUsing stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testDefaultGraphPathFinder stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testDirectSearching stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testIndirectSearching stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testInvalidConversion stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MeasureConverterTest #testSameDomainConversion stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testAdd stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testAmount stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testBagCreationWithNumber stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testBetweenAnd stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testCompoundMeasureCreationWithMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testConvertTo stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testDenominator stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testDivide stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testDivideByUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testDivideMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testEqualsCompoundMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testEqualsMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testIsCompoundMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testIsNothing stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testMax stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testMin stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testModulo stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testModuloMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testMultiplication stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testMultiplyByUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testMultiplyMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testNegated stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testNegative stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testNumerator stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testPositive stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testRemainder stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testRemainderMeasure stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testRoundTo stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testSameDomainAs stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testSameUnitAs stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testSubtract stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testToBy stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testToFromFixed stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testToInfinity stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testToToFixed stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testTruncated stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MinusInfinityTest #testUnitNameOf stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDenominator stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDivideByDividedUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDivideByFloat stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDivideByInfinity stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDivideByInteger stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDivideByMinusInfinity stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDivideBySimpleUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDividedByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testDividedByNullUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testEqualDividedUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testEqualMultipliedUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testEqualNullUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testEqualSimpleUnit stamp: 'HAW 8/30/2020 19:11:08'!
PASSED!

!testRun: #MultipliedUnitTest #testFloatDividedByUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testFloatDividedByUnitTwice stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testFloatMultipliedByUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testFloatMultipliedByUnitTwice stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testIntegerDividedByUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testIntegerDividedByUnitTwice stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testIntegerMultipliedByUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testIntegerMultipliedByUnitTwice stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMeasureCreation stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByDividedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByFloat stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByInfinity stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByInteger stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByMinusInfinity stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyByNullUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testMultiplyBySimpleUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testName stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testNameForMany stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testNameForOne stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testNothingAmount stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testNullMeasure stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testNumerator stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testReciprocal stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testSameDomainAsDividedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testSameDomainAsMultipliedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testSameDomainAsNullUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testSameDomainAsSameSimpleUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #MultipliedUnitTest #testSign stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testDenominator stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testName stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testNameForMany stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testNameForOne stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testNothingAmount stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testNullMeasure stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testNumerator stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testReciprocal stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testSameDomainAs stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NotProportionalDerivedUnitTest #testSign stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testDenominator stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testDivideByDividedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testDivideByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testDivideByNullUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testDivideBySimpleUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testEqualBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testEqualDerivedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testEqualDividedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testEqualMultipliedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testEqualNullUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testMeasureCreation stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testMultiplyByDividedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testMultiplyByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testMultiplyByNullUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testMultiplyBySimpleUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testName stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testNameForMany stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testNameForOne stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testNumerator stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testReciprocal stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testSameDomainAsBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testSameDomainAsDerivedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testSameDomainAsDividedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testSameDomainAsMultipliedUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testSameDomainAsNullUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NullUnitTest #testSign stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testAmount stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:09'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testConvertTo stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testConvertToIfSuccessfullDoIfFails stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testIsNothing stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #NumberMeasureProtocolTest #testUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testAdd stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testAmount stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testBagCreationWithNumber stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testBetweenAnd stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testCompoundMeasureCreationWithMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testConvertTo stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testDenominator stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testDivide stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testDivideByUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testDivideMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testEqualsCompoundMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testEqualsMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testIsCompoundMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testIsNothing stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testMax stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testMin stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testModulo stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testModuloMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testMultiplication stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testMultiplyByUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testMultiplyMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testNegated stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testNegative stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testNumerator stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testPositive stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testRemainder stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testRemainderMeasure stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testRoundTo stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testSameDomainAs stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testSameUnitAs stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testSubtract stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testToBy stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testToFromFixed stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testToInfinity stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testToToFixed stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testTruncated stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #PlusInfinityTest #testUnitNameOf stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testConversionFactor stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDenominator stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideByDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideByDifferentDomainDerivedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideByDivideUnitSameDerivedUnitNumerator stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideByDividedUnitSameBaseUnitNumerator stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideByNullUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideBySameBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testDivideBySameDomainDerivedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualDerivedSameBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualDividedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualMultipliedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualNullUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualSameBaseUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testEqualSameDerivedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testMeasureCreation stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testMultiplyByDividedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testMultiplyByMultipliedUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testMultiplyByNullUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testMultiplyBySimpleUnit stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testName stamp: 'HAW 8/30/2020 19:11:10'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testNameForMany stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testNameForOne stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testNothingAmount stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testNullMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testNumerator stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testReciprocal stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsDerivedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsDerivedUnitOfOtherDomain stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsDividedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsMultipliedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsNullUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsSameBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSameDomainAsUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalDerivedUnitTest #testSign stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalUnitConversionFunctionTest #testAccessing stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalUnitConversionFunctionTest #testEqual stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalUnitConversionFunctionTest #testHash stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalUnitConversionFunctionTest #testInvalidValues stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #ProportionalUnitConversionFunctionTest #testValidValues stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAbs stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddAssociativity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddBaseUnitAndDerivedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddCommutativity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddDerivedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddDifferentBaseUnits stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddDifferentUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddDividedMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddFloatWithMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddFractionWithMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddInfinity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddIntegerWithMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddMinusInfinity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddMultipliedMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAddNumber stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAmount stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAmountCanBeConvertedToFloat stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAmountCanBeConvertedToFraction stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAmountCanBeConvertedToInteger stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testAtBaseUnitIfNone stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testBetweenAnd stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testBetweenAndNotInclusive stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testCompareGreaterThan stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testConvertAmountToBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testConvertNothing stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testConvertTo stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testConvertToBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDenominator stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivideInfinity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivideMinusInfinity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionByDividedMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionByMeasureBaseUnitOverBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionByMeasureBaseUnitOverDerivedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionByMeasureDerivedUnitOverBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionByNumber stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionByZero stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionFloatByMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionFractionByMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionOfBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testDivisionOfDerivedUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testEqual stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testEqualDifferentBaseUnit stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testEqualNothingWhenRepresentSameEntity stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testEqualNumber stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testGreaterThanEquals stamp: 'HAW 8/30/2020 19:11:11'!
PASSED!

!testRun: #SimpleMeasureTest #testHash stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testIntegerDivideCompoundMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidBetweenAnd stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidBetweenAndNotInclusive stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidConvertTo stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidGreaterThan stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidGreaterThanAgainstScalar stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidGreaterThanEquals stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidLessThan stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidLessThanEquals stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidMax stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidMin stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidNotInclusiveBetweenAnd stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testInvalidNotInclusiveBetweenAndNotInclusive stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testIsFraction stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testIsNothing stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testLessThan stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testLessThanEquals stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMax stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMeasures stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMin stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloByZero stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloFloatByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloFractionByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloInfinity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloMinusInfinity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloOfBaseUnit stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testModuloOfDerivedUnit stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplicationOfBaseUnit stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplicationOfDerivedUnit stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyByDividedMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyByMeasureAssociativity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyByMultipliedMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyByNumber stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyFloatByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyFractionByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyInfinity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testMultiplyMinusInfinity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testNegated stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testNegative stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testNotEqual stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testNotInclusiveBetweenAnd stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testNotInclusiveBetweenAndNotInclusive stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testNumerator stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testPositive stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testPrintingForMany stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testPrintingForOne stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemFrom stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderByZero stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderCompoundMeasureByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderFloatByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderInfinity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderIntegerByMeasure stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderMinusInfinity stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderOfBaseUnit stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRemainderOfDerivedUnit stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testRoundTo stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testSameDomainAs stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testSimplificationsAddingWithZero stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testSimplificationsDividingFromZero stamp: 'HAW 8/30/2020 19:11:12'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractAssociativity stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractBaseUnit stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractDerivedUnit stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractDividedMeasure stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractFloatWithMeasure stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractFractionWithMeasure stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractInfinity stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractIntegerWithMeasure stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractMinusInfinity stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testSubtractMultipliedMeasure stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testTheZeroOfTheDomainIsEqualToZero stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testTo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToAt stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToAtByNegative stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToBy stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToByDo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToCollect stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToFirst stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToLast stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testToSize stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testTruncated stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testUnit stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testUnitNameOf stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #SimpleMeasureTest #testZeroIsEqualToTheZeroOfTheDomain stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleTest #testAccessing stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleTest #testConvert stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleTest #testEqual stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleTest #testHash stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleToEdgeAdapterTest #testAccessing stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleToEdgeAdapterTest #testEdgeProtocol stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleToEdgeAdapterTest #testEdgeProtocolBehavior stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleToEdgeAdapterTest #testEqual stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #UnitConversionRuleToEdgeAdapterTest #testHash stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #AllDatesUniverseTest #testDo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #AllDatesUniverseTest #testFrom stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #AllDatesUniverseTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #AllDatesUniverseTest #testTo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #ArgentineLaw23555RuleTest #testCreation stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #ArgentineLaw23555RuleTest #testIncludesDayMovesToTheNextMonday stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #ArgentineLaw23555RuleTest #testIncludesDayMovesToThePreviousMonday stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #ArgentineLaw23555RuleTest #testIncludesDayWhenDayIsMonday stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #ArgentineLaw23555RuleTest #testIncludesDayWhenDayIsSaturday stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #ArgentineLaw23555RuleTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #CardinalDayMonthRuleTest #testDifferentMonth stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #CardinalDayMonthRuleTest #testIncludesDayMovesToTheThirdMonday stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #CardinalDayMonthRuleTest #testIncludesDayWhenDayIsSaturday stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #CardinalDayMonthRuleTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DayOfMonthRuleTest #testAccessing stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DayOfMonthRuleTest #testIncludes stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testAdd stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testAddRules stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testAlwaysFulfills stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testAsOrderedCollection stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testAsSortedCollection stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testComposite stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testCreation stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testDo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludedFromTo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludedIn stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludes stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testExcludesAll stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludedFromTo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludedIn stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludes stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testIncludesAll stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testInvalidDo stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testIsEmpty stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testRemoveAllRules stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testRemoveIfAbsent stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testRemoveRule stamp: 'HAW 8/30/2020 19:11:13'!
PASSED!

!testRun: #DefinedByRulesTest #testRulesCopy stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #DefinedByRulesTest #testRulesThatInclude stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #DefinedByRulesTest #testSize stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #DefinedByRulesTest #testSpecies stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testAccessing stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testEquals stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testImmutableValue stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testMonday stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testNext stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testNextFiltered stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testPreviousFiltered stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testSaturday stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testSunday stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #FilteredGregorianDateTest #testToday stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #IntervalConstrainedInclusionRuleTest #testFrom stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #IntervalConstrainedInclusionRuleTest #testIncludes stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #IntervalConstrainedInclusionRuleTest #testInstanceCreating stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #IntervalConstrainedInclusionRuleTest #testPrintString stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #IntervalConstrainedInclusionRuleTest #testTo stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testDaysBetween stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testExcludedFromTo stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testExcludedIn stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testExcludes stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testExcludesAll stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testIncludedFromTo stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testIncludedIn stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testIncludes stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testIncludesAll stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testName stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testNegated stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testNextNegativeDuration stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testNextPositiveDuration stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #NegatedTimeLineFilterTest #testStream stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAbsoluteDate stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAcceptAVisitor stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAsSmalltalkDate stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAt stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAtMidnight stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAtNoon stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testAtTimeOfDay stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testDay stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testDayNumber stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testDayOfMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testDaysFrom stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testDaysTo stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testDefaultIntervalIncrement stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testEqual stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testHash stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testIntervalStrategy stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testIsFirstDayOfMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testIsFirstDayOfYear stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testIsLastDayOfMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testIsLastDayOfYear stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testLessThan stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testMonthOfYear stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNext stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNextDay stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNumberOfDaysFromBaseDate stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNumberOfDaysFromBeginningOfMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNumberOfDaysFromJanuaryFirst stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNumberOfDaysToEndOfMonth stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testNumberOfDaysToEndOfYear stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testPrevious stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testPreviousDay stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testToEvery stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testToEveryDay stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testToEveryDayNumber stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testToEveryDayNumbers stamp: 'HAW 8/30/2020 19:11:14'!
PASSED!

!testRun: #RelativeGregorianDateTest #testYear stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #SpecificDayRuleTest #testAccessing stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #SpecificDayRuleTest #testIncludes stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #SpecificObjectInclusionRuleTest #testAccessing stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #SpecificObjectInclusionRuleTest #testIncludes stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #SpecificObjectInclusionRuleTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterStreamTest #testAtEnd stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterStreamTest #testCurrent stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterStreamTest #testDo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterStreamTest #testReset stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddArgentineLaw23555Rule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddCardinalDayMonthRuleRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddDateRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddDayOfMonthRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddDayRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRuleFrom stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRuleFromTo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRules stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRulesFrom stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testAddRulesFromTo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testDateRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testDayOfMonthRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testDayRule stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testDaysBetween stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludedFromTo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludedIn stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludes stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testExcludesAll stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testFromString stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testHash stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludedFromTo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludedIn stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludes stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testIncludesAll stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testNegatedIncludes stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testNegatedNext stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testNextNegativeDuration stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testNextPositiveDuration stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testNumberOfDaysBetweenTwoDates stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testPrintOn stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testRemoveAllRules stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testRuleFromTo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testRules stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testRulesThatIncludeADate stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #TimeLineFilterTest #testStream stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #UniverseTest #testDo stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testEqual stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testHash stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testLastDayNumber stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testLessThan stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testName stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNext stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumber stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testNumberOfDaysIn stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testPrevious stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FebruaryGregorianMonthTest #testPrintString stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #test29OfFebruaryToEveryDayOfMonth stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testAsSmalltalkDate stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testAt stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtMidnight stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtNoon stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testAtTimeOfDay stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testCreation stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testDay stamp: 'HAW 8/30/2020 19:11:15'!
PASSED!

!testRun: #FixedGregorianDateTest #testDayNumber stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testDayOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testDaysFrom stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testDaysTo stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testEqual stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testHash stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testImmutableValue stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesDate stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesDateTime stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesMonthOfYear stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIncludesYear stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testInvalidCreation stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsApril stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsAugust stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsDecember stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFebruary stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFirstDayOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFirstDayOfYear stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsFriday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJanuary stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJuly stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsJune stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsLastDayOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsLastDayOfYear stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMarch stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsMonday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsNovember stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsOctober stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSaturday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSeptember stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsSunday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsThursday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsTuesday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testIsWednesday stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testLessThan stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testMonthOfYear stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNext stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextDay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextDayOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextInNumberOfDays stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextInWeeks stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNextMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromBaseDate stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromBeginningOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysFromJanuaryFirst stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysToEndOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testNumberOfDaysToEndOfYear stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testPrevious stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousDay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousDayOfMonth stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousInNumberOfDays stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testPreviousInWeeks stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testPrintString stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testTheBeginningAndTheEndOfTime stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testTo stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToBy stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToByDo stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToByReverse stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryBeginningDifferentDay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryBeginningSameDay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayBeginningDifferentDay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayBeginningSameDay stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayNumber stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayNumbers stamp: 'HAW 8/30/2020 19:11:16'!
PASSED!

!testRun: #FixedGregorianDateTest #testToEveryDayOfMonth stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #FixedGregorianDateTest #testToNegativeBy stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #FixedGregorianDateTest #testTomorrow stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #FixedGregorianDateTest #testVisitorAccessing stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #FixedGregorianDateTest #testYear stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #FixedGregorianDateTest #testYesterday stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testAccessing stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testAdd stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testComparing stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testFirstTimeOfDay stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testHash stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testLastTimeOfDay stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testLessThan stamp: 'HAW 8/30/2020 19:11:17'!
PASSED!

!testRun: #GregorianDateTimeTest #testNow stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testPrintString stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testReverse stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testSameDateAs stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testSameTimeOfDayAs stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testSpecialDateTimes stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testSubtract stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeFrom stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeFromMidnight stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeTo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testTimeToEndOfDay stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testTo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testToBy stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testToByDo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testToByMinutesDo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testToNegativeByDo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testWithDay stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDateTimeTest #testWithDayOfMonth stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testComma stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testComparing stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testCreation stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDateOfYear stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDaysFrom stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDaysTo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testDivisionSymbolCanBeUseToCreateADate stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testEqual stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testHash stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testInvalidCreation stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsFirstDayOfMonth stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsFirstDayOfYear stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsLastDayOfMonth stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testIsLastDayOfYear stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNext stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNextANumberOfDays stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysFromBeginningOfMonth stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysToEndOfMonth stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testNumberOfDaysToEndOfYear stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPrevious stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPreviousANumberOfDays stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testPrintString stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testTo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToBy stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToByDo stamp: 'HAW 8/30/2020 19:11:18'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToEveryDayNumber stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToEveryDayNumbers stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToNegativeBy stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToReverse stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayOfMonthTest #testToday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testCommonDaysMeasure stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testDayCreation stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testDayPositionedInWeek stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testDays stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testDaysFrom stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testDaysTo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testEqual stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testGlobalVariables stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testInvalidNameCreation stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsFriday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsMonday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsSaturday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsSunday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsThursday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsTuesday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testIsWednesday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testName stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testNext stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testNextInANumberOfDays stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testNumberOfDaysSinceSunday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testPrevious stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testPreviousInANumberOfDays stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testPrintString stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testSinceSunday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testTo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testToBy stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testToDo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testToNegativeBy stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testToNegativeByDo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianDayTest #testToday stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCardinalDay stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCreation stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testCurrent stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testDates stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testEqual stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testFirstDate stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testFirstDay stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testHash stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesDate stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesDateTime stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesMonthOfYear stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testIncludesYear stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testInvalidCreation stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDate stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDay stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLastDayNumber stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testLessThan stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testMonthsFrom stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testMonthsTo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testName stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNext stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNextANumberOfMonths stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNextMonthDefinedAs stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testNumberOfDays stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPrevious stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPreviousANumberOfMonths stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPreviousMonthDefinedAs stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testPrintString stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testTo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToBy stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToByDo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToByYearsDo stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToNegativeBy stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthOfYearTest #testToReverse stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthTest #testApril stamp: 'HAW 8/30/2020 19:11:19'!
PASSED!

!testRun: #GregorianMonthTest #testAugust stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testComma stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testCommonMonthsMeasure stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testCurrent stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testDayOfMonthCreation stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testDecember stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testDivisionSymbolCanBeUseToCreateADayOfMonth stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testFebruary stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testFirstDayOfMonth stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testGlobalVariables stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIdentity stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsApril stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsAugust stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsDecember stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsFebruary stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsJanuary stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsJuly stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsJune stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsMarch stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsMay stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsNovember stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsOctober stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testIsSeptember stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testJanuary stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testJuly stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testJune stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testLastDayOfMonth stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testLessThan stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testMarch stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testMay stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testMonthCreation stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsFrom stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testMonthsTo stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testNamed stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testNext stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testNextInANumberOfMonths stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testNovember stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testNumberOfMonthsPerYear stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testOctober stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testOf stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testOfYear stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testPrevious stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testPreviousInANumberOfMonths stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testSeptember stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testTo stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testToBy stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testToByDo stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testToNegativeByDo stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianMonthTest #testToReverse stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testAccessing stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testAsInterval stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testCanCreateATimespanAfterATimeMeasure stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testCanCreateATimespanBeforeATimeMeasure stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testEqual stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testFromInterval stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testHash stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testPrintString stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianTimespanTest #testTo stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testCurrent stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testDates stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testDaysInFebruary stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testDistanceTo stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testEqual stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testFirstDate stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testFirstDay stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testFirstMonth stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testHash stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testIncludesDate stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testIncludesDateTime stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testIncludesMonthOfYear stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testIncludesYear stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testInvalidNextANumberOfYears stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testInvalidPreviousANumberOfYears stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testInvalidYear stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testIsLeap stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testLastDate stamp: 'HAW 8/30/2020 19:11:20'!
PASSED!

!testRun: #GregorianYearTest #testLastDay stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testLastMonth stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testLessThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testMonths stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testMonthsOfYearsAccessing stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testNext stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testNextANumberOfYears stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testNextLeapYear stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testNumberOfDays stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testNumberOfDaysFromBaseDate stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testPrevious stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testPreviousANumberOfYears stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testPreviousLeapYear stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testPrintString stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testTo stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testToBy stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testToByDo stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testToByReverse stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testToNegativeBy stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testYearsFrom stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testYearsTo stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #GregorianYearTest #testZeroYears stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testEqual stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testHash stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLastDayNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testLessThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testName stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNext stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysFromBeginningOfYear stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testNumberOfDaysIn stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrevious stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #JanuaryGregorianMonthTest #testPrintString stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #MoreThanOnePointInTimeIntervalStrategyTest #testIsValidIntervalFromToBy stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testEqual stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testHash stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLastDayNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testLessThanFebruary stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testName stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #NonSpecificThirtyOneDaysGregorianMonthTest #testPrintString stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testDayOfMonthCreation stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testEqual stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testGreaterThanFebruary stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testHash stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLastDayNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLessThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testLessThanFebruary stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testName stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumber stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumberOfDaysFromJanuaryFirst stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testNumberOfDaysIn stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyDaysGregorianMonthTest #testPrintString stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyOneDaysGregorianMonthTest #testThirtieth stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #ThirtyOneDaysGregorianMonthTest #testThirtyfirst stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testAdd stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCanCreateAsWrittenInEnglish stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCanNotCreateTimeOfDayWithSemiColonWhenReceiverHasSeconds stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testComparing stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCreation stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCreationHour stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCreationMilliseconds stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCreationMinute stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testCreationSecond stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testFirstTimeOfDay stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testGreaterThan stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testHash stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testInvalidCreation stamp: 'HAW 8/30/2020 19:11:21'!
PASSED!

!testRun: #TimeOfDayTest #testLastTimeOfDay stamp: 'HAW 8/30/2020 19:11:22'!
PASSED!

!testRun: #TimeOfDayTest #testLessThan stamp: 'HAW 8/30/2020 19:11:22'!
PASSED!

!testRun: #TimeOfDayTest #testNow stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testOneMillisecond stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testOneSecond stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testPrintString stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testReverse stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testSubtract stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testTimeFrom stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testTimeFromMidnight stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testTimeTo stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testTimeToEndOfDay stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testTo stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testToBy stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testToByDo stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testToNegativeByDo stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testTwentyFourHours stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeOfDayTest #testZeroHours stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testAllUnits stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testDay stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testHour stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testMillisecond stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testMinute stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testMonth stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testSecond stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testWeek stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #TimeUnitsTest #testYear stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #BinarySearchTest #testquickFindFirst stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #BinarySearchTest #testquickFindLast stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #BinarySearchTest #testquickIndexOf stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #BinarySearchTest #testquickIndexOfWithSemistableOrder stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectTest #testIdentitySet stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectTest #testOrderedCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectTest #testSet stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectTest #testSortedCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAsCommaSeparatedOnWorksAsCommaStringAnd stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAsCommaStringAndDoesNotAddAnythingWhenEmpty stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAsCommaStringAndDoesNotAddAnythingWhenHasOneElement stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAsCommaStringAndSeparatesWithAndWhenTwoOneElements stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAsCommaStringAndSeparatesWithCommaButLastOneWithAndWhenMoreThanTwoElements stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAverageFailsWhenTheCollectionIsEmpty stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAverageIfEmptyCalculatesItAsUsualWhenTheCollectionIsNotEmpty stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testAverageIfEmptyEvaluatesEmptyBlockWhenTheCollectionIsEmpty stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testGroupByHavingSelectsTheResultOfGroupBy stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testGroupByReturnsADictionaryThatGroupsACollectionByThePluggableKey stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testIsCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testItMaintainsTheSameCollectionSpecies stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testSetEquality stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testWhenCollectionContainsASingleLevelOfElementsItReturnsTheSameCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testWhenCollectionContainsMoreThanTwoLevelsltReturnsTheElementsOfAllNestedCollections stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testWhenCollectionContainsStringCollectionsItDoesNotFlattenTheStrings stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testWhenCollectionContainsStringsItReturnsTheSameCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testWhenCollectionContainsTwoLevelsOfElementsItReturnsTheElementsOfAllNestedCollections stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testWhenCollectionIsEmptyItReturnsTheSameCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #CollectionTest #testsAverageWorksWithABlock stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #DictionaryTest #testIsCollection stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #DictionaryTest #testKeyNotFoundSignalTheRightMessage stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testAt stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testDoesNotIncludeNumbersOutsideTheInInterval stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testDoesNotIncludeObjectsThatAreNotNumbers stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testDoesNotIncludedNumbersThatAreInRangeButNotReachedByTheStep stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testDoesNotIncludedNumbersThatAreInRangeButNotReachedByTheStepWithReversedIntervals stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testFloatInterval stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testFloatToByDo stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testIncludedNumbersRespectAStepDifferentToOne stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testIncludedNumbersRespectNegativeSteps stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testIncludesNumbersInsideTheInterval stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testIncludesNumbersInsideTheIntervalEvenForReversedIntervals stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testIntegerInterval stamp: 'HAW 8/30/2020 19:11:23'!
PASSED!

!testRun: #IntervalTest #testIntegerToByDo stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #IntervalTest #testIntervalWithOneNumberAndNegativeStepBiggerThanOneIncludeOnlyThatNumber stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #IntervalTest #testIntervalWithOneNumberAndNegativeStepIncludeOnlyThatNumber stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #IntervalTest #testIntervalWithOneNumberAndStepBiggerThanOneIncludesOnlyTheNumber stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #IntervalTest #testIntervalWithOneNumberIncludesOnlyTheNumber stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #OrderedCollectionTest #testIsCollection stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #OrderedCollectionTest #testStreamContentsWorksAsExpected stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #OrderedCollectionTest #testWriteStreamOnOrderedCollectionGrowsAsExpected stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #OrderedDictionaryTest #testOrder stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #OrderedDictionaryTest #testRemove stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testCombinationsAtATimeDoShouldEvaluateBlockWithEmptyCollection stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testCombinationsAtATimeDoWorksAsExpected stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testDoSeparatedByDoesNotValueSeparatedBlockOnLastElement stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testDoSeparatedByDoesNothingForEmptyCollection stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testFirstAvailableReturnsAllObjectsWhenRequestedMoreThanTheSize stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testFirstAvailableReturnsAllObjectsWhenRequestedTheReceiversSize stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testFirstAvailableReturnsTheFirstRequestedObjectsWhenTheyAreAvailable stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testLastAvailableReturnsAllObjectsWhenRequestedMoreThanTheSize stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testLastAvailableReturnsAllObjectsWhenRequestedTheReceiversSize stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testLastAvailableReturnsTheLastRequestedObjectsWhenTheyAreAvailable stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testWithIndexDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testWithIndexDoSeparatedByDoesNotValueSeparatedBlockOnLastElement stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #SequenceableCollectionTest #testWithIndexDoSeparatedByDoesNothingForEmptyCollection stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #TextTest #testIsText stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #WeakIdentitySetTest #test stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllAccessToInstVarReturnsAccessReceiversBranch stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllAccessToIsEmptyForVariableNotDefinedInClass stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllBroadAccessToReturnsAccessInAllHierarchy stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllSuperclassesUpToFailsWhenWantsToStopOnInvalidSuperclass stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllSuperclassesUpToPutsFirstSuperclassesFirst stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllSuperclassesUpToStopsOnRightClass stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testAllUnreferencedInstanceVariablesReturnsOnlyUnreferencedVariables stamp: 'HAW 8/30/2020 19:11:24'!
PASSED!

!testRun: #BehaviorTest #testHasReferencesToInstanceVariableNamedLooksInClassOnly stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testHighestClassImplementingReturnsReceiverWhenNoOtherSuperclassImplementsSelector stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testHighestClassImplementingReturnsTheTopSuperclassImplementingSelector stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testHighestClassImplementingValuesIfNoneBlockWhenSelectorIsNotImplemented stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testIsInstanceVariableNamedReferencedInHierarchyLooksReferencesInHierarchy stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testProtoObjectAllRegularInstVarNamesDoesNotFail stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testUnreferencedInstanceVariablesReturnsOnlyUnreferencedVariables stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #BehaviorTest #testWithAllSuperclassesUpToIncludesReceiverClass stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #ClassTest #testDefinitionReplacingCategoryWithReplacesTheCategoryWithTheGivenOne stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #ClassTest #testDefinitionReplacingCategoryWithWorksWhenCategoryIsNil stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testCreation stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testDayOfWeek stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testInvalidOperations stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testIsDateAndTime stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testLessDateAndTime stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testOperations stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateAndTimeTest #testToByDo stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateTest #testCreation stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateTest #testInvalidOperations stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateTest #testLessDate stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DateTest #testLessDuration stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #DurationTest #testPrintString stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #MonthTest #testCreation stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #MonthTest #testPrintString stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #TimeTest #testCreation stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #TimeTest #testEqual stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #TimeTest #testSqueakInquiries stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #TimeTest #testTimePartsArePositive stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #TimespanTest #testIsTimespan stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #WeekTest #testCreation stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #WeekTest #testIncluding stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #WeekTest #testInvalidOperations stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #WeekTest #testPrintString stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #WeekTest #testWeekDayNames stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #YearTest #testCreation stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #YearTest #testIncluding stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test01isGetterWhenSameSelectorAsInstanceVariableAndOnlyReturnsThatVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test01withPropertiesDoIfSelectorEvaluatesFirstBlockWhenMethodHasProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test02isNotGetterWhenDifferentSelectorAsInstanceVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test02removePropertiesRestoresPenultimalLiteralToSelector stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test03isNotGetterWhenSameSelectorAsInstanceVariableButDoesOtherThingBesidesReturningVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test03removePropertiesKeepsSelectorIfMethodDoesNotHaveProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test04isSetterWhenSameKeywordSelectorAsInstanceVariableAndOnlySetsTheVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test04withPropertiesDoIfSelectorEvaluatesSecondBlockWhenMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test05hasLiteralSuchThatTravelsListeralsWhenMethodHasProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test05isNotSetterWhenDifferentKeywordSelectorAsInstanceVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test06hasLiteralSuchThatTravelsListeralsWhenMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test06isNotSetterWhenSameKeywordSelectorAsInstanceVariableButDoesNotAssignParameter stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test0701withPropertiesDoReturnsNilIfMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test07AccessorDescriptionIsGetterForAGetter stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test07withPropertiesDoEvaluatesBlockOnlyWhenMethodHasProperties stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test08AccessorDescriptionIsSetterForASetter stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test08hasLiteralThoroughReturnTrueWhenMethodHasPropertiesAndHasLiteral stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test09AccessorDescriptionIsReadForMethodThatReadsInstanceVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test09hasLiteralThoroughReturnFalseWhenMethodHasPropertiesAndHasNoLiteral stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test10AccessorDescriptionIsWriteForMethodThatWritesInstanceVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test10hasLiteralThoroughReturnTrueWhenMethodHasNoPropertiesAndHasLiteral stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test11AccessorDescriptionIsWriteReadForMethodThatWritesAndReadInstanceVariable stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test11hasLiteralThoroughReturnFalseWhenMethodHasNoPropertiesAndHasNoLiteral stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test12pragmaAtReturnsPragmaIfExist stamp: 'HAW 8/30/2020 19:11:25'!
PASSED!

!testRun: #CompiledMethodTest #test13pragmaAtReturnsNilIfPragmaDoesNotExist stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test14pragmasReturnsCollectionOfMethodPragmas stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test15pragmasReturnsEmptyCollectionWhenMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test16propertiesReturnsAnNewAdditionalMethodStateWhenNoPropertiesHasBeenSet stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test17propertiesReturnsTheAlreadySetAdditionalMethodStateWhenHasProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test18propertyKeysAndValuesDoIteratesOverProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test19propertyKeysAndValuesDoDoesNotEvaluateBlockWhenMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test20propertyValueAtReturnsPropertyValueWhenSetted stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test21propertyValueAtReturnsNilWhenPropertyIsNotFound stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test22propertyValueAtReturnsNilWhenMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test23propertyValueAtIfAbsetReturnsPropertyValueWhenFound stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test24propertyValueAtIfAbsetEvaluatesIfAbsentBlockWhenNotFound stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test25propertyValueAtIfAbsetEvaluatesIfAbsentBlockWhenMethodHasNoProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test26propertyValueAtPutCreatesPropertiesWithNewOne stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test27propertyValueAtPutReplacesPropertyIfAlreadyExisted stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test28propertyValueAtPutAddsNewPropertyIfPropertiesExisted stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test29selectorReturnsMethodSelectorWhenNoProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test30selectorReturnsMethodSelectorWhenHasProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test31SettingSelectorWhenHasNoProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #CompiledMethodTest #test32SettingSelectorWhenHasProperties stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #DelayTest #testBounds stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #DelayTest #testMultiProcessWaitOnSameDelay stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #DelayTest #testMultiSchedule stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #MonitorTest #testExample1 stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #MonitorTest #testExample2 stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #MonitorTest #testMonitorNotGainingUnwantedSignalsDuringUnwinding stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #ProcessTest #testAtomicSuspend stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #SemaphoreTest #testCritical stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #SemaphoreTest #testCriticalIfError stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #SemaphoreTest #testSemaAfterCriticalWait stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #SemaphoreTest #testSemaInCriticalWait stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #SemaphoreTest #testWaitAndWaitTimeoutTogether stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #SemaphoreTest #testWaitTimeoutMSecs stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!classDefinition: #BecomeTestExperiment category: #'BaseImageTests-Kernel' stamp: 'HAW 8/30/2020 19:11:26'!
Object subclass: #BecomeTestExperiment
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BaseImageTests-Kernel'!

!testRun: #BecomeTest #testBecome stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!classDefinition: #BecomeTestExperiment category: #'BaseImageTests-Kernel' stamp: 'HAW 8/30/2020 19:11:26'!
Object subclass: #BecomeTestExperiment
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'BaseImageTests-Kernel'!

!testRun: #BecomeTest #testShapeMutation stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #BooleanTest #testAndAndAndAndTrueTable stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #BooleanTest #testAndAndAndTrueTable stamp: 'HAW 8/30/2020 19:11:26'!
PASSED!

!testRun: #BooleanTest #testAndAndTrueTable stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #BooleanTest #testIsBoolean stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #BooleanTest #testOrOrOrOrTrueTable stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #BooleanTest #testOrOrOrTrueTable stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #BooleanTest #testOrOrTrueTable stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterSetTest #testIncludesReturnsFalseForCharacterNotIncluded stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterSetTest #testIncludesReturnsFalseForObjectsThatAreNotCharacters stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterSetTest #testIncludesReturnsTrueForCharacterIncluded stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testCaseConversion stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNilIfNotNil0Arg stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNilIfNotNil0ArgAsVar stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNilIfNotNil1Arg stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNilIfNotNil1ArgAsVar stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNil0Arg stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNil0ArgAsVar stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNil1Arg stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNil1ArgAsVar stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNilIfNil0Arg stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNilIfNil0ArgAsVar stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNilIfNil1Arg stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #IfNotNilTests #testIfNotNilIfNil1ArgAsVar stamp: 'HAW 8/30/2020 19:11:27'!
PASSED!

!testRun: #ProcessorTest #testGrabProcessor stamp: 'HAW 8/30/2020 19:11:28'!
PASSED!

!testRun: #ProcessorTest #testGrabProcessorOnlyForNoTimeout stamp: 'HAW 8/30/2020 19:11:30'!
PASSED!

!testRun: #ProcessorTest #testGrabProcessorOnlyForTimeout stamp: 'HAW 8/30/2020 19:11:31'!
PASSED!

!testRun: #ProcessorTest #testValueUnpreemptively stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #SpecialSelectorsTest #testCollectionAtSymbol stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #SpecialSelectorsTest #testNumberAtSymbol stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StrikeFontTest #testBaseAndDerivedFont stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StrikeFontTest #testBaseAndDerivedFontSanity stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testFirstNoBlankIndex stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testLastNoBlankIndex stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testAntepenultimateIfAbsentReturnsAntepenultimateIfExists stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testAntepenultimateIfAbsentValuesIfAbsentBlockWhenNoAntepenultimate stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testAntepenultimateReturnsAntepenultimateIfExists stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testAntepenultimateSignalsErrorWhenCollectionIsNotBigEnough stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testCanNotInsertShiftingRightWhenInsertionPointIsBiggerThanSize stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testCanNotInsertShiftingRightWhenInsertionPointIsLessThanOne stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testInsertShiftingRightLoosesLastElementAndKeepsPreviousOnes stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testInsertShiftingRightReplacesElementWhenSizeIsOne stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testInsertShiftingRightReplacesLastElementWhenInsertingAtLastIndex stamp: 'HAW 8/30/2020 19:11:33'!
PASSED!

!testRun: #ArrayTest #testIsArray stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testIsCollection stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testLastIfEmptyReturnsLastWhenExist stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testLastIfEmptyValuesEmptyBlockWhenEmpty stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testLastSignalsErrorWhenEmpty stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testPenultimateIfAbsentReturnsPenultimateIfExists stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testPenultimateIfAbsentValuesIfAbsentBlockWhenNoPenultimate stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testPenultimateReturnsPenultimateIfExists stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ArrayTest #testPenultimateSignalsErrorWhenCollectionIsNotBigEnough stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArray64Test #testIsCollection stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArray64Test #testZeroArrayDividend stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArray64Test #testZeroArrayDivisor stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArray64Test #testZeroDividend stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArray64Test #testZeroDivisor stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArrayTest #testIsType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArrayTest #testZeroArrayDividend stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArrayTest #testZeroArrayDivisor stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArrayTest #testZeroDividend stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #FloatArrayTest #testZeroDivisor stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testBlockClosuresCanBeUsedAsHandlingCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithExceptionTypeAndExceptionType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithExceptionTypeAndFilterCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithExceptionTypeAndOrCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithFilterConditionAndExceptionType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithFilterConditionAndFilterCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithFilterConditionAndOrCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithOrConditionAndExceptionType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithOrConditionAndFilterCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateFilterConditionWithOrConditionAndOrCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithExceptionTypeAndExceptionType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithExceptionTypeAndFilterCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithExceptionTypeAndOrCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithFilterConditionAndExceptionType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithFilterConditionAndFilterCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithFilterConditionAndOrCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithOrConditionAndExceptionType stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithOrConditionAndFilterCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testCanCreateOrConditionWithOrConditionAndOrCondition stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testExceptionsFollowTheExpectedHierarchy stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testFilterConditionWorksAsExcpetedWhenHandlingException stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionHandlingConditionTest #testOrConditionWorksAsExcpetedWhenHandlingException stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testDoubleOuterPass stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testDoublePassOuter stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testDoubleResume stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testHandlerFromAction stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testNoTimeout stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testNonResumableFallOffTheEndHandler stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testNonResumableOuter stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testNonResumablePass stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testResignalAs stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testResignalAsUnwinds stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testResumableFallOffTheEndHandler stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testResumableOuter stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testResumablePass stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSignalFromHandlerActionTest stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleEnsure stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleEnsureTestWithError stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleEnsureTestWithNotification stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleEnsureTestWithUparrow stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleIsNested stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleOuter stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimplePass stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleResignalAs stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleResume stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleRetry stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleRetryUsing stamp: 'HAW 8/30/2020 19:11:34'!
PASSED!

!testRun: #ExceptionTests #testSimpleReturn stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ExceptionTests #testTimeoutWithZeroDuration stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ProcessTerminateBug #testSchedulerTermination stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ProcessTerminateBug #testTerminationDuringUnwind stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ProcessTerminateBug #testUnwindFromActiveProcess stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ProcessTerminateBug #testUnwindFromForeignProcess stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ArrayLiteralTest #testIsArray stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ArrayLiteralTest #testReservedIdentifiers stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ArrayLiteralTest #testSymbols stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test01isAtSuperclassWhenIndexIsInSuperclass stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test02isNotAtSuperclassWhenIndexIsOutsideSuperclass stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test03isAtClassNameWhenIndexIsInClassName stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test04isNotAtClassNameWhenIndexIsOutsideClassName stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test05isAtInstanceVariablesWhenIndexIsInInstanceVariablesString stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test06isNotAtInstanceVariablesWhenIndexIsOutsideInstanceVariablesString stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test07CanAccessSuperclass stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test08isAtCategoryWhenIndexIsInCategoryString stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test09isNotAtCategoryWhenIndexIsOutsideCategoryString stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test10InstanceVariablesIsTheSecondParameter stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClassDefinitionNodeAnalyzerTest #test11CategoryIsTheFifthParameter stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testBlockDoitDecompilation stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testBlockNumbering stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testBlockNumberingForInjectInto stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testDebuggerTempAccess stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInjectIntoDecompilationsEncoderForV3PlusClosures stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInjectIntoDecompiledDebugs stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInlineBlockCollectionEM1 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInlineBlockCollectionLR1 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInlineBlockCollectionLR2 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInlineBlockCollectionLR3 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testInlineBlockCollectionSD1 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testSourceRangeAccessForClosureBytecodeInjectInto stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testSourceRangeAccessForInjectInto stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureCompilerTest #testTempNameAccessForInjectInto stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample01 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample02 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample03 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample04 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample05 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample06 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample07 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample08 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample09 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample10 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureSerializationTest #testSample11 stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testBlockArgument stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testBlockTemp stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testCopyNonLocalReturn stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testIsTrivialClosure stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testMethodArgument stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testMethodTemp stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testToDoArgument stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testToDoArgumentNotInlined stamp: 'HAW 8/30/2020 19:11:35'!
PASSED!

!testRun: #ClosureTests #testToDoInsideTemp stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testToDoInsideTempNotInlined stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testToDoOutsideTemp stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testToDoOutsideTempNotInlined stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testWhileModificationAfter stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testWhileModificationAfterNotInlined stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testWhileModificationBefore stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testWhileModificationBeforeNotInlined stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testWhileWithTemp stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ClosureTests #testWhileWithTempNotInlined stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ContextCompilationTest #testVariablesAndOffsetsDo stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #MirrorPrimitiveTests #testMirrorAt stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #MirrorPrimitiveTests #testMirrorClass stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #MirrorPrimitiveTests #testMirrorEqEq stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #MirrorPrimitiveTests #testMirrorInstVarAt stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #MirrorPrimitiveTests #testMirrorPerform stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #MirrorPrimitiveTests #testMirrorSize stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ParserTest #testItGeneratesATempDeclarationNodeForEachTempInABlock stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ParserTest #testItGeneratesATempDeclarationNodeForEachTempInAMethod stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ParserTest #testItGeneratesAnEmptyTempsDeclarationNodeForAMethodWithoutTemps stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ParserTest #testRangesAreOkWhenReturningAVariableWithoutSpaceAfterThat stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #PrettyPrintingTest #test1 stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #PrettyPrintingTest #test2 stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #PrettyPrintingTest #test3 stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #PrettyPrintingTest #test4 stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #PrettyPrintingTest #test5 stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #PrettyPrintingTest #test6 stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #ScannerTest #testLiteralSymbols stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test01TryingToTrimAnAlreadyTrimmedIntervalThatRepresentsASmalltalkExpressionDoesNotChangeTheOriginalInterval stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test02StartingAndEndingSeparatorsAreTrimmed stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test03StartingAndEndingDotsAreTrimmed stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test04GroupsOfParenthesesAreTrimmed stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test05GroupsOfParenthesesIncludingSeparatorsAreTrimmed stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test06AnIntervalThatDoesNotHaveCharactersToExpandRemainsTheSame stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test07AnIntervalEnclosedByParenthesesCanBeExpanded stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test08AnIntervalWithParenthesesOnJustOneSideCannotBeExpanded stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test09AnIntervalEnclosedByBackticksCanBeExpanded stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test10AnIntervalEnclosedMultipleBackticksAndParenthesesCanBeExpanded stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #SourceCodeIntervalTest #test11AsSourceCodeIntervalMessageDoesNotCreateANewSourceCodeIntervalInstance stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileIOAccessorTest #testDirectoryExists stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testAbsolutePath stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testAtPut stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testConcatenation stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testCopy stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testDefaultDirectory stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testFileContents stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testIsAbsolutePathName stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testIsRelativePathName stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testPathComponents stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testPipe stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testRecursiveDelete stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testRefresh stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testRename stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testRoot stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #FileManTest #testStream stamp: 'HAW 8/30/2020 19:11:36'!
PASSED!

!testRun: #CuisSourceFileArrayTest #testAddressRange stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #CuisSourceFileArrayTest #testChangesFileAddressRange stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #CuisSourceFileArrayTest #testFileIndexFromSourcePointer stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #CuisSourceFileArrayTest #testFilePositionFromSourcePointer stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #CuisSourceFileArrayTest #testSourcePointerFromFileIndexAndPosition stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #CuisSourceFileArrayTest #testSourcesFileAddressRange stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #SystemConsistencyTest #testMethodsWithUnboundGlobals stamp: 'HAW 8/30/2020 19:11:37'!
PASSED!

!testRun: #TrieTest #testAllMesssagesLikeDicionary stamp: 'HAW 8/30/2020 19:11:42'!
PASSED!

!testRun: #TrieTest #testAllMesssagesLikeSet stamp: 'HAW 8/30/2020 19:11:46'!
PASSED!

!testRun: #TrieTest #testIncludesReturnsFalseForObjectsThatAreNotString stamp: 'HAW 8/30/2020 19:11:46'!
PASSED!

!testRun: #TrieTest #testIncludesReturnsFalseForStringsNotIncluded stamp: 'HAW 8/30/2020 19:11:46'!
PASSED!

!testRun: #TrieTest #testIncludesReturnsTrueForIncludedStrings stamp: 'HAW 8/30/2020 19:11:46'!
PASSED!

!testRun: #TrieTest #testKeyNotFoundSignalTheRightMessage stamp: 'HAW 8/30/2020 19:11:46'!
PASSED!

!testRun: #TrieTest #testPrefixIteration stamp: 'HAW 8/30/2020 19:11:46'!
PASSED!

!testRun: #TrieTest #testPrefixIteration2 stamp: 'HAW 8/30/2020 19:11:47'!
PASSED!

!testRun: #TrieTest #testRemoveLikeDicionary stamp: 'HAW 8/30/2020 19:11:50'!
PASSED!

!testRun: #TrieTest #testRemoveLikeSet stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #TrieTest #testSetProtocol stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #ReferenceStreamTest #testDiskProxy stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #ReferenceStreamTest #testSortedCollection stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #ReferenceStreamTest #testWeakDumps stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #SmartRefStreamTest #testDiskProxy stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #SmartRefStreamTest #testSortedCollection stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #SmartRefStreamTest #testWeakDumps stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #BitBltTest #testAllAlphasRgbAdd stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #BitBltTest #testAllAlphasRgbMax stamp: 'HAW 8/30/2020 19:11:54'!
PASSED!

!testRun: #BitBltTest #testAllAlphasRgbMin stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #BitBltTest #testAllAlphasRgbMinInvert stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #BitBltTest #testAllAlphasRgbMul stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #BitBltTest #testAllAlphasRgbSub stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #BitBltTest #testAlphaCompositing stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #BitBltTest #testAlphaCompositing2 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bpp stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bpp61 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bpp62 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bpp63 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bppLE stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bppLE61 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bppLE62 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test16bppLE63 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test32bpp stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test32bpp63 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #test32bppLE63 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bpp stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bpp61 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bpp62 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bpp63 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bppLE stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bppLE61 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bppLE62 stamp: 'HAW 8/30/2020 19:11:55'!
PASSED!

!testRun: #JpegTest #testBA16bppLE63 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testBA32bpp stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testBA32bpp63 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGray stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGray61 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGray62 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGray63 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGrayBA stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGrayBA61 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGrayBA62 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #JpegTest #testGrayBA63 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #AffineTransformationTest #testComposition stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #AffineTransformationTest #testDisplayBounds stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #AffineTransformationTest #testFloatInverseTransform stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #AffineTransformationTest #testFloatTransform stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #AffineTransformationTest #testInverseTransformation stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #LayoutMorphTest #testLayout1 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #LayoutMorphTest #testLayout2 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #LayoutMorphTest #testLayout3 stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #MorphicLocationTest #testComposition stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #MorphicTranslationTest #testComposition stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #MorphicTranslationTest #testDisplayBounds stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #MorphicTranslationTest #testInverseTransform stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #MorphicTranslationTest #testInverseTransformation stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #MorphicTranslationTest #testTransform stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #WorldTest #testDoOneCycleWorksWithDeferredQueue stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TaskbarTest #testClassSingleton stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TaskbarTest #testHorizontalAlignment stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TaskbarTest #testWidth stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertChangesByPassesWhenActionChangesConditionByTheSpecifiedAmount stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertChangesFromToPassesWhenActionChangesConditionFromAndToTheSpecifiedValues stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertChangesPassesWhenConditionIsAlteredByAction stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertDoeNotChangePassesWhenConditionIsNotAlteredByAction stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertIncludesFailsWhenElementIsNotIncludedInCollection stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertIncludesShouldNotFailWhenElementIsInCollection stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToPassesForSameNumberDifferentToZero stamp: 'HAW 8/30/2020 19:11:56'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToPassesWhenBothAreZero stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToPassesWithSameCalculatedNumber stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToWithPrecisionPassesWhenDifferenceIsNegativeAndLessThanPrecision stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testAssertIsCloseToWithPrecisionPassesWhenDifferenceIsPositiveAndLessThanPrecision stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testAssertIsNotCloseWithPrecisionPassesWhenDifferenceIsBiggerThanPrecision stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testIsTestCase stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldFailErrorsWhenNoErrorIsSignaled stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldFailPassesWhenAnErrorIsSignaled stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldNotTakeMoreThanFailsWhenClosureTakesMoreThanTheLimit stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldNotTakeMoreThanPassesWhenClosureTakesLessThanTheLimit stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoCanExpectException stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoFailsWhenNoExceptionIsSignaled stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoFailsWhenOtherExceptionTypeIsSignaled stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoPassSignaledExceptionToAssertionsBlock stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithExceptionDoValuesAssertionsBlockWhenExceptionIsRaised stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithMessageTextDoesNotFailWithRightMessageText stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShouldRaiseWithMessageTextFailsWithDifferentMessageText stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShoulndFailErrorsWhenAnErrorIsSignaled stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestCaseTest #testShoulndFailPassesWhenNoErrorIsSignaled stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test01SuiteForTestCaseClassHasTheSameTestAsCreatingTheSuiteFromTheTestCaseClass stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test02SuiteForNoTestCaseClassUsesTestClassWithSameNameEndingWithTest stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test03SuiteForNoTestCaseClassAndNoTestClassLooksForReferencesInTests stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test04SuiteForTestMethodIncludesOnlyTheMethod stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test05SuiteForNoTestMethodIncludesTestCaseSendingTheCompiledMethodSelector stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test06ForSystemCategoryWithTestCasesIncludesOnlyTestCasesClasses stamp: 'HAW 8/30/2020 19:11:57'!
PASSED!

!testRun: #TestSuiteTest #test07ForSystemCategoryWithNoTestCasesIncludesTestClassesTests stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestSuiteTest #test08ForMessageCategoryContainingTestCasesIncludesThoseTestCases stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestSuiteTest #test09ForMessageCategoryWihoutTestIsEmpty stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestSuiteTest #test10CanNotDebugAsFailureQuickMethods stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #DifferenceFinderTest #testCharacters stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #DifferenceFinderTest #testCharacters2 stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #DifferenceFinderTest #testCode stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #DifferenceFinderTest #testLines stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #DifferenceFinderTest #testWords stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #UnicodeTest #test1ReadBinary stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #UnicodeTest #test2ReadWithOutBinary stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #UnicodeTest #test3ReadUtf8 stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #UnicodeTest #test4BackConversion stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #UnicodeTest #test5ReadWriteUtf8 stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestValueWithinFix #testValueWithinNonLocalReturnFixReal stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestValueWithinFix #testValueWithinNonLocalReturnFixSimply stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestValueWithinFix #testValueWithinTimingBasic stamp: 'HAW 8/30/2020 19:11:58'!
PASSED!

!testRun: #TestValueWithinFix #testValueWithinTimingNestedInner stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TestValueWithinFix #testValueWithinTimingNestedOuter stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TestValueWithinFix #testValueWithinTimingRepeat stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testIsStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNewLineTabWhenConditionIsFalseDoesNotPutANewLineTabInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNewLineTabWhenConditionIsTruePutsANewLineTabInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNewLineWhenConditionIsFalseDoesNotPutANewLineInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNewLineWhenConditionIsTruePutsANewLineInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNextPutAllWhenConditionIsFalseDoesNotPutCollectionInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNextPutAllWhenConditionIsTruePutsCollectionInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNextPutWhenConditionIsFalseDoesNotPutObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testNextPutWhenConditionIsTruePutsObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testPrintWhenConditionIsFalseDoesNotPrintObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testPrintWhenConditionIsTruePrintsObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testSpaceManyTimesWhenConditionIsFalseDoesNotPutASpaceInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testSpaceManyTimesWhenConditionIsTruePutSpacesInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testSpaceWhenConditionIsFalseDoesNotPutASpaceInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testSpaceWhenConditionIsTruePutsASpaceInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testTabManyTimesWhenConditionIsFalseDoesNotPutATabInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testTabManyTimesWhenConditionIsTruePutsTabsInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testTabWhenConditionIsFalseDoesNotPutATabInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #WriteStreamTest #testTabWhenConditionIsTruePutsATabInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testNewLineWhenConditionIsFalseDoesNotPutANewLineInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testNewLineWhenConditionIsTruePutsANewLineInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testNextPutAllWhenConditionIsFalseDoesNotPutCollectionInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testNextPutAllWhenConditionIsTruePutsCollectionInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testNextPutWhenConditionIsFalseDoesNotPutObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testNextPutWhenConditionIsTruePutsObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testPrintWhenConditionIsFalseDoesNotPrintObjectInStream stamp: 'HAW 8/30/2020 19:11:59'!
PASSED!

!testRun: #TranscriptTest #testPrintWhenConditionIsTruePrintsObjectInStream stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #TranscriptTest #testSpaceWhenConditionIsFalseDoesNotPutASpaceInStream stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #TranscriptTest #testSpaceWhenConditionIsTruePutsASpaceInStream stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #TranscriptTest #testTabWhenConditionIsFalseDoesNotPutATabInStream stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #TranscriptTest #testTabWhenConditionIsTruePutsATabInStream stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ColorTest #testIsColor stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #RectangleTest #testIsRectangle stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ColorFormTest #testIsColorForm stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #GrayFormTest #testIsGrayForm stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ObjectTest #testErrorSignalsTheRightException stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ObjectTest #testShouldNotHappenBecauseSignalsTheRightError stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ObjectTest #testShouldNotHappenSignalsTheRightError stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #WeakMessageSendTest #testIsMessageSend stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #test01DefaultStringVersionIsClassAndSelector stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #test02CanPrefixStringVersion stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testActualClassIfAbsentEvaluatesBlockIfClassDoesNotExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testActualClassIfAbsentReturnsClassIfClassExists stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testActualClassReturnNilWhenClassDoesNotExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testActualClassReturnsClassIfExists stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testCompiledMethodIfAbsentEvaluatesAbsentBlockWhenActualClassIsNil stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testCompiledMethodIfAbsentEvaluatesAbsentBlockWhenSelectorIsNotImplemented stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testCompiledMethodIfAbsentReturnsImplementedMethodWhenItExists stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testReferencesParameterAtReturnsFalseWhenInvalid stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testReferencesParameterAtReturnsTrueWhenTheParameterIsReferenced stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testSourceCodeIfAbsentEvaluatesBlockIfClassDoesNotExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testSourceCodeIfAbsentEvaluatesBlockIfMethodDoesNotExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testSourceCodeIfAbsentReturnsSourceCodeIfExists stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testSourceCodeReturnsSourceCodeIfMethodExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testSourceCodeSignalExceptionIfClassDoesNotExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #MethodReferenceTest #testSourceCodeSignalExceptionIfMethodDoesNotExist stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsNotValidBinarySelectorIfItContainsACharacterNotAllowed stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsNotValidKeywordSelectorIfItContainsSeparators stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsNotValidUnarySelectorIfItContainsCharactersUsedInBinarySelectors stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsNotValidUnarySelectorIfItStartsWithALetterAndContainsSeparators stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsValidBinarySelectorIfItContainsAnAllowedCharacterOrSequenceOfCharacters stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsValidKeywordSelectorIfItContainsKeywordsWithColons stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #SymbolTest #testIsValidUnarySelectorIfItStartsWithALetterAndDoesNotContainSeparators stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test01WhenIsImplementedOnlyInRootReturnsThatImplementorOnly stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test02ReturnsImplementorsOfSuperclasses stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test03IfNotImplementedInRootOrSuperclassesDoesNotIncludeSubclassesImplementations stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test04IncludesSubclassesImplementations stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test05DoesNotIncludeImplementorsOfSubclassesNotDefinedInSuperclass stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test06DoesNotIncludeImplementorsOfSiblingsWhenNotDefinedInSuperclass stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test07ReturnsAllSubclassesImplementorsOfTheHighestImplementorClass stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test08highestClassImplementingSelectorReturnsHighgestClass stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualImplementorsTest #test09WhenNoHighestClassImplementingSelectorIfNoneBlockIsEvaluated stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test01SurelyRecognizeTypeSenderWhenSentToInstanceVariable stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test02SurelyRecognizeTypeSenderWhenSentToTemporaryVariable stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test03SurelyRecognizeTypeSenderInACollaboration stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test04RecognizeTypeSendersToInstancesOfSubClasses stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test05RecognizeTypeSendersToLiteralTrue stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test06RecognizeTypeSendersToLiteralFalse stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test07RecognizeTypeSendersToThisContext stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test08RecognizeTypeSendersToSelf stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test09RecognizeTypeSendersToSuper stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test09_01 stamp: 'HAW 8/30/2020 19:12:00'!
PASSED!

!testRun: #ActualSendersTest #test10RecognizeTypeSendersToSelfOfMessageImplementedInSuperclass stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test11RecognizeTypeSendersToReturnsOfMessageSend stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test12RecognizeTypeSendersOfChainedMessageSends stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test13RecognizeTypeSendersToReturnOfMessageSendNoMatterThePrecedence stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test14RecognizeTypeSendersToClasses stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test15RecognizeTypeSendersToVariablesReferencingClasses stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test16RecognizeTypeSendersToAnyLiteral stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test17CanRecognizePossibleTypeSenders stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test18RecognizeTypeSendersWhenReturnTypeIsSelfType stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test19RecognizeTypeSendersWhenReturnTypeIsClassType stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test20SurelySendWhenReceiverTypeIsSuperclassOfImplementorType stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test21ActualSendersWorksWithCascadeMessageSends stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ActualSendersTest #test22ActualSendersDoesNotHangWhenReceiverIsTempVarInMethodWithoutTypes stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test01topBlockTempsMapReturnsTheTempsMapOfTheMethod stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test02MethodWithNoParametersNoTemporariesAreInitializedCorrectly stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test03MethodWithOnlyOneArgumentAreInitializedCorrectly stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test04rawTypesOfInvalidVariableNameEvaluatesIfAbsentBlock stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test05MethodWithOnlyOneTempTwoArgumentsAreInitializedCorrectly stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test06MethodWithRemoveVectorVariablesAreInitializedCorrectly stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test07RemoteVectorRawTypesIsNilWhenMethodHasNoVariableInRemoteVector stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test08VariableRawTypesIsNilWhenMethodHasNoVariableButHasInRemoteVector stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #AdditionalMethodStateTest #test09CanGetRawTypesWhenMethodHasNoVariableButHasInRemoteVector stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #ClosureVariablesTest #testOneArrayForTypesIsCreatedWhenAMethodHasNoClosures stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test01TypeConvertionForAClassReturnsSameClass stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test02TypeConvertionForSelfTypeReturnsReceiversType stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test03TypeConvertionForClassTypeReturnsReceiversTypeClass stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test04ClassMessageSendChainsClassType stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test05TypeConvertionForInstanceTypeReturnsMetaclassSoleInstance stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test06newTypeIsMetaclassSoleInstance stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test07InstanceTypeReturnsClassWhenIsKindOfOfBehaviorButNotMeta stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test08InstanceTypeErrorsWhenUsedWithNoBehavior stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #DynamicTypesTest #test09ClassTypeForMetamodelIsMetaclass stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test01TypeCollectionOfInstanceVariableDefinedInLeafClassDoesNotTraverseHierarchy stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test02TypeCollectionIncludesSubclasses stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test03TypeCollectionDoesNotIncludeSuperclassesAndSiblings stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test05TypeCollectionIncludesAllSubclasses stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test06IsNotMegamorphicIfTypesSizeIsLessToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test07IsMegamorphicIfTypesSizeIsEqualToTheMaxOfWithAllSubclassesRawTypesSize stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test08IsNotMegamorphicIfDoesNotFillRawTypesForLocalTypeInfo stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test09IsMegamorphicIfFillsRawTypesOfDefiningClassForLocalTypeInfo stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test10IsMegamorphicIfFillsRawTypesOfNotDefiningClassForLocalTypeInfo stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test11IsTypesEmptyOfNonLocalTypeInfoTakesCareOfHierarchy stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test12IsTypesEmptyForLocalTypeInfoOnlyCheckOnLocalRawTypes stamp: 'HAW 8/30/2020 19:12:01'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'HAW 8/30/2020 19:12:01'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'HAW 8/30/2020 19:12:02'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #InstanceVariableTypeInfoTest #test13RemovingAClassRemovesItAndItsClassFromInstanceVariableRawTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariableTypeInfoTest #test14InstVarAtPutKeepTypeInfo stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test01InstanceVariablesTypesIsInitializedWithAnArrayOfClassInstSize stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test02InitializeInstanceVariablesTypesWithAllInstancesStoreCurrentClassInstancesTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test03TypesOfDifferentInstVarsAreStoredCorrectly stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test04MoreThanOneTypeAreStoredCorrectlyInDifferentInstVars stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test05TypesAreStoredUpToInstVarTypesSize stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test06NoTypesAreStoredWhenInstVarTypesIsNil stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test07CommonSupertypeOfReturnsSupertypeOfStoredTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test08CommonSupertypeIfNoTypesEvaluatesAlternativeBlockWhenNoTypeHasBeenStore stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #InstanceVariablesTypesTest #test09EvaluatesIfAbsentBlockWhenAskTypeInfoForNonExistingInstVar stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test01KeepTypesOfLocalTemporariesI stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test02KeepTypesOfRemoteTemporaries stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test03KeepTypesOfParameters stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test04KeepReturnTopTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test05KeepReturnConstantTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test06KeepReturnReceiverTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test07KeepReturnFromClosureTypes stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test08KeepReturnTypeWhenUnwind stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test09BlockReturnDoesNotAffectMethodReturn stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test10KeepTypesOfParametersWhenSendingValueWithArguments stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #LiveTypingCodeSimulationTest #test11BlockWithParametersDoNotAffectMethodParameters stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #MethodNotAnnotatingTypesTest #test01CanSignalItWithAMethod stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!testRun: #MethodNotAnnotatingTypesTest #test02IsResumable stamp: 'HAW 8/30/2020 19:12:02'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'HAW 8/30/2020 19:12:02'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'HAW 8/30/2020 19:12:03'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test01RemovingAClassRemovesItFromMethodVariableRawTypesForParameter stamp: 'HAW 8/30/2020 19:12:03'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'HAW 8/30/2020 19:12:03'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'HAW 8/30/2020 19:12:03'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test02RemovingAClassRemovesItsClassFromMethodVariableRawTypesForParameter stamp: 'HAW 8/30/2020 19:12:04'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'HAW 8/30/2020 19:12:04'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'HAW 8/30/2020 19:12:04'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test03RemovingAClassRemovesItFromMethodVariablesRawTypes stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'HAW 8/30/2020 19:12:05'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'HAW 8/30/2020 19:12:05'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #MethodVariableTypeInfoTest #test04RemovingAClassRemovesItFromMethodVariableRemoteVectorRawTypes stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test01ActualSendersIsEmpty stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test02CategoryIsNil stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test03CompiledMethodSignalsError stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test04CompiledMethodIfAbsentEvaluatesIfAbsentBlock stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test05doesOnlySurelySendReturnsFalse stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test06dynamicTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test07IsNotValid stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test08liveTypingAutoCompleterDocumentationReturnsEmptyText stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test09rangesOASentSelectorWhenSendToReceiverTypesIsEmpty stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test10FailsWhenAsItsSourceCode stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #NotImplementedMethodTest #test11StringVersionStartsWithNotImplemented stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #PossibleSenderTest #test01StringVersionBeginsWithPossible stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test01QuickReturnSelfMethodsReturnSelfTypeAsReturnType stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test02QuickReturnTrueMethodsReturnTrueReturnType stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test03QuickReturnFalseMethodsReturnFalseAsReturnType stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test04QuickReturnNilMethodsReturnUndefinedObjectAsReturnType stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test05QuickReturnMinusOneMethodsReturnSmallIntegerAsReturnType stamp: 'HAW 8/30/2020 19:12:05'!
PASSED!

!testRun: #ReturnTypeInfoTest #test06QuickReturnZeroMethodsReturnSmallIntegerAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test07QuickReturnOneMethodsReturnSmallIntegerAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test08QuickReturnTwoMethodsReturnSmallIntegerAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test09QuickReturnOfFirstInstanceVariableMethodsReturnInstanceVariableTypesAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test10QuickReturnOfSecondInstanceVariableMethodsReturnInstanceVariableTypesAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test11classMethodReturnsClassTypeAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test12newMethodReturnsInstanceTypeAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test13yourselfMethodReturnsSelfTypeAsReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!classDefinition: #LiveTypingClassToBeRemoved category: #'__LiveTyping-TestData__' stamp: 'HAW 8/30/2020 19:12:06'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!classRemoval: #LiveTypingClassToBeRemoved stamp: 'HAW 8/30/2020 19:12:06'!
Object subclass: #LiveTypingClassToBeRemoved
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__LiveTyping-TestData__'!

!testRun: #ReturnTypeInfoTest #test14RemovingAClassRemovesItAndItsClassFromMethodReturnType stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test15ReturnTypesOfAbstractMethodsIncludesSubclassesImplementationsTypes stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #ReturnTypeInfoTest #test16ReturnTypesOfAbstractMethodWorksWhenNotImplementedInAllSubclasses stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test01IsEmptyWhenAllTypesAreNil stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test02StoresAddedTypes stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test03StoresSameTypeOnce stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test04StoresMoreThanOneTypeCorrectly stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test05DoesNotStoreTypesWhenContainerIsNil stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test06CommonSupertypeOfSiblingsClassesReturnsRightSuperclass stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test07CommonSupertypeOnSameHierarchyIsMostTopClass stamp: 'HAW 8/30/2020 19:12:06'!
PASSED!

!testRun: #VariableTypeInfoTest #test08CommonSupertypeOnSameHierarchyIsNotAffectedByAddingOrder stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test09ObjectIsCommonSupertypeWhenClassesAreNotSiblings stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test10ProtoObjectIsCommonSupertypeWhenThereAreNoTypesStored stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test11ProtoObjectIsCommonSupertypeWhenCointainerIsNil stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test12CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenIsEmpty stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test13CommonSupertypeIfNoTypesReturnsAlternativeClosureValueWhenContainerIsNil stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test14UndefinedObjectIsNotConsideredWhenLookingForCommonSupertype stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test15StoresTypesIsTrueWhenContainerIsNotNil stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test16StoresTypesIsFalseWhenContainerIsNil stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test17IsMegamorphicWhenContainerIsFull stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test18IsNotMegamorphicWhenContainerIsNotFull stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test19CommonSelectorsPreviousToSameOnlyTypeIsEmpty stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test20CommonSelectorsPreviousToSuperclassOfOnlyAddedTypeAreAddedTypeSelectors stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test21CommonSelectorsPreviousToSuperclassSuperclassOfOnlyAddedTypeAreAddedTypeUpToSuperclassSelectors stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test22CommonSelectorsPreviousToInvalidSuperclassRaisesError stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test23CommonSelectorsPreviousToSuperclassOfSiblingTypesAreSiblingsCommonSelectors stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test24CommonSelectorsPreviousToOnSameHierarchyReturnsCommonSuperclassesSelectors stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test25CommonSelectorsPreviousToAddedSSupertypeOnSameHierarchyIsEmpty stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test26CommonSelectorsPreviousToWhenNotStoringTypesIsEmpty stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test27CommonSelectorsPreviousToIfInvalidSupertypeEvaluatesInvalidBlock stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test28CommonSelectorsPreviousToIfInvalidSupertypeWithManyTypesEvaluatesInvalidBlock stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test29CommonSelectosGoesUpToIncludingProtoObject stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test30CommonSupertypeIfGenericEvaluatesIfGenericBlockForObject stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test31CommonSupertypeIfGenericEvaluatesIfGenericBlockForProtoObject stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test32WithCommonSupertypeDoIfGenericEvaluatesDoBlockWhenNoGenericSupertype stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test33WithCommonSupertypeDoIfGenericEvaluatesGenericBlockWhenGenericSupertype stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test34AddingATypeWhenNoMoreSpaceEvaluatesIsFullBlock stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test35TypeIsNotMoreInTypesWhenRemoved stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test36RemovingTypeWhenTypesIsEmptyEvaluatesIfAbsent stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test37RemovingNotIncludedTypeEvaluatesIfAbsent stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test38RemovingLastAddedTypeWorksAsExpected stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test39RemoveTypeSignalExceptionWhenTypeNotFound stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #VariableTypeInfoTest #test40TypesDoEvaluatesBlockOnEachType stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test01ManyMethodsCanBeTypeChecked stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test02ClassesCanBeTypeChecked stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test03MethodsWithoutTypeAnnotationsLogsAProblem stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test04ProblemsDetectIfNone stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test05ProblemsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test06WarningsCollectsAllTypeCheckersWarnings stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test07ErrorsDetectIfNone stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test08ErrorsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test09ProblemsCollectsTypeCheckersProblems stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test10WarningsDetectIfNone stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test11WarningsDetectIfNoneValuesIfNoneWhenNoProblemFound stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test12HasErrorsReturnsTrueIfATypeCheckerHasErrors stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test13HasErrorsReturnsFalseWhenNoErrorFound stamp: 'HAW 8/30/2020 19:12:07'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test14ErrorsCollectsAllTypeCheckersErrors stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #ManyMethodsTypeCheckerTest #test15HasErrorsOrWarnings stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test01MethodNotAnnotatingTypesGeneratesWarning stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test02EmptyMethodDoesNotGenerateWarningsOrErrors stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test03MessageSendNotUnderstoodByReceiverGeneratesError stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test04MessageUnderstooodByReceiverDoesNotGenerateErrors stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test05ErrorsWhenNoTypeImplementMessageSent stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test06DifferentErrorsAreReported stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test07ReceiverWithoutTypesGeneratesWarning stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test08GivesAWarningWhenReceiversTypeHasAnError stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test09WhenMethodHasNoReturnTypesAProblemIsAdded stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test10PrimitiveMethodsAreNotTypedChecked stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test11IfNotNilFiltersUndefinedObjectType stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test12IfNotNilDoesNotFiltersUndefinedObjectTypeForNotCheckedObject stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test13ComparingForNilWithIfTrueIfFalse stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test14ComparingForNilWithIfTrueIfFalseWhenNilFiltersOtherTypes stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test15ComparingForNilWithIfTrueIfFalseWhenNilKeepsUndefinedObject stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test16NestedIfNotNilFiltersUndefinedObjectType stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test17NestedIfNotNilDoesNotFilterUndefinedObjectWhenOutsideRightIfNotNil stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test18IfNilAssumesUndefinedObjectAsType stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test19NestedIfNilAssumesUndefinedObjectAsType stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test20NestedIfNilDoesUseUndefinedObjectWhenOutsideRightIfNil stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test21IfNilIfNotNilWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test22IfNotNilIfNilWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test23EqualsNilIfTrueIfFalseWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test24EqualsNilIfTrueWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test25IdenticalToNilIfTrueWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test26EqualsNilIfFalseWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test27IdenticalToNilIfFalseWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test28EqualsToNilIfFalseIfTrueWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test29IdenticalToNilIfFalseIfTrueWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test30nilEqualsToIfTrueIfFalseOrIfFalseIfTrueWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test31nilEqualsToIfTrueOrIfFalseWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test32nilIdenticalToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test32_01_nilNotIdenticalOrEqualToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test33NotEqualToNilWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test34NotIdenticalToNilWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test35isNilWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test36notNilWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test37TypeCastWithEqualOrIdenticalToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test38TypeCastWithNotEqualOrNotIdenticalToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test39TypeCastToUsingEqualOrIdenticalToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test40TypeCastToUsingNotEqualOrNotIdenticalToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test41TypeCastUsingIsKindOfToWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test42TypeCheckMessageWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test43TypeCheckMessageSentToSelfWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test44TypeCheckMessageWorksAsExpected stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test46TypeCastRejectsCanBeNested stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test47IsKindOfCastingAllowsSubtypes stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test48IfNotNilWithBlockArgumentFiltersUndefinedObject stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test49TypeCastWithBlockInRejectBlockKeepsCastingStrategy stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test50TypeCastWithoutBlockShouldFail stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test51NotNilAndFiltersUndefinedObject stamp: 'HAW 8/30/2020 19:12:08'!
PASSED!

!testRun: #MethodTypeCheckerTest #test52CascasdeMessageSendAreTypeChecked stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test53TypeCastWorksOnCascadeMessageSends stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test54IfNilWithReturnRejectsNilInNextColaborations stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test55TypeCheckMessageWithSubclassesReturningFalse stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test56Float_store_on_hasNoTypeErrors stamp: 'HAW 8/30/2020 19:12:09'!
FAILURE!

!testRun: #MethodTypeCheckerTest #test57TypeCheckMessageWithFalse_True_False_InSubclassesCastCorrectly stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test58TypeCheckMessageWithReturnOnIfTrueRejectsTypeInNextColaborations stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test59TypeCheckMessageWithReturnOnIfFalseRejectsTypeInNextColaborations stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test60TypeCastWithReturnOnIfTrueRejectsTypeInNextColaborations stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test61TypeCastWithReturnOnIfFalseRejectsTypeInNextColaborations stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test62ifNotNilifNotNilWithMoreThanAMessageSendAndNilAsValue stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test63orCheck stamp: 'HAW 8/30/2020 19:12:09'!
FAILURE!

!testRun: #MethodTypeCheckerTest #test64notNilAndIfTrue stamp: 'HAW 8/30/2020 19:12:09'!
FAILURE!

!testRun: #MethodTypeCheckerTest #test65isNilOr stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test66DoesNotFailsWithMessageSendAsConditionOfIfTrueWithCascadeSend stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test66orWithoutMessageAsReceiverShouldNotError stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test67andWithoutMessageAsReceiverShouldNotError stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #MethodTypeCheckerTest #test68DoesNotFailsWithIfTrueSendInCascadeMode stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #DenotativeObjectRenameMethodApplierTest #test01ScopeOptionsAreTheSame stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #DenotativeObjectTest #test01IsDenotativeObjectNamedReturnsTrueForADenotativeObject stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #DenotativeObjectTest #test02IsDenotativeObjectNamedReturnsFalseForANoDenotativeObject stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #TestChangesTest #testDataClassName stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitConversion stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitConversion2 stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitGradualUnderflow stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitInfinities stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitNaN stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitRoundingMode stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #test32bitZeros stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testAdd stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testArCosh stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testArSinh stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testArTanh stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testArcTan stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testArcTanNonPrimitive stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testAsTrueFraction stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testCeiling stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testCharacterization stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testComparisonWhenPrimitiveFails stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testComparisonWithFraction stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testCopy stamp: 'HAW 8/30/2020 19:12:09'!
PASSED!

!testRun: #FloatTest #testCopySign stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testCos stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testCosh stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testDegreeCos stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testDegreeCosForExceptionalValues stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testDegreeSin stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testDegreeSinForExceptionalValues stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testDivide stamp: 'HAW 8/30/2020 19:12:10'!
ERROR!

!testRun: #FloatTest #testDivide stamp: 'HAW 8/30/2020 19:12:10'!
ERROR!

!testRun: #FloatTest #testDivide stamp: 'HAW 8/30/2020 19:12:10'!
ERROR!

!testRun: #FloatTest #testDivide stamp: 'HAW 8/30/2020 19:12:10'!
ERROR!

!testRun: #FloatTest #testDivide stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testE stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testEqualityComparison stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testEquals stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testExactAsString stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testExactAsString2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testExactStoreString stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testExactStoreString2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testExp stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testExpNonPrimitive stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFloatRounded stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFloatTruncated stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFloatsAwayFrom stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFloatsAwayFromWithPowersOfTwo stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFloor stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFloorLog2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFractionAsFloat stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFractionAsFloat2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFractionAsFloatRoundsHalfToEven stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFractionAsFloatWithUnderflow stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testFromStringDoesNotUnderflow stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithBigNegativeSmallInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithBigSmallInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithFraction stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithLargeNegativeInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithLargePositiveInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithSmallishLargeNegativeInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithSmallishLargeNegativeInteger2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithSmallishLargePositiveInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHashWithSmallishLargePositiveInteger2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testHugeValues stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testInfinity1 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testInfinity2 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testInfinityTruncated stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testIntegerAsFloat stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testIsDenormalized stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testIsZero stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testLiteralEqualityOfNan stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testLiteralEqualityOfZeroAndNegativeZero stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testLn stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testLnForExceptionalValues stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testLnNonPrimitive stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testMaxExactInteger stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testMinimalAsString stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testMixedTypeArithmetic stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testMixedTypeComparison stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testMultiply stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testNaN1 stamp: 'HAW 8/30/2020 19:12:10'!
PASSED!

!testRun: #FloatTest #testNaN2 stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNaN3 stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNaN4 stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNaNCompare stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNaNPropagationBinary stamp: 'HAW 8/30/2020 19:12:11'!
FAILURE!

!testRun: #FloatTest #testNaNPropagationUnary stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNaNTruncated stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNaNisLiteral stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNextAwayFromZero stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNextTowardsZero stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testNoIntegerHash stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPartBits stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPi stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPositiveAndNegativeZero stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPredecessorSuccessor stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPredecessorSuccessor2 stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimAdd stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimArcTan stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimDivideBy stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimEqual stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimExpAndLn stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimExponent stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimGreater stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimGreaterEqual stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimLess stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimLessEqual stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimMultiplyBy stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimNotEqual stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimSin stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimSmallIntegerAsFloat stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimSqrt stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimSubtract stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimTimesTwoPower stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrimTruncated stamp: 'HAW 8/30/2020 19:12:11'!
FAILURE!

!testRun: #FloatTest #testPrintShowingDecimalPlaces4 stamp: 'HAW 8/30/2020 19:12:11'!
PASSED!

!testRun: #FloatTest #testPrintStringStress stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testReadFromManyDigits stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testReciprocal stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testReciprocal stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testRoundHalfToEven stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testRounded stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSetOfFloat stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSignificandAndExponent stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSignificandAsInteger stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSin stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSinNonPrimitive stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSinh stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSomeNines stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSqrt stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSqrtNonPrimitive stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testStoreBase16 stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testStoreOn stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testStringAsFloatRoundsHalfToEven stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testStringAsFloatRoundsHalfToEven2 stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testStringAsNumber stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testStringAsNumber2 stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testSubtract stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testTanh stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testTimesTwoPowerGradualUnderflow stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testTimesTwoPowerOverflow stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testTimesTwoPowerUnderflow stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testTruncated stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testUlp stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testZeroAbs stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testZeroDividedByZero stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroDividedByZero stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroDividedByZero stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroDividedByZero stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroDividedByZero stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
ERROR!

!testRun: #FloatTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testZeroSign stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FloatTest #testZeroSignificandAsInteger stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testCeiling stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testDegreeCos2 stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testDegreeSin2 stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testExactRaisedTo stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testExactSqrt stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testFloor stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testFloorLog stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testFloorLogExactness stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testFractionPrinting stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testHash stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testInexactRaisedTo stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testInexactSqrt stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testIntegerWholeDivision stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testIntegerWholeMultiplication stamp: 'HAW 8/30/2020 19:12:12'!
PASSED!

!testRun: #FractionTest #testIsType stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testLog stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testNthRoot stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testReciprocal stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testRoundHalfToEven stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testRounded stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testThatFractionDenominatorIsPositive stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testThatFractionIsReduced stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testTruncated stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testWholeDifference stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testWholeDivision stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testWholeMultiplication stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #FractionTest #testWholeSum stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testAndSingleBitWithMinusOne stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testLargeShift stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testMixedSignDigitLogic stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testNBitAndNNegatedEqualsN stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testNNegatedEqualsNComplementedPlusOne stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testShiftMinusOne1LeftThenRight stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerDigitLogicTest #testShiftOneLeftThenRight stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #test01readFromWithEmptyStringRaisesAnError stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #test02readFromWithInvalidStringRaisesAnError stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLnLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLnLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLnSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLnSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLpLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLpLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLpSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashLpSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSnLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSnLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSnSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSnSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSpLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSpLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSpSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBackslashBackslashSpSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBenchFib stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBigReceiverInexactNthRoot stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBigReceiverInexactSqrt stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBitAt stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBitLogic stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBitReversal stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testBitReversalCorrectClass stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testCrossSumBase stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDifferentBases stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLnLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLnLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLnSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLnSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLpLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLpLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLpSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivLpSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSnLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSnLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSnSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSnSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSpLn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSpLp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSpSn stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testDivSpSp stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testEven stamp: 'HAW 8/30/2020 19:12:13'!
PASSED!

!testRun: #IntegerTest #testExactRaisedTo stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testExactSqrt stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testFloorLog stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testFloorLogExactness stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testGCDAndLCM stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testGCDExample stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testGCDProperties stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testHighBit stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testHighBitOfMagnitude stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIntegerDivision stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIntegerPadding stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIntegerReadFrom stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIsInteger stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIsPowerOfTwo stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIsPowerOfTwoM6873 stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIsPrime stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testIsProbablyPrime stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testLCMExample stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testLCMProperties stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testLargePrimesUpTo stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testLn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testLog stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testLowBit stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLnLn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLnLp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLnSn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLnSp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLpLn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLpLp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLpSn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModLpSp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSnLn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSnLp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSnSn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSnSp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSpLn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSpLp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSpSn stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testModSpSp stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testMontgomeryMultiplication stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNegativeIntegerPrinting stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNew stamp: 'HAW 8/30/2020 19:12:14'!
ERROR!

!testRun: #IntegerTest #testNew stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNthRoot stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNthRootErrorConditions stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNthRootExactness stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNthRootExactnessForHugeValue stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNthRootImmuneToDoubleRounding stamp: 'HAW 8/30/2020 19:12:14'!
PASSED!

!testRun: #IntegerTest #testNthRootTruncated stamp: 'HAW 8/30/2020 19:12:15'!
PASSED!

!testRun: #IntegerTest #testNumberOfDigits stamp: 'HAW 8/30/2020 19:12:15'!
PASSED!

!testRun: #IntegerTest #testPositiveIntegerPrinting stamp: 'HAW 8/30/2020 19:12:15'!
PASSED!

!testRun: #IntegerTest #testPrimesUpTo stamp: 'HAW 8/30/2020 19:12:15'!
PASSED!

!testRun: #IntegerTest #testPrintOnBaseShowRadix stamp: 'HAW 8/30/2020 19:12:15'!
PASSED!

!testRun: #IntegerTest #testPrintStringBase stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLnLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLnLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLnSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLnSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLpLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLpLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLpSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoLpSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoRem stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSnLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSnLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSnSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSnSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSpLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSpLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSpSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testQuoSpSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRaisedToModulo stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRange stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testReadFrom stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLnLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLnLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLnSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLnSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLpLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLpLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLpSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemLpSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSnLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSnLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSnSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSnSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSpLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSpLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSpSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRemSpSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testRomanPrinting stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLnLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLnLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLnSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLnSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLpLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLpLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLpSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashLpSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSnLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSnLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSnSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSnSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSpLn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSpLp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSpSn stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSlashSlashSpSp stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testSqrtFloor stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testStringAsNumber stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testTwoComplementBitLogicWithCarry stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #IntegerTest #testTwoComplementRightShift stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testCompactClassIndex stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testDenormalizedPrintString stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testDigitAt stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testDigitAtPut stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testDigitLength stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testEmptyTemplate stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testMinimumNegativeIntegerArithmetic stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargeNegativeIntegerTest #testReplaceFromToWithStartingAt stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testBitShift stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testCompactClassIndex stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testDenormalizedPrintString stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testDigitAt stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testDigitAtPut stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testDigitLength stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testEmptyTemplate stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testLargeSqrtFloor stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testMultDicAddSub stamp: 'HAW 8/30/2020 19:12:16'!
PASSED!

!testRun: #LargePositiveIntegerTest #testNormalize stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LargePositiveIntegerTest #testReplaceFromToWithStartingAt stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test01readFromWhenTheInitilValueIsNaNTheResultIsNaN stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test02readFromWhenTheInitilValueIsInfinityTheResultIsInfinity stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test03readFromWhenTheInitilValueIsMinusInfinityTheResultIsNegativeInfinity stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test04readFromWhenTheInitilValueIsANegativeNumberTheResultIsThatNumberNegated stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test05readFromWhenTheInitilValueIsJustANumberTheResultIsThatNumber stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test06readFromWhenTheInitialValueIncludesRadixItIsConvertedWithTheIndicatedRadixBase stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test07readFromWhenTheInitialValueIncludesAnInvalidRadixItRaisesAnError stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test08readFromWhenTheInitialValueIncludesANegativeRadixItConvertsTheNumberWithTheIndicatedRadixBase stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #test09readFromWhenTheInitialValueIsEmptyItRaisesAnError stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testFractionPart stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testHash1 stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testHash2 stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testHash3 stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testIntegerPart stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testOne stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testPrintShowingDecimalPlaces stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testPrintShowingDecimalPlaces2 stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testPrintShowingDecimalPlaces3 stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testRaisedTo stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testRaisedToInteger stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testRaisedToIntegerWithFloats stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testReadFrom stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testReciprocal stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #NumberTest #testZeroDivideHandler stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testBasicNew stamp: 'HAW 8/30/2020 19:12:17'!
ERROR!

!testRun: #SmallIntegerTest #testBasicNew stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testDivide stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testEven stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testMaxVal stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testMinVal stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testNew stamp: 'HAW 8/30/2020 19:12:17'!
ERROR!

!testRun: #SmallIntegerTest #testNew stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testOdd stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testPrintPaddedWith stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testPrintString stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #SmallIntegerTest #testZeroRaisedToNegativePower stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testNext stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testNextBits stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testNextBitsInvalid stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testNextInteger stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testNextIntegerInvalid stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testRandomLargeInteger1 stamp: 'HAW 8/30/2020 19:12:17'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testRandomLargeInteger2 stamp: 'HAW 8/30/2020 19:12:19'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testSeedAndRepeatability stamp: 'HAW 8/30/2020 19:12:19'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testSetAtRandom stamp: 'HAW 8/30/2020 19:12:19'!
PASSED!

!testRun: #LaggedFibonacciRandomTest #testSimpleBuckets stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testNext stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testNextBits stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testNextBitsInvalid stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testNextInteger stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testNextIntegerInvalid stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testParkMillerCorrectness stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testParkMillerInitialValues stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testParkMillerSeedCornerCases stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testParkMillerSeedRange stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testRandomLargeInteger1 stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testRandomLargeInteger2 stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testSeedAndRepeatability stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testSetAtRandom stamp: 'HAW 8/30/2020 19:12:20'!
PASSED!

!testRun: #ParkMiller88RandomTest #testSimpleBuckets stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testNext stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testNextBits stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testNextBitsInvalid stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testNextInteger stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testNextIntegerInvalid stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testRandomLargeInteger1 stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testRandomLargeInteger2 stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testSeedAndRepeatability stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testSetAtRandom stamp: 'HAW 8/30/2020 19:12:21'!
PASSED!

!testRun: #ParkMiller93RandomTest #testSimpleBuckets stamp: 'HAW 8/30/2020 19:12:22'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesAAtoAM stamp: 'HAW 8/30/2020 19:12:22'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesANtoAZ stamp: 'HAW 8/30/2020 19:12:23'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesBAtoBM stamp: 'HAW 8/30/2020 19:12:24'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesBNtoBZ stamp: 'HAW 8/30/2020 19:12:25'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesCAtoCM stamp: 'HAW 8/30/2020 19:12:25'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesCNtoCZ stamp: 'HAW 8/30/2020 19:12:26'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesDAtoDM stamp: 'HAW 8/30/2020 19:12:27'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesDNtoDZ stamp: 'HAW 8/30/2020 19:12:27'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesEAtoEM stamp: 'HAW 8/30/2020 19:12:27'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesENtoEZ stamp: 'HAW 8/30/2020 19:12:28'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesFAtoFM stamp: 'HAW 8/30/2020 19:12:29'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesFNtoFZ stamp: 'HAW 8/30/2020 19:12:30'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesGAtoGM stamp: 'HAW 8/30/2020 19:12:30'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesGNtoGZ stamp: 'HAW 8/30/2020 19:12:31'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesHAtoHM stamp: 'HAW 8/30/2020 19:12:31'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesHNtoHZ stamp: 'HAW 8/30/2020 19:12:31'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesIAtoIM stamp: 'HAW 8/30/2020 19:12:31'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesINtoIZ stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesJAtoJM stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesJNtoJZ stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesKAtoKM stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesKNtoKZ stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesLAtoLM stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesLNtoLZ stamp: 'HAW 8/30/2020 19:12:32'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesMAtoMM stamp: 'HAW 8/30/2020 19:12:33'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesMNtoMZ stamp: 'HAW 8/30/2020 19:12:34'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesNAtoNM stamp: 'HAW 8/30/2020 19:12:34'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesNNtoNZ stamp: 'HAW 8/30/2020 19:12:35'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesOAtoOM stamp: 'HAW 8/30/2020 19:12:35'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesONtoOZ stamp: 'HAW 8/30/2020 19:12:35'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesPAtoPM stamp: 'HAW 8/30/2020 19:12:36'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesPNtoPZ stamp: 'HAW 8/30/2020 19:12:37'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesQAtoQM stamp: 'HAW 8/30/2020 19:12:37'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesQNtoQZ stamp: 'HAW 8/30/2020 19:12:37'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesRAtoRM stamp: 'HAW 8/30/2020 19:12:38'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesRNtoRZ stamp: 'HAW 8/30/2020 19:12:38'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesSAtoSM stamp: 'HAW 8/30/2020 19:12:38'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesSNtoSZ stamp: 'HAW 8/30/2020 19:12:39'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesTAtoTM stamp: 'HAW 8/30/2020 19:12:39'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesTNtoTZ stamp: 'HAW 8/30/2020 19:12:39'!
FAILURE!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesTNtoTZ stamp: 'HAW 8/30/2020 19:12:39'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesUAtoUM stamp: 'HAW 8/30/2020 19:12:39'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesUNtoUZ stamp: 'HAW 8/30/2020 19:12:40'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesVAtoVM stamp: 'HAW 8/30/2020 19:12:40'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesVNtoVZ stamp: 'HAW 8/30/2020 19:12:40'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesWAtoWM stamp: 'HAW 8/30/2020 19:12:40'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesWNtoWZ stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesXAtoXM stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesXNtoXZ stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesYAtoYM stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesYNtoYZ stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesZAtoZM stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testDecompilerInClassesZNtoZZ stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #DecompilerTestFailuresCollector #testRemoteTemp stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test000_AutocompletesMessagesFor_GlobalVariables_WithSelectorsFromTheirClasses stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test001_AutocompletesMessagesFor_Self_WithSelectorsFromTheBrowsedClass stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test002_AutocompletesMessagesFor_Super_WithSelectorsFromTheBrowsedClass stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test003_AutocompletesMessagesFor_Super_WithSelectorsForUnknownClassesWhenTheBrowsedClassDoesNotHaveASuperclass stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test004_AutocompletesMessagesFor_True_WithSelectorsFromTrue stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test005_AutocompletesMessagesFor_False_WithSelectorsFromFalse stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test006_AutocompletesMessagesFor_Nil_WithSelectorsFromUndefinedObject stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test007_AutocompletesMessagesFor_Characters_WithSelectorsFromCharacter stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test008_AutocompletesMessagesFor_Numbers_WithSelectorsFromTheirClass stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test009_AutocompletesMessagesFor_Strings_WithSelectorsFromString stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test010_AutocompletesMessagesFor_Symbols_WithSelectorsFromSymbol stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test011_AutocompletesMessagesFor_StringSymbol_WithSelectorsFromSymbol stamp: 'HAW 8/30/2020 19:12:41'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test012_AutocompletesMessagesFor_InstanceVariables stamp: 'HAW 8/30/2020 19:12:42'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test012_AutocompletesMessagesFor_InstanceVariables_WithSelectorsOfInstVarTypes stamp: 'HAW 8/30/2020 19:12:42'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test013_AutocompletesMessagesFor_MethodArguments_WithSelectorsForUnknownClasses stamp: 'HAW 8/30/2020 19:12:43'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test014_AutocompletesMessagesFor_TemporaryVariables_WithSelectorsForUnknownClasses stamp: 'HAW 8/30/2020 19:12:44'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test014_AutocompletesMessagesFor_TemporaryVariables_WithSelectorsOfTempVarTypes stamp: 'HAW 8/30/2020 19:12:44'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test015_AutocompletesMessagesFor_BlockArguments_WithSelectorsForUnknownClasses stamp: 'HAW 8/30/2020 19:12:44'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test016_AutocompletesMessagesFor_BlockTemporaryVariables_WithSelectorsForUnknownClasses stamp: 'HAW 8/30/2020 19:12:45'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test017_AutocompletesMessagesFor_NilWorkspaceVariables_WithSelectorsForUnknownClasses stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test017_AutocompletesMessagesFor_NonNilWorkspaceVariables_WithSelectorsFromTheirClasses stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test018_AutocompletesMessagesFor_ThisContext_WithSelectorsFromMethodContext stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test019_AutocompletesMessagesFor_ClassVariables_WithSelectorsFromTheirClasses stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test020_AutocompletesMessagesFor_PoolConstants_WithSelectorsFromTheirClasses stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test021_AutocompletesMessagesFor_BlockEndings_WithSelectorsFromBlockClosure stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test022_AutocompletesMessagesFor_ArrayEnds_WithSelectorsFromArray stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test023_AutocompletesMessagesFor_RightBraces_WithSelectorsFromArray stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test023_AutocompletingMessagesFor_UnaryMessages stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test024_AutocompletingMessagesFor_RightParenthesis stamp: 'HAW 8/30/2020 19:12:46'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test025_AutocompletesMessagesFor_UnknownIdentifiers_WithSelectorsForUnknownClasses stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test026_AutocompletingMessagesFor_Cascade stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test027_AutocompletesEntriesFor_GlobalVariables_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test028_AutocompletesEntriesFor_PoolConstants_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test029_AutocompletesEntriesFor_WorkspaceVariables_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test030_AutocompletesEntriesFor_ClassVariables_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test031_AutocompletesEntriesFor_InstanceVariables_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test032_AutocompletesEntriesFor_MethodArguments_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test033_AutocompletesEntriesFor_TemporaryVariables_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test034_AutocompletesEntriesFor_BlockArguments_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test035_AutocompletesEntriesFor_BlockTemporaryVariables_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test036_AutocompletesEntriesFor_IncompleteIdentifiers_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test037_AutocompletesEntriesFor_ReservedNames_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test038_DoesNotAutocompleteEntriesFor_UndefinedIdentifiers stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test039_AutocompletesEntriesFor_BinaryMessages_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test040_AutocompletesEntriesFor_IncompleteBinaryMessages_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test041_AutocompletesEntriesFor_UnaryMessages_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test042_AutocompletesEntriesFor_IncompleteUnaryMessages_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:47'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test043_AutocompletesEntriesFor_KeywordMessages_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test044_AutocompletesEntriesFor_IncompleteKeywordMessages_WithIdentifiersBegginingWithThem stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #testMessages stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ArrayWithArrayAndOtherObjects stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArray stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArrayOfArray stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndArrayWithManyElements stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBinaryInParenthesis stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlock stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlockOfBlock stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndBlockOfEvaluatedBlock stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndExpresionInParenthesis stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndLiteralArray stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndMoreThanOneUnaryAfterExpresionInParenthesis stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterBlock stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterBrace stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterCharacter stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterLiteralArray stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterStringSymbol stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndOneUnaryAfterSymbol stamp: 'HAW 8/30/2020 19:12:48'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUnaryInProtoObject stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteKeywordAfterParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteKeywordAfterUnary stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryAndUncompleteMessageAfterUnary stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryInParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryWithMoreThanOneUnary stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_BinaryWithOneUnary stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ClosedAndUnclosedParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ExpressionInManyParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_ExpressionWithMoreThanOneParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_LFBeforeParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_SpaceBeforeParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnaryAfterExpresionInParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedArrayAfterClosedArray stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedBlockAfterBlock stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_UnclosedDoubleParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Browser_selfInProtoObject stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_ExpresionInParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_MoreThanOneUnaryMessage stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!testRun: #LiveTypingSmalltalkCompleterTest #test_Workspace_OnlyRightParenthesis stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:49'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:49'!
griffle [ var1 := 1. goo := 1. ^goo + var1 ]! !

!testRun: #CompilerTest #testAddsMoreThanOneUndeclaredVariableCorrectlyInBlock stamp: 'HAW 8/30/2020 19:12:49'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:50'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:50'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:50'!
griffle [|var1| var1 := 1.goo := 1.^ goo + var1]! !

!testRun: #CompilerTest #testAddsUndeclaredVariableCorrectlyInBlockWhenNoSpaceBetweenLastOneAndPipe stamp: 'HAW 8/30/2020 19:12:50'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:50'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:50'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:50'!
griffle [ :var1 | goo := 1.^ goo + var1]! !

!testRun: #CompilerTest #testAddsUndeclaredVariableCorrectlyInBlockWhenTheresAnArgumentAlready stamp: 'HAW 8/30/2020 19:12:50'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:51'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:51'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:51'!
griffle [ :var1 | | | goo := 1.^ goo + var1]! !

!testRun: #CompilerTest #testAddsUndeclaredVariableCorrectlyInBlockWhenTheresArgumentsAndTempDeclarationPipesWithNoTemps stamp: 'HAW 8/30/2020 19:12:51'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:52'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:52'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:52'!
griffle var1 := 1. [ goo := 1. ^goo + var1 ]! !

!testRun: #CompilerTest #testAddsUndeclaredVariableCorrectlyInMethodAndInBlock stamp: 'HAW 8/30/2020 19:12:52'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:52'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:53'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:53'!
griffle |var1| var1 := 1.goo := 1.^ goo + var1! !

!testRun: #CompilerTest #testAddsUndeclaredVariableCorrectlyInMethodWhenNoSpaceBetweenLastOneAndPipe stamp: 'HAW 8/30/2020 19:12:53'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:53'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:53'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:53'!
griffle [|goo| goo := 1. ^goo ]. [goo1:=1.^ goo1]! !

!testRun: #CompilerTest #testAddsUndeclaredVariableInRightBlock stamp: 'HAW 8/30/2020 19:12:53'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:54'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:54'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:54'!
griffle [ :var1 | | foo | foo := 2. goo := 1.^ goo + var1 + foo ]! !

!testRun: #CompilerTest #testAddsUndeclaredVariableWithAnArgumentAndTempAlreadyInBlock stamp: 'HAW 8/30/2020 19:12:54'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:55'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #CompilerTest #testCanNotDefineVarsInsideBackTick stamp: 'HAW 8/30/2020 19:12:55'!
PASSED!

!testRun: #CompilerTest #testCanNotHaveMoreThanOneExpressionInsideBackTick stamp: 'HAW 8/30/2020 19:12:55'!
PASSED!

!testRun: #CompilerTest #testCanNotHaveReturnInsideBackTick stamp: 'HAW 8/30/2020 19:12:55'!
PASSED!

!testRun: #CompilerTest #testCanNotReferenceSelfInsideBackTick stamp: 'HAW 8/30/2020 19:12:56'!
PASSED!

!testRun: #CompilerTest #testCanNotReferenceSuperInsideBackTick stamp: 'HAW 8/30/2020 19:12:56'!
PASSED!

!testRun: #CompilerTest #testCanNotReferenceTempVarsInsideBackTick stamp: 'HAW 8/30/2020 19:12:56'!
PASSED!

!testRun: #CompilerTest #testCanNotReferenceThisContextInsideBackTick stamp: 'HAW 8/30/2020 19:12:57'!
PASSED!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:57'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:57'!
griffle [ | goo | ]. [ | goo | ]! !

!testRun: #CompilerTest #testDoesNotConfusesVariablesWithSameNameOfDifferentBlocksWhenRemoving stamp: 'HAW 8/30/2020 19:12:57'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:58'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:58'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:58'!
griffle | goo |! !

!testRun: #CompilerTest #testDoesNotRemoveUnusedVariableIfSaidSo stamp: 'HAW 8/30/2020 19:12:58'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:58'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:58'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:58'!
griffle | goo a | a := 1. ^a! !

!testRun: #CompilerTest #testKeepsVariableDefinitionWhenThereAreUsedTemporaries stamp: 'HAW 8/30/2020 19:12:58'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:12:59'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:12:59'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:12:59'!
griffle [ | goo | ]! !

!testRun: #CompilerTest #testRemovesUnusedVariablesFromBlocks stamp: 'HAW 8/30/2020 19:12:59'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:00'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:00'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:13:00'!
griffle | goo |! !

!testRun: #CompilerTest #testRemovesVariableDefinitionWhenNoMoreUnusedTemporaries stamp: 'HAW 8/30/2020 19:13:00'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:00'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:00'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:13:00'!
griffle [ || goo := 1.^ goo ]! !

!testRun: #CompilerTest #testReusesBlockTempDeclarationWhenEmptyForUndeclaredVariable stamp: 'HAW 8/30/2020 19:13:00'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:01'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:01'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!CompilerTestDataClass__ methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:13:01'!
griffle || goo := 1.^ goo! !

!testRun: #CompilerTest #testReusesMethodTempDeclarationWhenEmptyForUndeclaredVariable stamp: 'HAW 8/30/2020 19:13:01'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:02'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:02'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #CompilerTest #testUndeclaredVariableIsSignaledForUndeclaredVariables stamp: 'HAW 8/30/2020 19:13:02'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:02'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:02'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #CompilerTest #testUndefinedVariableIsSignaledForVariablesDefinedButNotInitialized stamp: 'HAW 8/30/2020 19:13:02'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:03'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:03'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #CompilerTest #testUnknownSelectorIsSignalForMessagesSendNotImplemented stamp: 'HAW 8/30/2020 19:13:03'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:03'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #CompilerTestDataClass__ category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:13:03'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #CompilerTest #testUnusedVariableIsSignaledForUnusedVariables stamp: 'HAW 8/30/2020 19:13:03'!
PASSED!

!classRemoval: #CompilerTestDataClass__ stamp: 'HAW 8/30/2020 19:13:04'!
RefactoringClassTestData subclass: #CompilerTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test01AddingAClassShouldBeLogged stamp: 'HAW 8/30/2020 19:13:04'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:05'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test01ScanNewClassChange stamp: 'HAW 8/30/2020 19:13:05'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:05'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test02AddingANewMethodShouldBeLogged stamp: 'HAW 8/30/2020 19:13:05'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:06'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test02ScanNewMethodChange stamp: 'HAW 8/30/2020 19:13:06'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:07'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test03ChangingAMethodShouldBeLogged stamp: 'HAW 8/30/2020 19:13:07'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:07'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test03ScanMethodModifiedChange stamp: 'HAW 8/30/2020 19:13:07'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:08'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test04RemovingAMethodShouldBeLogged stamp: 'HAW 8/30/2020 19:13:08'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:09'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test04ScanMethodRemovalChange stamp: 'HAW 8/30/2020 19:13:09'!
PASSED!

!classRemoval: #LogChangesTestClass__ stamp: 'HAW 8/30/2020 19:13:09'!
RefactoringClassTestData subclass: #LogChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test05RemovingAClassShouldBeLogged stamp: 'HAW 8/30/2020 19:13:10'!
PASSED!

!testRun: #ChangesTest #test05ScanClassRemovalChange stamp: 'HAW 8/30/2020 19:13:10'!
PASSED!

!testRun: #ChangesTest #test06RenamingAClassShouldBeLogged stamp: 'HAW 8/30/2020 19:13:11'!
PASSED!

!classRemoval: #NewTestClass__ stamp: 'HAW 8/30/2020 19:13:11'!
RefactoringClassTestData subclass: #NewTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #test06ScanClassRenamedChange stamp: 'HAW 8/30/2020 19:13:11'!
PASSED!

!classRemoval: #NewTestClass__ stamp: 'HAW 8/30/2020 19:13:12'!
RefactoringClassTestData subclass: #NewTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangesTest #testDataClassName stamp: 'HAW 8/30/2020 19:13:12'!
PASSED!

!testRun: #GreenTest #test01WhenANewTestIsAddedThenIsWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:13'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:13'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test02WhenAProductionMethodIsAddedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:13'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:13:14'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test03WhenAProductionMethodIsChangedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:14'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:13:15'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test04WhenAProductionClassIsAddedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:15'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:13:15'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test05WhenAProductionClassIsRemovedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:16'!
PASSED!

!testRun: #GreenTest #test06WhenATestIsChangedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:16'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:17'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test07WhenATestPassesNothingHappens stamp: 'HAW 8/30/2020 19:13:17'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:18'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test08WhenAMethodIsRemovedIsRefactoring stamp: 'HAW 8/30/2020 19:13:18'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:13:18'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test09WhenATestHasAnErrorAnErrorIsReportedAndTransitionsToRed stamp: 'HAW 8/30/2020 19:13:18'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:19'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test10WhenATestIsRenamedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:19'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:20'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test11WhenATestFailsAnErrorIsReportedAndTransitionsToRed stamp: 'HAW 8/30/2020 19:13:20'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:20'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test12WhenATestIsRemovedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:21'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:21'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test13WhenATestClassIsRemovedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:22'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:22'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test14WhenATestClassIsAddedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:22'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:23'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #GreenTest #test15WhenATestClassIsRenamedThenIsRefactoring stamp: 'HAW 8/30/2020 19:13:23'!
PASSED!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:13:24'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test01WhenAClassIsRemovedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:24'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:25'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test02WhenTheLastOfTheTestsIsRemovedIsBackToWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:25'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:26'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test03WhenTheFirstOfTheTestsIsRemovedIsBackToWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:26'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:26'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test04WhenAnotherTestIsRemovedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:26'!
PASSED!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:13:27'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:27'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test05WhenAMethodIsRemovedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:27'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:28'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:28'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test06WhenAModelMethodIsChangedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:28'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:29'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:29'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test07WhenAModelClassIsAddedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:29'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:30'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:30'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test08WhenAModelMethodIsAddedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:30'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:31'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:31'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test09WhenATestIsAddedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:31'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:32'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test10WhenATestClassIsAddedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:32'!
PASSED!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:13:33'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:33'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test11WhenOneOfTheTestTheTestsIsChangedIsStillInThisState stamp: 'HAW 8/30/2020 19:13:33'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:34'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test12WhenAnotherTestIsChangedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:34'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:34'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test13WhenATestFailsAnErrorIsReportedAndGoesToRed stamp: 'HAW 8/30/2020 19:13:35'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:35'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test14WhenOneOfTheTestsPassesTwoErrorsAreReported stamp: 'HAW 8/30/2020 19:13:35'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:36'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test15WhenAllOfTheTestsPassErrorsAreReportedAndGoesToGreen stamp: 'HAW 8/30/2020 19:13:36'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:37'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test16WhenOneOfTheTestsIsRenamedIsStillInThisState stamp: 'HAW 8/30/2020 19:13:37'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:37'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test17WhenAnotherTestIsRenamedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:37'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:38'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #MoreThanOneTestWrittenTest #test18WhenATestUtilityIsChangedNothingHappens stamp: 'HAW 8/30/2020 19:13:38'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:39'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test01WhenAProductionClassIsAddedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:39'!
PASSED!

!classRemoval: #ProdClassA stamp: 'HAW 8/30/2020 19:13:40'!
Object subclass: #ProdClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test02WhenAProductionMethodIsAddedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:40'!
PASSED!

!classRemoval: #ProdClassA stamp: 'HAW 8/30/2020 19:13:40'!
Object subclass: #ProdClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test03WhenATestIsAddedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:40'!
PASSED!

!classRemoval: #ProdClassA stamp: 'HAW 8/30/2020 19:13:41'!
TestCase subclass: #ProdClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test04WhenATestClassIsAddedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:41'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:42'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test05WhenATestIsChangedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:42'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:42'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test06WhenAProductionMethodIsChangedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:42'!
PASSED!

!classRemoval: #ProductionClassA stamp: 'HAW 8/30/2020 19:13:43'!
Object subclass: #ProductionClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test07WhenAClassIsRemovedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:43'!
PASSED!

!testRun: #NotDoingTDDTest #test08WhenThereIsOneTestAndPassesThenIsInGreen stamp: 'HAW 8/30/2020 19:13:44'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:44'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test09WhenOneOfTheTestFailsThenIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:45'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:45'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test10WhenOneOfTheTestIsNotRunThenIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:45'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:46'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test11WhenATestIsRenamedIsStillNotDoingTDD stamp: 'HAW 8/30/2020 19:13:46'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:47'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test12WhenThereIsMoreThanOneTestAndAllPassThenIsInGreen stamp: 'HAW 8/30/2020 19:13:47'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:47'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test13WhenATestIsRemovedIsNoLongerTakenIntoAccount stamp: 'HAW 8/30/2020 19:13:48'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:48'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test14WhenATestClassIsRemovedIsNoLongerTakenIntoAccount stamp: 'HAW 8/30/2020 19:13:49'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:13:49'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotDoingTDDTest #test15WhenAllTestAreRemovedThenGoesToGreen stamp: 'HAW 8/30/2020 19:13:50'!
PASSED!

!testRun: #NotStartedTest #test01WhenNoChangesAreDoneThenNothingHappens stamp: 'HAW 8/30/2020 19:13:50'!
PASSED!

!testRun: #NotStartedTest #test02WhenAModelClassIsAddedThenWeAsumeIsWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:50'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:51'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test03WhenATestClassIsAddedThenIsWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:51'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:13:52'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test04WhenAProductionMethodIsAddedResultShouldHaveAnError stamp: 'HAW 8/30/2020 19:13:52'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:52'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test05WhenAMethodIsChangedResultShouldHaveAnError stamp: 'HAW 8/30/2020 19:13:52'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:53'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test06WhenATestIsAddedThenIsWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:53'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:54'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test07WhenAClassIsRemovedResultShouldHaveAnError stamp: 'HAW 8/30/2020 19:13:54'!
PASSED!

!testRun: #NotStartedTest #test08WhenAMethodIsRemovedResultShouldHaveAnError stamp: 'HAW 8/30/2020 19:13:55'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:13:55'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test09WhenAllTestsPassThenIsInGreenState stamp: 'HAW 8/30/2020 19:13:55'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:56'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test10WhenATestFailsThenIsInRedState stamp: 'HAW 8/30/2020 19:13:56'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:57'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test11WhenATestHasAnErrorThenIsInRedState stamp: 'HAW 8/30/2020 19:13:57'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:57'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test12WhenATestIsChangedThenIsWritingAFailingTest stamp: 'HAW 8/30/2020 19:13:57'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:58'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #NotStartedTest #test13WhenATestIsRenamedThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:13:58'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:13:59'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test01ShouldIgnoreDoIts stamp: 'HAW 8/30/2020 19:13:59'!
PASSED!

!testRun: #OtherTest #test02ResultKnowsTheChangesThatWereDone stamp: 'HAW 8/30/2020 19:13:59'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:14:00'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test03TDDStateForEachChange stamp: 'HAW 8/30/2020 19:14:00'!
PASSED!

!classRemoval: #TestClass stamp: 'HAW 8/30/2020 19:14:01'!
TestCase subclass: #TestClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test04TestRenamesAreGroupedInASingleChange stamp: 'HAW 8/30/2020 19:14:01'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:01'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test05TestsWithSameNameInDifferentClassesAreDifferent stamp: 'HAW 8/30/2020 19:14:01'!
PASSED!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:14:02'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:02'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test06WhenATestHasAnErrorThisTestDoesNotFail stamp: 'HAW 8/30/2020 19:14:02'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:03'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test07RunFromASpecificChange stamp: 'HAW 8/30/2020 19:14:03'!
PASSED!

!classRemoval: #ExampleClass stamp: 'HAW 8/30/2020 19:14:04'!
Object subclass: #ExampleClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:04'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test08ReRunTheWholeAnalysis stamp: 'HAW 8/30/2020 19:14:04'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:05'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test09ReRunFromASpecificChange stamp: 'HAW 8/30/2020 19:14:05'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:05'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:06'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #OtherTest #test10ChangeWhenAMethodWasAdded stamp: 'HAW 8/30/2020 19:14:06'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:06'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test01WhenAProductionClassIsAddedIsStillInRed stamp: 'HAW 8/30/2020 19:14:06'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:14:07'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:07'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test02WhenAProductionMethodIsAddedIsStillInRed stamp: 'HAW 8/30/2020 19:14:07'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:08'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:08'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test03WhenTheTestPassesThenIsInGreen stamp: 'HAW 8/30/2020 19:14:08'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:09'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:09'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test04WhenTheTestFailsIsStillInRed stamp: 'HAW 8/30/2020 19:14:09'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:10'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:10'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test05WhenAProductionMethodIsChangedIsStillInRed stamp: 'HAW 8/30/2020 19:14:10'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:11'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:11'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test06WhenTheNewTestPassesButAnotherTestFailsThenIsStillInRed stamp: 'HAW 8/30/2020 19:14:12'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:12'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:12'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test07WhenAllTestsPassThenIsInGreen stamp: 'HAW 8/30/2020 19:14:13'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:13'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:14'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test08WhenATestIsAddedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:14'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:14'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test09WhenATestIsRenamedAndAllTestsPassThenIsInGreen stamp: 'HAW 8/30/2020 19:14:14'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:15'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:15'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test10WhenAModelMethodIsRemovedIsStillInRed stamp: 'HAW 8/30/2020 19:14:15'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:16'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:16'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test11WhenAModelClassIsRemovedIsStillInRed stamp: 'HAW 8/30/2020 19:14:17'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:17'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test11WhenATestClassIsAddedIsStillInRed stamp: 'HAW 8/30/2020 19:14:17'!
PASSED!

!classRemoval: #TestSomethingB stamp: 'HAW 8/30/2020 19:14:18'!
TestCase subclass: #TestSomethingB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:18'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test12WhenTheTestIsChangedIsStillInRed stamp: 'HAW 8/30/2020 19:14:18'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:19'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:19'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test13WhenAnotherTestIsChangedIsStillInRed stamp: 'HAW 8/30/2020 19:14:20'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:20'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test14WhenATestIsRemovedResultShouldHaveAnErrorAndIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:20'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:21'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RedTest #test15WhenATestClassIsRemovedResultShouldHaveAnErrorAndIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:21'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:22'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test01WhenAProductionMethodIsChangedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:22'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:23'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test02WhenAProductionMethodIsAddedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:23'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:23'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test03WhenAProductionClassIsAddedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:23'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:14:24'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test04WhenATestIsChangedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:24'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:25'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test05WhenATestIsRenamedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:25'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:26'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test06WhenATestClassIsAddedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:26'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:26'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test07WhenATestIsAddedResultHasAnErrorAndIsWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:26'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:27'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test08WhenAllTestPassThenIsInGreen stamp: 'HAW 8/30/2020 19:14:27'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:28'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test09WhenOneOfTheTestFailsThenIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:28'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:28'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test10WhenAClassIsRemovedIsStillRefactoring stamp: 'HAW 8/30/2020 19:14:29'!
PASSED!

!testRun: #RefactorTest #test11WhenAProductionMethodIsRemovedStillRefactoring stamp: 'HAW 8/30/2020 19:14:29'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:14:30'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test12WhenATestClassIsRemovedThoseTestsAreNoLongerTakenIntoAccount stamp: 'HAW 8/30/2020 19:14:30'!
PASSED!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:14:31'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test13WhenATestIsRemovedIsNoLongerTakenIntoAccount stamp: 'HAW 8/30/2020 19:14:31'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:32'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test14WhenAllTestAreRemovedThenGoesToGreen stamp: 'HAW 8/30/2020 19:14:32'!
PASSED!

!testRun: #RefactorTest #test15WhenAModelMethodIsAddedButNotUsedThereIsAnError stamp: 'HAW 8/30/2020 19:14:32'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:33'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:33'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test16WhenAModelMethodIsAddedAndThenUsedThereAreNoErrors stamp: 'HAW 8/30/2020 19:14:33'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:34'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:34'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test17WhenAModelMethodIsAddedAndRemovedAndIsNotUsedThereAreNoErrors stamp: 'HAW 8/30/2020 19:14:34'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:35'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:35'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test18WhenAModelMethodIsAddedAndIsOnlyMentionedInACommentThereIsAnError stamp: 'HAW 8/30/2020 19:14:36'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:36'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:36'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test19WhenTwoModelMethodsAreAddedBothHaveToBeUsedInAValidRefactor stamp: 'HAW 8/30/2020 19:14:37'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:37'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:37'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test20WhenTwoModelMethodsAreAddedAndNotUsedIsNotAValidRefactor stamp: 'HAW 8/30/2020 19:14:38'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:38'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:38'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test21WhenAModelMethodIsAddedAndIsUsedAsAVariableNameIsNotAValidRefactor stamp: 'HAW 8/30/2020 19:14:39'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:39'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:39'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test22WhenAModelMethodIsNotUsedWhenAnalysisIsFinishedThereIsAnError stamp: 'HAW 8/30/2020 19:14:40'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:40'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:40'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test23WhenATestClassIsRenamedThoseTestsAreStillTakenIntoAccount stamp: 'HAW 8/30/2020 19:14:41'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:41'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:14:42'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #RefactorTest #test24WhenAMethodIsOverridenItIsConsideredUsedAndRefactorIsValid stamp: 'HAW 8/30/2020 19:14:42'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:42'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:43'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test01WhenTheTestIsChangedThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:43'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:43'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test02WhenAModelClassIsAddedThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:43'!
PASSED!

!classRemoval: #ProductionClass stamp: 'HAW 8/30/2020 19:14:44'!
Object subclass: #ProductionClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test03WhenATestClassIsAddedThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:44'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:45'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test04WhenATestFailsThenIsInRedState stamp: 'HAW 8/30/2020 19:14:45'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:45'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test05WhenAModelMethodIsAddedAndNoTestIsBeingWrittenThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:45'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:46'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:46'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test06WhenTheTestIsRenamedThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:46'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:47'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test07WhenAModelMethodIsChangedThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:47'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:14:48'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:48'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test08WhenSetUpMethodIsAddedToTheTestClassThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:48'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:49'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test09WhenAMethodIsAddedToTheTestClassThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:49'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:49'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test10WhenASecondTestIsAddedIsInMoreThanOneTestWritten stamp: 'HAW 8/30/2020 19:14:50'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:50'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test11WhenATestWithTheSameNameIsChangedInOtherClassThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:50'!
PASSED!

!classRemoval: #TestSomethingB stamp: 'HAW 8/30/2020 19:14:51'!
TestCase subclass: #TestSomethingB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:51'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test12WhenADifferentTestIsChangedThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:51'!
PASSED!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:52'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test13WhenATestWithTheSameNameIsAddedInOtherClassThenIsInMoreThanOneTestWritten stamp: 'HAW 8/30/2020 19:14:52'!
PASSED!

!classRemoval: #TestSomethingB stamp: 'HAW 8/30/2020 19:14:53'!
TestCase subclass: #TestSomethingB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:53'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test14WhenAModelMethodIsRemovedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:53'!
PASSED!

!classRemoval: #ModelClassA stamp: 'HAW 8/30/2020 19:14:54'!
Object subclass: #ModelClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:54'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test15WhenTheTestIsRemovedThenIsInGreen stamp: 'HAW 8/30/2020 19:14:54'!
PASSED!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:55'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test16WhenATestIsRenamedThenIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:55'!
PASSED!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:55'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test17WhenAModelClassIsRemovedThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:56'!
PASSED!

!classRemoval: #TestSomethingA stamp: 'HAW 8/30/2020 19:14:56'!
TestCase subclass: #TestSomethingA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test18WhenTheTestPassesAnErrorIsReportedAndGoesToGreen stamp: 'HAW 8/30/2020 19:14:56'!
PASSED!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:14:57'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test19AnotherTestIsRemovedAnErrorIsReportedAndIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:57'!
PASSED!

!classRemoval: #TestClassB stamp: 'HAW 8/30/2020 19:14:58'!
TestCase subclass: #TestClassB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:58'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test20WhenAFirstTestIsAddedIsStillWritingAFailingTest stamp: 'HAW 8/30/2020 19:14:58'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:14:59'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test21WhenAModelMethodIsAddedBeforeRunningTestsThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:14:59'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:15:00'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:15:00'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test22WhenAModelMethodIsChangedBeforeWritingATestThenIsNotDoingTDD stamp: 'HAW 8/30/2020 19:15:00'!
PASSED!

!classRemoval: #ModelClass stamp: 'HAW 8/30/2020 19:15:01'!
Object subclass: #ModelClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestSomething stamp: 'HAW 8/30/2020 19:15:01'!
TestCase subclass: #TestSomething
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #WritingAFailingTestTest #test23WhenATestClassIsRemovedIsNotDoingTDD stamp: 'HAW 8/30/2020 19:15:01'!
PASSED!

!classRemoval: #TestSomethingB stamp: 'HAW 8/30/2020 19:15:02'!
TestCase subclass: #TestSomethingB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test01RunningAPassingTestShouldBeLogged stamp: 'HAW 8/30/2020 19:15:02'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'HAW 8/30/2020 19:15:03'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test02RunningAFailingTestShouldBeLogged stamp: 'HAW 8/30/2020 19:15:03'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'HAW 8/30/2020 19:15:03'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test03RunningATestWithAnErrorShouldBeLogged stamp: 'HAW 8/30/2020 19:15:03'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'HAW 8/30/2020 19:15:04'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test04OverridingAMethodShouldBeLoggedWithAReferenceToTheOverridenMethod stamp: 'HAW 8/30/2020 19:15:04'!
PASSED!

!classRemoval: #SubclassTestDataClass__ stamp: 'HAW 8/30/2020 19:15:05'!
TestChangesTestClass__ subclass: #SubclassTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'HAW 8/30/2020 19:15:05'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test05WhenAMethodIsNotOverridenTheMethodReferenceIsNotIncluded stamp: 'HAW 8/30/2020 19:15:05'!
PASSED!

!classRemoval: #SubclassTestDataClass__ stamp: 'HAW 8/30/2020 19:15:06'!
TestChangesTestClass__ subclass: #SubclassTestDataClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'HAW 8/30/2020 19:15:06'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #LogTestChangesTest #test06WhenAMethodIsChangedItIsNotConsideredOverriden stamp: 'HAW 8/30/2020 19:15:06'!
PASSED!

!classRemoval: #TestChangesTestClass__ stamp: 'HAW 8/30/2020 19:15:07'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test01ScanPassingTestChange stamp: 'HAW 8/30/2020 19:15:07'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'HAW 8/30/2020 19:15:07'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test02ScanFailedTestChange stamp: 'HAW 8/30/2020 19:15:07'!
PASSED!

!classRemoval: 'TestChangesTestData' stamp: 'HAW 8/30/2020 19:15:08'!
TestCase subclass: 'TestChangesTestData'
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test03ScanNewTestClass stamp: 'HAW 8/30/2020 19:15:08'!
PASSED!

!classRemoval: #TestClassA stamp: 'HAW 8/30/2020 19:15:09'!
TestCase subclass: #TestClassA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test04ScanOverridenMethod stamp: 'HAW 8/30/2020 19:15:09'!
PASSED!

!classRemoval: #AClass__ stamp: 'HAW 8/30/2020 19:15:09'!
TestChangesTestClass__ subclass: #AClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'HAW 8/30/2020 19:15:10'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #ScanTestChangesTest #test05ScanAMethodThatIsNotOverriden stamp: 'HAW 8/30/2020 19:15:10'!
PASSED!

!classRemoval: #AClass__ stamp: 'HAW 8/30/2020 19:15:10'!
TestChangesTestClass__ subclass: #AClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!classRemoval: #TestChangesTestClass__ stamp: 'HAW 8/30/2020 19:15:11'!
Object subclass: #TestChangesTestClass__
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__TDDGuru-TestData__'!

!testRun: #BlockNodeTest #testItDoesNotSendsAGivenMessageToSelfWhenTheBlockIsEmpty stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #BlockNodeTest #testItSendsAGivenMessageToSelfWhenItContainsAnStatementWithAMessageSendToSelf stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #MessageNodeTest #testItDoesNotSendTheMessageToSelfWhenTheReceiverIsNotSelf stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #MessageNodeTest #testItDoesNotSendTheMessageToSelfWhenTheReceiverIsSelfButTheSelectorIsDifferent stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #MessageNodeTest #testItSendsTheMessageToSelfWhenTheReceiverIsSelf stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #VariableNodeTest #testItDoesNotReferencesSelfWhenTheVariableNameIsNotSelf stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #VariableNodeTest #testItReferencesSelfWhenTheVariableNameIsSelf stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #AddInstanceVariableTest #test01NewVariableNameCanNotBeEmpty stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #AddInstanceVariableTest #test02NewVariableNameCanNotContainBlanks stamp: 'HAW 8/30/2020 19:15:11'!
PASSED!

!testRun: #AddInstanceVariableTest #test03NewVariableNameCanNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:15:12'!
PASSED!

!testRun: #AddInstanceVariableTest #test04ValidNewVariableNameGetBlanksTrimmed stamp: 'HAW 8/30/2020 19:15:12'!
PASSED!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:12'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddInstanceVariableTest #test05NewVariableNameCanNotBeDefinedInClass stamp: 'HAW 8/30/2020 19:15:12'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:13'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:13'!
RefactoringClassTestData subclass: #SuperclassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:13'!
SuperclassWithInstVar subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddInstanceVariableTest #test06NewVariableNameCanNotBeDefinedInSuperclasses stamp: 'HAW 8/30/2020 19:15:13'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:14'!
SuperclassWithInstVar subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassWithInstVar stamp: 'HAW 8/30/2020 19:15:14'!
RefactoringClassTestData subclass: #SuperclassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:14'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:14'!
ClassToAddInstVar subclass: #SubclassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddInstanceVariableTest #test07NewVariableNameCanNotBeDefinedInAnySubclass stamp: 'HAW 8/30/2020 19:15:14'!
PASSED!

!classRemoval: #SubclassWithInstVar stamp: 'HAW 8/30/2020 19:15:15'!
ClassToAddInstVar subclass: #SubclassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:15'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:15'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:15'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddInstanceVariableTest #test08AddCreatesNewInstanceVariable stamp: 'HAW 8/30/2020 19:15:15'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:15'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:16'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:16'!
m1 | a | a := 10.! !

!testRun: #AddInstanceVariableTest #test09FailsWhenNewVariableEqualsTemporaryVariableOfAMethodInClass stamp: 'HAW 8/30/2020 19:15:16'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:16'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:16'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:16'!
m1:a! !

!testRun: #AddInstanceVariableTest #test10FailsWhenNewVariableEqualsArgumentOfAMethodInClass stamp: 'HAW 8/30/2020 19:15:16'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:17'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:17'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:17'!
m1 [ :a | ] value: 1! !

!testRun: #AddInstanceVariableTest #test11FailsWhenNewVariableEqualsArgumentOfABlockInAMethodInClass stamp: 'HAW 8/30/2020 19:15:17'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:17'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:17'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:17'!
m1 [ | a | ] value! !

!testRun: #AddInstanceVariableTest #test12FailsWhenNewVariableEqualsTemporaryOfABlockInAMethodInClass stamp: 'HAW 8/30/2020 19:15:17'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:18'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:18'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassOfClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:18'!
ClassToAddInstVar subclass: #SubclassOfClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassOfClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:18'!
m1 | a | ! !

!testRun: #AddInstanceVariableTest #test13FailsWhenNewVariableIsHiddenInAnyMethodOfAnySubclass stamp: 'HAW 8/30/2020 19:15:18'!
PASSED!

!classRemoval: #SubclassOfClassToRefactor stamp: 'HAW 8/30/2020 19:15:19'!
ClassToAddInstVar subclass: #SubclassOfClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:19'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:19'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddInstanceVariableTest #test14NewVariableNameCanNotBeAReservedName stamp: 'HAW 8/30/2020 19:15:19'!
PASSED!

!classRemoval: #ClassToAddInstVar stamp: 'HAW 8/30/2020 19:15:20'!
RefactoringClassTestData subclass: #ClassToAddInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:20'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20'!
sender_m1 self m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20'!
m1: newParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20' prior: 50842751!
sender_m1 self m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:15:20'!
m1!

!testRun: #AddParameterTest #test01AddingParameterToUnaryMessageAddsColonAndParameter stamp: 'HAW 8/30/2020 19:15:20'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:20'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:20'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20'!
sender_m1 self m1: 1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:20' prior: 50842790!
sender_m1 self m1: 1 m2: 2! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:20'!
m1: oldParam!

!testRun: #AddParameterTest #test02AddingParameterToKeywordMessageAddsNewKeywordAndParameter stamp: 'HAW 8/30/2020 19:15:20'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:21'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:21'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:21'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:21'!
sender_m1 self m1: 1. self m1: 1.! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:21'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:21' prior: 50842830!
sender_m1 self m1: 1 m2: 2. self m1: 1 m2: 2.! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:21'!
m1: oldParam!

!testRun: #AddParameterTest #test03AddingParameterToKeywordMessageMultipleSendsInSameMethodSameLiteral stamp: 'HAW 8/30/2020 19:15:21'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:21'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:22'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22'!
sender_m1 self m1: self size.! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22' prior: 50842871!
sender_m1 self m1: self size m2: 2.! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:22'!
m1: oldParam!

!testRun: #AddParameterTest #test04AddingParameterToKeywordMessageWithMessageSendAsLastFormalParameter stamp: 'HAW 8/30/2020 19:15:22'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:22'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:22'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22'!
sender_m1 self m1: self size + 4.! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:22' prior: 50842912!
sender_m1 self m1: self size + 4 m2: 2.! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:22'!
m1: oldParam!

!testRun: #AddParameterTest #test05AddingParameterToKeywordMessageWithBinaryMessageSendAsLastFormalParameter stamp: 'HAW 8/30/2020 19:15:22'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:23'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:23'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23'!
sender_m1 self m1: (self at: 1 put: 2).! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23' prior: 50842953!
sender_m1 self m1: (self at: 1 put: 2) m2: 2.! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:23'!
m1: oldParam!

!testRun: #AddParameterTest #test06AddingParameterToKeywordMessageWithKeywordMessageSendAsLastFormalParameter stamp: 'HAW 8/30/2020 19:15:23'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:23'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:23'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23'!
sender_m1 #m1 size! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23'!
m1: newParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:23' prior: 50842994!
sender_m1 #m1: size! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:15:23'!
m1!

!testRun: #AddParameterTest #test07AddingParameterToUnaryMessageChangesReferencesToSelector stamp: 'HAW 8/30/2020 19:15:23'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:24'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:24'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:24'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:24'!
sender_m1 #m1: size.! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:24'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:24' prior: 50843033!
sender_m1 #m1:m2: size.! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:24'!
m1: oldParam!

!testRun: #AddParameterTest #test08AddingParameterToKeywordMessageChangesReferencesToSelector stamp: 'HAW 8/30/2020 19:15:24'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:25'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterTest #test09FailsIfNewParameterValueCanNotBeCompiled stamp: 'HAW 8/30/2020 19:15:25'!
PASSED!

!testRun: #AddParameterTest #test10FailsIfNewParameterValueIsEmpty stamp: 'HAW 8/30/2020 19:15:25'!
PASSED!

!testRun: #AddParameterTest #test11NewParameterNameCanNotBeEmpty stamp: 'HAW 8/30/2020 19:15:26'!
PASSED!

!testRun: #AddParameterTest #test12NewParameterNameCanNotStartWithNumber stamp: 'HAW 8/30/2020 19:15:26'!
PASSED!

!testRun: #AddParameterTest #test13NewParameterNameCanNotContainSpaces stamp: 'HAW 8/30/2020 19:15:26'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:27'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: 'newParam'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:27'!
m1! !

!testRun: #AddParameterTest #test14NewParameterCanNotBeDefinedAsInstanceVariableInAnyImplementor stamp: 'HAW 8/30/2020 19:15:27'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:27'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: 'newParam'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:27'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:27'!
m1:newParam! !

!testRun: #AddParameterTest #test15NewParameterCanNotBeDefinedAsParameterInAnyImplementor stamp: 'HAW 8/30/2020 19:15:27'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:28'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterTest #test16WhenCreatedForUnarySelectorMustBeUnary stamp: 'HAW 8/30/2020 19:15:28'!
PASSED!

!testRun: #AddParameterTest #test17WhenCreatedForBinarySelectorMustBeBinary stamp: 'HAW 8/30/2020 19:15:28'!
PASSED!

!testRun: #AddParameterTest #test18CanNotAddParameterToBinaryKeyword stamp: 'HAW 8/30/2020 19:15:29'!
PASSED!

!testRun: #AddParameterTest #test19AllImplementorsMustImplementOldSelector stamp: 'HAW 8/30/2020 19:15:29'!
PASSED!

!testRun: #AddParameterTest #test20AllSendersShouldSendOldSelector stamp: 'HAW 8/30/2020 19:15:29'!
PASSED!

!testRun: #AddParameterTest #test21NewKeywordToAddToOldSelectorCanNotBeUnary stamp: 'HAW 8/30/2020 19:15:30'!
PASSED!

!testRun: #AddParameterTest #test22NewKeywordToAddToOldSelectorCanNotBeBinary stamp: 'HAW 8/30/2020 19:15:30'!
PASSED!

!testRun: #AddParameterTest #test23NewKeywordToAddToOldSelectorCanNotBeKeywordWithMoreThanOneParameter stamp: 'HAW 8/30/2020 19:15:31'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:31'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:31'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:31'!
sender_m1 self m1
	! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:31'!
m1: newParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:31' prior: 50843168!
sender_m1 self m1: 1
	! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:15:31'!
m1!

!testRun: #AddParameterTest #test24AddingParameterToSendersTakeCaresOfSeparators stamp: 'HAW 8/30/2020 19:15:31'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:32'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:32'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32'!
sender_m1 self m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32'!
m1: newParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32' prior: 50843205!
sender_m1 self m1: (self at: 1)! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:15:32'!
m1!

!testRun: #AddParameterTest #test25IfNewParameterValueIsKeywordMessageSendAddParenthesisToItForUnaryMessages stamp: 'HAW 8/30/2020 19:15:32'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:32'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:32'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32'!
sender_m1 self m1: 1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:32' prior: 50843245!
sender_m1 self m1: 1 m2: (self at: 1)! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:32'!
m1: oldParam!

!testRun: #AddParameterTest #test26IfNewParameterValueIsKeywordMessageSendAddParenthesisToItForKeywordMessages stamp: 'HAW 8/30/2020 19:15:32'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:33'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterTest #test27NewParameterValueCanNotHaveMoreThanOneStatement stamp: 'HAW 8/30/2020 19:15:33'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:33'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:33'!
m1: oldParam! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:33'!
sender_m1 self m1:[ 1 factorial ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:33'!
m1: oldParam m2: newParam ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:33' prior: 50843290!
sender_m1 self m1:[ 1 factorial ] m2: 1! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:33'!
m1: oldParam!

!testRun: #AddParameterTest #test28WhenSenderLastParameterIsABlockAddedParameterIsNotAddedInsideTheBlock stamp: 'HAW 8/30/2020 19:15:33'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:34'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:34'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:34'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:34'!
sender self m1: 1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:34'!
m2: newParam m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:34' prior: 50843331!
sender self m2: 2 m1: 1! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:15:34'!
m1: p1!

!testRun: #AddParameterTest #test29AddingParameterAsFirstOneWorksAsExpected stamp: 'HAW 8/30/2020 19:15:34'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:35'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:35'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35'!
sender self m1: 1 m3: 3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35'!
m1: p1 m2: newParam m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35' prior: 50843370!
sender self m1: 1 m2: 2 m3: 3! !

!methodRemoval: ClassToAddParameter #m1:m3: stamp: 'HAW 8/30/2020 19:15:35'!
m1: p1 m3: p3!

!testRun: #AddParameterTest #test30AddingParameterInTheMiddleWorksAsExpected stamp: 'HAW 8/30/2020 19:15:35'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:35'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:35'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35'!
sender
	self m1: 1 m3: 3.
	self
		m1: 4
		m3: 6! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35'!
m1: p1 m2: newParam m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:35' prior: 50843410!
sender
	self m1: 1 m2: 2 m3: 3.
	self
		m1: 4
		m2: 2 m3: 6! !

!methodRemoval: ClassToAddParameter #m1:m3: stamp: 'HAW 8/30/2020 19:15:35'!
m1: p1 m3: p3!

!testRun: #AddParameterTest #test31AddingParameterInTheMiddleWithManySendersWorksAsExpected stamp: 'HAW 8/30/2020 19:15:35'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:36'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterTest #test32IndexCanNotBeLessThanOne stamp: 'HAW 8/30/2020 19:15:36'!
PASSED!

!testRun: #AddParameterTest #test33IndexCanNotBeBiggerThanNumberOfParametersPlusOne stamp: 'HAW 8/30/2020 19:15:36'!
PASSED!

!testRun: #AddParameterTest #test34IndexMustBeInteger stamp: 'HAW 8/30/2020 19:15:37'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:37'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:37'!
m1

! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:37'!
sender_m1 self m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:37'!
m1: newParam

! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:37' prior: 50843462!
sender_m1 self m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:15:37'!
m1

!

!testRun: #AddParameterTest #test35AddingParameterRetractsInsertionPointWhenAtInsertionPointIsANewLine stamp: 'HAW 8/30/2020 19:15:37'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:38'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:38'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterTest #test36ParentesisAreAddedToSendersOfUnaryMessage stamp: 'HAW 8/30/2020 19:15:38'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:15:38'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangeKeywordsSelectorOrderTest #test01CannotChangeSelectorOrderInUnaryMessages stamp: 'HAW 8/30/2020 19:15:38'!
PASSED!

!testRun: #ChangeKeywordsSelectorOrderTest #test02CannotChangeSelectorOrderInBinaryMessages stamp: 'HAW 8/30/2020 19:15:39'!
PASSED!

!testRun: #ChangeKeywordsSelectorOrderTest #test03CannotChangeSelectorOrderInKeywordMessagesWithOneParameterOnly stamp: 'HAW 8/30/2020 19:15:39'!
PASSED!

!classDefinition: #ClassToChangeSelectorOrder category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:39'!
RefactoringClassTestData subclass: #ClassToChangeSelectorOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeSelectorOrder methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:39'!
m1: p1 m2: p2! !
!ClassToChangeSelectorOrder methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:39'!
m2: p2 m1: p1! !

!methodRemoval: ClassToChangeSelectorOrder #m1:m2: stamp: 'HAW 8/30/2020 19:15:39'!
m1: p1 m2: p2!

!testRun: #ChangeKeywordsSelectorOrderTest #test04ChangesKeywordsOrder stamp: 'HAW 8/30/2020 19:15:39'!
PASSED!

!classRemoval: #ClassToChangeSelectorOrder stamp: 'HAW 8/30/2020 19:15:40'!
RefactoringClassTestData subclass: #ClassToChangeSelectorOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeSelectorOrder category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:40'!
RefactoringClassTestData subclass: #ClassToChangeSelectorOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeSelectorOrder methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:40'!
m1: p1 m2: p2! !
!ClassToChangeSelectorOrder methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:40'!
m2: p2 m1: p1! !

!methodRemoval: ClassToChangeSelectorOrder #m1:m2: stamp: 'HAW 8/30/2020 19:15:40'!
m1: p1 m2: p2!

!testRun: #ChangeKeywordsSelectorOrderTest #test05ChangesParametersOrder stamp: 'HAW 8/30/2020 19:15:40'!
PASSED!

!classRemoval: #ClassToChangeSelectorOrder stamp: 'HAW 8/30/2020 19:15:41'!
RefactoringClassTestData subclass: #ClassToChangeSelectorOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ChangeKeywordsSelectorOrderTest #test06NewSelectorMustIncludeOldSelectorKeywords stamp: 'HAW 8/30/2020 19:15:41'!
PASSED!

!classDefinition: #ClassToChangeSelectorOrder category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:41'!
RefactoringClassTestData subclass: #ClassToChangeSelectorOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeSelectorOrder methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:41'!
m1: p1 m2: p2 m3: p3! !
!ClassToChangeSelectorOrder methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:41'!
m2: p2 m3: p3 m1: p1! !

!methodRemoval: ClassToChangeSelectorOrder #m1:m2:m3: stamp: 'HAW 8/30/2020 19:15:41'!
m1: p1 m2: p2 m3: p3!

!testRun: #ChangeKeywordsSelectorOrderTest #test07ChangesKeywordsAndParametersOrderForMoreThanTwoKeywords stamp: 'HAW 8/30/2020 19:15:41'!
PASSED!

!classRemoval: #ClassToChangeSelectorOrder stamp: 'HAW 8/30/2020 19:15:42'!
RefactoringClassTestData subclass: #ClassToChangeSelectorOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:42'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:42'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:42'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test01NewSelectorShouldNotBeEmpty stamp: 'HAW 8/30/2020 19:15:42'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:42'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:42'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:42'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:42'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test02NewSelectorShouldNotContainSeparators stamp: 'HAW 8/30/2020 19:15:42'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:43'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:43'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:43'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:43'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test03ExtractingToSelectorAlreadyDefinedInTheClassRaisesAWarning stamp: 'HAW 8/30/2020 19:15:43'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:44'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:44'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:44'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:44'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test04NewSelectorShouldNotStartWithANumber stamp: 'HAW 8/30/2020 19:15:44'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:44'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:44'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:44'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:44'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test05NewUnarySelectorShouldNotStartWithASymbol stamp: 'HAW 8/30/2020 19:15:44'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:45'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:45'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:45'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !

!testRun: #ExtractMethodTest #test06IntervalToExtractIsNotBeforeMethodSourceCodeBoundaries stamp: 'HAW 8/30/2020 19:15:45'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:45'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:46'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:46'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !

!testRun: #ExtractMethodTest #test07IntervalToExtractIsNotAfterMethodSourceCodeBoundaries stamp: 'HAW 8/30/2020 19:15:46'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:46'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:46'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:46'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:46'!
m1 ^ localVar + ((4))! !

!testRun: #ExtractMethodTest #test08IntervalToExtractShouldNotContainAReturnExpression stamp: 'HAW 8/30/2020 19:15:46'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:47'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:47'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:47'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:47'!
m1 ^ 4! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:47'!
m2

	^ 4! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:47' prior: 50843917!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test09ExtractingALiteralCreatesANewMethodAndChangesExistingCodeToCallThatNewMethod stamp: 'HAW 8/30/2020 19:15:47'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:47'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:47'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:47'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:47'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test10IntervalToExtractDoesNotContainsPartOfTheOriginalSelector stamp: 'HAW 8/30/2020 19:15:47'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:48'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:48'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:48'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:48'!
m1 | localVar | ^ localVar + 3! !

!testRun: #ExtractMethodTest #test11IntervalToExtractDoesNotContainsPartOfLocalVariablesDefinition stamp: 'HAW 8/30/2020 19:15:48'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:49'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:49'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:49'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:49'!
m1 <annoyingPragma>! !

!testRun: #ExtractMethodTest #test12IntervalToExtractDoesNotContainsPartOfPragmasDefinition stamp: 'HAW 8/30/2020 19:15:49'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:49'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:49'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:49'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:49'!
m1 ^ 3 + ((4))! !

!testRun: #ExtractMethodTest #test13IntervalToExtractShouldBeAValidSmalltalkExpression stamp: 'HAW 8/30/2020 19:15:49'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:50'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:50'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:50'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !

!testRun: #ExtractMethodTest #test14ItIsNotPossibleToExtractTheLeftSideOfAnAssignment stamp: 'HAW 8/30/2020 19:15:50'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:51'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:51'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:51'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:51'!
m1 self m3.
	self m4: 5! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:51'!
m2

	self m3.
	self m4: 5! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:51' prior: 50844133!
m1 self m2! !

!testRun: #ExtractMethodTest #test15ExtractingAListOfStatementsCreatesANewMethodWithoutReturn stamp: 'HAW 8/30/2020 19:15:51'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:51'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:51'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:51'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:51'!
m1 ^ 'hey true'! !

!testRun: #ExtractMethodTest #test16CanNotExtractPartOfALiteral stamp: 'HAW 8/30/2020 19:15:51'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:52'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:52'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:52'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:52'!
m1 ^ '^ 3' size! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:52'!
m2

	^ '^ 3' size! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:52' prior: 50844210!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test17AStringContainingTheReturnCharacterCanBeExtracted stamp: 'HAW 8/30/2020 19:15:52'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:53'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:53'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:53'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:53'!
m1
	
	self m3.
	self m4: 5.! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:53'!
m2

	self m3.
	self m4: 5! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:53' prior: 50844253!
m1
	
	self m2.! !

!testRun: #ExtractMethodTest #test18ExtractingAListOfStatementsIncludingDotsRemovesThemAndContinuesWithMethodExtraction stamp: 'HAW 8/30/2020 19:15:53'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:53'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:53'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:53'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:53'!
m1 ^ ((42))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:53'!
m2

	^ 42! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:53' prior: 50844297!
m1 ^ ((self m2))! !

!testRun: #ExtractMethodTest #test19ASelectionContainingAdditionalParenthesesAtTheBeginningAndOrEndCanBeExtracted stamp: 'HAW 8/30/2020 19:15:53'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:54'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:54'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:54'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:54'!
m1 | local | ^ local + 3! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:54'!
m2: local

	^ local + 3! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:54' prior: 50844340!
m1 | local | ^ self m2: local! !

!testRun: #ExtractMethodTest #test20ASelectionContainingALocalVariableIsParameterizedOnTheExtractedMessage stamp: 'HAW 8/30/2020 19:15:54'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:55'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:55'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:55'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:55'!
m1 ^ (9) * 3! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:55'!
m2

	^ (9) * 3! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:55' prior: 50844384!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test21ASelectionContainingAdditionalParenthesesOnOneSideCanBeExtractedAndItIsNotTrimmed stamp: 'HAW 8/30/2020 19:15:55'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:55'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:55'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:55'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:55'!
m1 | localVar | ^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:55'!
m2: localVar

	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:55' prior: 50844427!
m1 | localVar | ^ self m2: localVar! !

!testRun: #ExtractMethodTest #test22ItIsPossibleToExtractTheLastExpressionOfAMethod stamp: 'HAW 8/30/2020 19:15:55'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:56'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:56'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:56'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !

!testRun: #ExtractMethodTest #test23CanNotExtractWithAnInvalidInterval stamp: 'HAW 8/30/2020 19:15:56'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:56'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:56'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:56'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:56'!
m1 | localVar | localVar _ 8! !

!testRun: #ExtractMethodTest #test24ItIsNotPossibleToExtractAnIntervalIncludingATemporaryAssignmentExpression stamp: 'HAW 8/30/2020 19:15:56'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:57'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:57'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:57'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:57'!
m1 ^ 8! !

!testRun: #ExtractMethodTest #test25NewUnarySelectorShouldNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:15:57'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:58'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:58'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:58'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:58'!
m1 ^ [ |something| something _ 3 ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:58'!
m2

	^ [ |something| something _ 3 ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:58' prior: 50844574!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test26ItIsPossibleToExtractAnEntireBlockIncludingALocalAssignment stamp: 'HAW 8/30/2020 19:15:58'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:58'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:58'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:58'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:58'!
m1 ^ 2 ifNil: [ #boo ] ifNotNil: [ #yay ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:58'!
m2

	^ 2 ifNil: [ #boo ] ifNotNil: [ #yay ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:15:58' prior: 50844618!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test27ItIsPossibleToExtractExpressionsWithOptimizedSelectors stamp: 'HAW 8/30/2020 19:15:58'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:15:59'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:15:59'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:59'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:15:59'!
m1 | localVar | ^ #foo! !

!testRun: #ExtractMethodTest #test28ItIsNotPossibleToExtractALocalVariableInsideOfItsDeclaration stamp: 'HAW 8/30/2020 19:15:59'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:00'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:00'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:00'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:00'!
m1: arg ^ 2 + arg * 3! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:00'!
m2: arg

	^ 2 + arg! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:00' prior: 50844698!
m1: arg ^ (self m2: arg) * 3! !

!testRun: #ExtractMethodTest #test29ExtractingABinaryExpressionToAKeywordMessageIntroducesParenthesesToNotBreakOriginalPrecedence stamp: 'HAW 8/30/2020 19:16:00'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:00'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:00'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:00'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:00'!
m1 ^ `3 + 4`! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:00'!
m2

	^ `3 + 4`! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:00' prior: 50844743!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test30ItIsPossibleToExtractAQuotedExpression stamp: 'HAW 8/30/2020 19:16:00'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:01'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:01'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:01'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:01'!
m1 ^ 2 factorial ifNotNil: [ #boo ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:01'!
m2

	^ 2 factorial ifNotNil: [ #boo ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:01' prior: 50844785!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test31ItIsPossibleToExtractExpressionsWithOptimizedSelectorsWhereTheReceiverIsNotASimpleLiteral stamp: 'HAW 8/30/2020 19:16:01'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:02'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:02'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:02'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:02'!
m1 ^ [ | a | a _ 3 factorial ]! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:02'!
m2

	| a | a _ 3 factorial! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:02' prior: 50844830!
m1 ^ [ self m2 ]! !

!testRun: #ExtractMethodTest #test32ItIsPossibleToExtractATemporaryDeclarationOfABlockIfItIsNotUsedOutsideOfSelectionInterval stamp: 'HAW 8/30/2020 19:16:02'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:02'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:02'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:02'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:02'!
m1 | a | a _ 3 factorial! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:02'!
m2

	| a | a _ 3 factorial! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:02' prior: 50844874!
m1 self m2! !

!testRun: #ExtractMethodTest #test33ItIsPossibleToExtractATemporaryDeclarationIfItIsNotUsedOutsideOfSelectionInterval stamp: 'HAW 8/30/2020 19:16:02'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:03'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:03'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:03'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:03'!
m1 | localVar1 localVar2 | ^ localVar1 + localVar2 + 2! !

!testRun: #ExtractMethodTest #test34TryingToExtractAMethodWithLessArgumentsThanNeededFails stamp: 'HAW 8/30/2020 19:16:03'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:04'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:04'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:04'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:04'!
m1 | localVar1 localVar2 | ^ localVar1 + localVar2 + 2! !

!testRun: #ExtractMethodTest #test35TryingToExtractAMethodWithMoreArgumentsThanNeededFails stamp: 'HAW 8/30/2020 19:16:04'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:04'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:04'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:04'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:04'!
m1 ^ (3 + 2) factorial; yourself! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:04'!
m2

	^ (3 + 2) factorial; yourself! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:04' prior: 50844992!
m1 ^ self m2! !

!testRun: #ExtractMethodTest #test36ItIsPossibleToExtractACascadeExpression stamp: 'HAW 8/30/2020 19:16:04'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:05'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:05'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:05'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:05'!
m1 | temp | []! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:05'!
m2

	| temp | []! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:05' prior: 50845036!
m1 self m2! !

!testRun: #ExtractMethodTest #test37ItIsPossibleATempDeclarationAlongWithABlock stamp: 'HAW 8/30/2020 19:16:05'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:06'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:06'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:06'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:06'!
m1 ^ (  (3 + 4))! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:06'!
m2

	^ 3 + 4! !
!ClassToExtractMethod methodsFor: 'category' stamp: 'HAW 8/30/2020 19:16:06' prior: 50845078!
m1 ^ (  (self m2))! !

!testRun: #ExtractMethodTest #test38ItIsPossibleToExtractCodeThatContainsMultipleParenthesisWithSpacesBetweenThem stamp: 'HAW 8/30/2020 19:16:06'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:06'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:06'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:06'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:06'!
m1 ^ 42! !

!testRun: #ExtractMethodTest #test39TryingToExtractToAMethodThatExistsInASuperclassRaisesAWarning stamp: 'HAW 8/30/2020 19:16:06'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:07'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:07'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:07'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:07'!
m1 |var| var _ 42. ^ var! !

!testRun: #ExtractMethodTest #test40CanNotExtractTemporaryAssignmentWithDeclarationIfTheVariableIsUsedOutsideOfSelectionInterval stamp: 'HAW 8/30/2020 19:16:07'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:07'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToExtractMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:07'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:08'!
mExtractMethodExample: anArgument

	<anAnnoyingPragma>
	| localVar |
	<anotherAnnoyingPragma>
	self m1.
	self m2: 'hey true'.
	self m3: anArgument , '^ 21'.
	localVar _ Set with: 'hello'.
	localVar := #($x $y $z) size and: [ (9) * 3 ].
	^ localVar + ((4))! !
!ClassToExtractMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:08'!
m1: arg ^ self! !

!testRun: #ExtractMethodTest #test41CannotExtractPartOfMethodSignature stamp: 'HAW 8/30/2020 19:16:08'!
PASSED!

!classRemoval: #ClassToExtractMethod stamp: 'HAW 8/30/2020 19:16:08'!
RefactoringClassTestData subclass: #ClassToExtractMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:08'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:08'!
m1 ^ 2! !

!testRun: #ExtractToTemporaryTest #test01NewVariableCanNotBeEmpty stamp: 'HAW 8/30/2020 19:16:08'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:09'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:09'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:09'!
m1 ^ 2! !

!testRun: #ExtractToTemporaryTest #test02NewVariableHasToBeValid stamp: 'HAW 8/30/2020 19:16:09'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:09'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:09'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:09'!
m1 | new | ^ 2! !

!testRun: #ExtractToTemporaryTest #test03NewVariableNameCanNotBeDefinedInMethod stamp: 'HAW 8/30/2020 19:16:09'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:10'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:10'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:10'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:10'!
m1 ^ 78! !

!testRun: #ExtractToTemporaryTest #test04FailsIfNewTemporaryIsEqualToInstanceVariableInClass stamp: 'HAW 8/30/2020 19:16:10'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:11'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:11'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRefactorSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:11'!
RefactoringClassTestData subclass: #ClassToRefactorSuperclass
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:11'!
m1 ^ 78! !

!testRun: #ExtractToTemporaryTest #test05FailsIfNewTemporaryIsEqualToInstanceVariableInAnySuperclass stamp: 'HAW 8/30/2020 19:16:11'!
PASSED!

!classRemoval: #ClassToRefactorSuperclass stamp: 'HAW 8/30/2020 19:16:11'!
RefactoringClassTestData subclass: #ClassToRefactorSuperclass
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:12'!
AnObsoleteClassToRefactorSuperclass subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:12'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:12'!
m1 ^ 1! !

!testRun: #ExtractToTemporaryTest #test06SourceCodeToExtractCanNotIncludeReturn stamp: 'HAW 8/30/2020 19:16:12'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:12'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:12'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:12'!
m1 ^ 1! !

!testRun: #ExtractToTemporaryTest #test07SourceCodeToExtractCanNotBeEmpty stamp: 'HAW 8/30/2020 19:16:12'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:13'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:13'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:13'!
m1 ^ 1 + 3! !

!testRun: #ExtractToTemporaryTest #test08SourceCodeToExtractCanNotHaveSyntaxErrors stamp: 'HAW 8/30/2020 19:16:13'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:13'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:13'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:13'!
m1 1+2. 3+4! !

!testRun: #ExtractToTemporaryTest #test09SourceCodeToExtractHasToBeOneStatement stamp: 'HAW 8/30/2020 19:16:13'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:14'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:14'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:14'!
m1 ^ 1! !

!testRun: #ExtractToTemporaryTest #test10FailsIfIntervalToExtractIsBeforeMethodSourceCodeBoundaries stamp: 'HAW 8/30/2020 19:16:14'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:15'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:15'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:15'!
m1 ^ 1! !

!testRun: #ExtractToTemporaryTest #test11FailsIfIntervalToExtractIsAfterMethodSourceCodeBoundaries stamp: 'HAW 8/30/2020 19:16:15'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:15'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:15'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:15'!
m1

	^ 42! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:15' prior: 50845515!
m1

	| new |
	new _ 42.
	^ new! !

!testRun: #ExtractToTemporaryTest #test12ItIsPossibleToExtractASingleLiteralFromAMethodWithoutAnyTempsOrArguments stamp: 'HAW 8/30/2020 19:16:15'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:16'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:16'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:16'!
m1

	| four |
	four _ 4.
	^ four + 2! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:16' prior: 50845545!
m1

	| four two |
	four _ 4.
	two _ 2.
	^ four + two! !

!testRun: #ExtractToTemporaryTest #test13ItIsPossibleToExtractASingleExpressionFromAMethodThatHasAlreadyOtherTemporary stamp: 'HAW 8/30/2020 19:16:16'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:17'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:17'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:17'!
m1

	| |
	^ 3 factorial! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:17' prior: 50845577!
m1

	| f |
	f _ 3 factorial.
	^ f! !

!testRun: #ExtractToTemporaryTest #test14ItIsPossibleToExtractASingleExpressionFromAMethodThatHasAnEmptyTemporariesDeclaration stamp: 'HAW 8/30/2020 19:16:17'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:17'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:17'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:17'!
m1

	^ 42! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:17' prior: 50845609!
m1

	| new |
	new := 42.
	^ new! !

!testRun: #ExtractToTemporaryTest #test15ItIsPossibleToExtractCodeAndGenerateAssignmentUsingAnsiAssignmentStyle stamp: 'HAW 8/30/2020 19:16:17'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:18'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:18'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:18'!
m1

	^ [ self m2 ]! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:18' prior: 50845639!
m1

	^ [ | new |
	new _ self m2 ]! !

!testRun: #ExtractToTemporaryTest #test16ItIsPossibleToExtractASingleLiteralFromABlockWithoutAnyTempsOrArguments stamp: 'HAW 8/30/2020 19:16:18'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:18'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:19'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:19'!
m1 ^ 1! !

!testRun: #ExtractToTemporaryTest #test17CannotExtractPartOfMethodName stamp: 'HAW 8/30/2020 19:16:19'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:19'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:19'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:19'!
m1 ^ self m2! !

!testRun: #ExtractToTemporaryTest #test18CannotExtractPartOfMessageSend stamp: 'HAW 8/30/2020 19:16:19'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:20'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:20'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:20'!
m1

	^ 42! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:20' prior: 50845718!
m1

	| new |
	new _ 42.
	^ new! !

!testRun: #ExtractToTemporaryTest #test19ItIsPossibleToExtractAnIntervalWithSomeExtraSpaces stamp: 'HAW 8/30/2020 19:16:20'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:20'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:20'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:20'!
m1

	^ []! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:20' prior: 50845748!
m1

	| new |
	new _ [].
	^ new! !

!testRun: #ExtractToTemporaryTest #test20ItIsPossibleToExtractAnEmptyBlock stamp: 'HAW 8/30/2020 19:16:20'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:21'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:21'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:21'!
m1 | existing | existing := 2! !

!testRun: #ExtractToTemporaryTest #test21CannotExtractLeftSideOfAssignment stamp: 'HAW 8/30/2020 19:16:21'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:22'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:22'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22'!
m1

	^ 3 factorial; yourself! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22' prior: 50845802!
m1

	| new |
	new _ 3 factorial; yourself.
	^ new! !

!testRun: #ExtractToTemporaryTest #test22ItIsPossibleToExtractACascadeExpression stamp: 'HAW 8/30/2020 19:16:22'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:22'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:22'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22'!
m1 ^ 2! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22' prior: 50845833!
m1 ^ 2! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22' prior: 50845837!
m1 ^ 2! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22' prior: 50845841!
m1 ^ 2! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22' prior: 50845845!
m1 ^ 2! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:22' prior: 50845849!
m1 ^ 2! !

!testRun: #ExtractToTemporaryTest #test23CannotUseAReservedNameAsTheNewTemporaryVariable stamp: 'HAW 8/30/2020 19:16:22'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:23'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:23'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:23'!
m1

	self run! !
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:23' prior: 50845878!
m1

	| action |
	action _ self run! !

!testRun: #ExtractToTemporaryTest #test24WhenExtractingAnEntireStatementItOnlyGeneratesTheVariableAssignment stamp: 'HAW 8/30/2020 19:16:23'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:24'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToDoExtractTemporary category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:24'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToDoExtractTemporary methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:24'!
m1: arg ^ self! !

!testRun: #ExtractToTemporaryTest #test25CannotExtractArgumentNamesFromMethodSignature stamp: 'HAW 8/30/2020 19:16:24'!
PASSED!

!classRemoval: #ClassToDoExtractTemporary stamp: 'HAW 8/30/2020 19:16:24'!
RefactoringClassTestData subclass: #ClassToDoExtractTemporary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:24'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AddedSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:24'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:24'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test01ChangesTheSuperclassOfTheClassToRefactor stamp: 'HAW 8/30/2020 19:16:24'!
PASSED!

!classRemoval: #ClassToAddSuperclass stamp: 'HAW 8/30/2020 19:16:25'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AddedSuperclass stamp: 'HAW 8/30/2020 19:16:25'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:25'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: 'instVar1 instVar2'
	classVariableNames: 'ClassVar1 ClassVar2'
	poolDictionaries: 'SharedAAA'
	category: '__Refactoring-TestData__'!

!classDefinition: #AddedSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:25'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:25'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: 'instVar1 instVar2'
	classVariableNames: 'ClassVar1 ClassVar2'
	poolDictionaries: 'SharedAAA'
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test02ClassToRefactorStructureIsMaintained stamp: 'HAW 8/30/2020 19:16:25'!
PASSED!

!classRemoval: #ClassToAddSuperclass stamp: 'HAW 8/30/2020 19:16:26'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: 'instVar1 instVar2'
	classVariableNames: 'ClassVar1 ClassVar2'
	poolDictionaries: 'private'
	category: '__Refactoring-TestData__'!

!classRemoval: #AddedSuperclass stamp: 'HAW 8/30/2020 19:16:26'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:26'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AddedSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:26'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:26'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test03NewSuperclassCategoryIsTheSameAsClassToRefactorCategory stamp: 'HAW 8/30/2020 19:16:26'!
PASSED!

!classRemoval: #ClassToAddSuperclass stamp: 'HAW 8/30/2020 19:16:27'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AddedSuperclass stamp: 'HAW 8/30/2020 19:16:27'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:27'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AddedSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:27'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:27'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test04NewSuperclassHasNoVariables stamp: 'HAW 8/30/2020 19:16:27'!
PASSED!

!classRemoval: #ClassToAddSuperclass stamp: 'HAW 8/30/2020 19:16:28'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AddedSuperclass stamp: 'HAW 8/30/2020 19:16:28'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:28'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AlreadyExistingClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:28'!
RefactoringClassTestData subclass: #AlreadyExistingClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test05NewSuperclassShouldNotExist stamp: 'HAW 8/30/2020 19:16:28'!
PASSED!

!classRemoval: #ClassToAddSuperclass stamp: 'HAW 8/30/2020 19:16:28'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AlreadyExistingClass stamp: 'HAW 8/30/2020 19:16:29'!
RefactoringClassTestData subclass: #AlreadyExistingClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test06NewSuperclassNameHasToBeASymbol stamp: 'HAW 8/30/2020 19:16:29'!
PASSED!

!testRun: #InsertSuperclassTest #test07NewSuperclassNameHasToStartWithUppercaseLetter stamp: 'HAW 8/30/2020 19:16:29'!
PASSED!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:30'!
RefactoringClassTestData subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AddedSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:30'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:30'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test08WhenAppliedToMetaclassWorksAsWithClass stamp: 'HAW 8/30/2020 19:16:30'!
PASSED!

!classRemoval: #ClassToAddSuperclass stamp: 'HAW 8/30/2020 19:16:30'!
AddedSuperclass subclass: #ClassToAddSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AddedSuperclass stamp: 'HAW 8/30/2020 19:16:30'!
RefactoringClassTestData subclass: #AddedSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #InsertSuperclassTest #test09NewSuperclassNameCanNotBeEmpty stamp: 'HAW 8/30/2020 19:16:30'!
PASSED!

!testRun: #InsertSuperclassTest #test10NewSuperclassNameCanNotHaveSpaces stamp: 'HAW 8/30/2020 19:16:31'!
PASSED!

!classDefinition: #ClassToMoveMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:31'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToMoveMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:31'!
newMethod ^a! !

!testRun: #MoveToInstanceOrClassMethodTest #test01CannotMoveWhenReferencingInstanceVariables stamp: 'HAW 8/30/2020 19:16:31'!
PASSED!

!classRemoval: #ClassToMoveMethod stamp: 'HAW 8/30/2020 19:16:32'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToMoveMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:32'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: 'ClassToMoveMethod class' category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:32'!
ClassToMoveMethod class
	instanceVariableNames: 'a'!
!ClassToMoveMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:32'!
newMethod|a|! !

!testRun: #MoveToInstanceOrClassMethodTest #test02CannotMoveToClassWhenLocalVariableIsTheSameAsClassInstanceVariable stamp: 'HAW 8/30/2020 19:16:32'!
PASSED!

!classRemoval: #ClassToMoveMethod stamp: 'HAW 8/30/2020 19:16:32'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToMoveMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:32'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToMoveMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:33'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToMoveMethod class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:33'!
newMethod|a|! !

!testRun: #MoveToInstanceOrClassMethodTest #test03CannotMoveToInstanceWhenLocalVariableIsTheSameAsClassInstanceVariable stamp: 'HAW 8/30/2020 19:16:33'!
PASSED!

!classRemoval: #ClassToMoveMethod stamp: 'HAW 8/30/2020 19:16:33'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToMoveMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:33'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToMoveMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:33'!
newMethod! !
!ClassToMoveMethod class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:33'!
newMethod! !

!methodRemoval: ClassToMoveMethod #newMethod stamp: 'HAW 8/30/2020 19:16:33'!
newMethod!

!testRun: #MoveToInstanceOrClassMethodTest #test04InstanceMethodIsMovedToClassMethod stamp: 'HAW 8/30/2020 19:16:33'!
PASSED!

!classRemoval: #ClassToMoveMethod stamp: 'HAW 8/30/2020 19:16:34'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToMoveMethod category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:34'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToMoveMethod class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:34'!
newMethod! !
!ClassToMoveMethod methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:34'!
newMethod! !

!methodRemoval: ClassToMoveMethod class #newMethod stamp: 'HAW 8/30/2020 19:16:34'!
newMethod!

!testRun: #MoveToInstanceOrClassMethodTest #test05ClassMethodIsMovedToInstanceMethod stamp: 'HAW 8/30/2020 19:16:34'!
PASSED!

!classRemoval: #ClassToMoveMethod stamp: 'HAW 8/30/2020 19:16:34'!
RefactoringClassTestData subclass: #ClassToMoveMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:34'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushDownInstanceVariableTest #test01AnInstanceVariableDoesNotExistOnClassToFactorCannotBePushedDownToSubclasses stamp: 'HAW 8/30/2020 19:16:34'!
PASSED!

!classRemoval: #ClassToPushInstanceVariableDown stamp: 'HAW 8/30/2020 19:16:35'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:35'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushInstanceVariableDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:35'!
newMethod^ a! !

!classDefinition: #SubclassWithoutInstVarOne category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:35'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarOne
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithoutInstVarTwo category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:35'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarTwo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushDownInstanceVariableTest #test02AnInstanceVariableThatIsAccessedOnClassToRefactorCannotBePushedDownToAllSubclasses stamp: 'HAW 8/30/2020 19:16:35'!
PASSED!

!classRemoval: #SubclassWithoutInstVarTwo stamp: 'HAW 8/30/2020 19:16:36'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarTwo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SubclassWithoutInstVarOne stamp: 'HAW 8/30/2020 19:16:36'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarOne
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushInstanceVariableDown stamp: 'HAW 8/30/2020 19:16:36'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:36'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithoutInstVarOne category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:36'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarOne
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithoutInstVarTwo category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:36'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarTwo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:36'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithoutInstVarOne category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:36'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarOne
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithoutInstVarTwo category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:36'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarTwo
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushDownInstanceVariableTest #test03AnInstanceVariableThatIsNotAccessedOnClassToRefactorShouldBePushedDownToAllSubclasses stamp: 'HAW 8/30/2020 19:16:36'!
PASSED!

!classRemoval: #SubclassWithoutInstVarTwo stamp: 'HAW 8/30/2020 19:16:37'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarTwo
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SubclassWithoutInstVarOne stamp: 'HAW 8/30/2020 19:16:37'!
ClassToPushInstanceVariableDown subclass: #SubclassWithoutInstVarOne
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushInstanceVariableDown stamp: 'HAW 8/30/2020 19:16:37'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:37'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass1 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:37'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass2 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:37'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:37'!
newMethod! !
!Subclass1 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:37' overrides: 50846542!
newMethod! !
!Subclass2 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:37' overrides: 50846542!
newMethod! !

!methodRemoval: ClassToPushMethodDown #newMethod stamp: 'HAW 8/30/2020 19:16:37'!
newMethod!

!testRun: #PushDownMethodTest #test01AnEmptyMethodOnClassToRefactorShouldBePushedDownToSubclasses stamp: 'HAW 8/30/2020 19:16:37'!
PASSED!

!classRemoval: #Subclass2 stamp: 'HAW 8/30/2020 19:16:38'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Subclass1 stamp: 'HAW 8/30/2020 19:16:38'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushMethodDown stamp: 'HAW 8/30/2020 19:16:39'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:39'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass1 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:39'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass2 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:39'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:39'!
newMethod|a|! !

!testRun: #PushDownMethodTest #test02AMethodTemporaryVarDeclaredAsInstVarOnASubclassCanNotBePushedDownToSubclasses stamp: 'HAW 8/30/2020 19:16:39'!
PASSED!

!classRemoval: #Subclass2 stamp: 'HAW 8/30/2020 19:16:39'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Subclass1 stamp: 'HAW 8/30/2020 19:16:40'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushMethodDown stamp: 'HAW 8/30/2020 19:16:40'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:40'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass1 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:40'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass2 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:40'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:40'!
newMethod:a! !

!testRun: #PushDownMethodTest #test03AMethodArgumentDeclaredAsInstVarOnASubclassCanNotBePushedDownToSubclasses stamp: 'HAW 8/30/2020 19:16:40'!
PASSED!

!classRemoval: #Subclass2 stamp: 'HAW 8/30/2020 19:16:40'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Subclass1 stamp: 'HAW 8/30/2020 19:16:41'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushMethodDown stamp: 'HAW 8/30/2020 19:16:41'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:41'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass1 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:41'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass2 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:41'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:41'!
newMethod^ 1 + a! !
!Subclass1 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:41' overrides: 50846716!
newMethod^ 1 + a! !
!Subclass2 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:41' overrides: 50846716!
newMethod^ 1 + a! !

!methodRemoval: ClassToPushMethodDown #newMethod stamp: 'HAW 8/30/2020 19:16:41'!
newMethod^ 1 + a!

!testRun: #PushDownMethodTest #test04AMethodAccessesClassToRefactorInstVarShouldBePushedDownToSubclasses stamp: 'HAW 8/30/2020 19:16:41'!
PASSED!

!classRemoval: #Subclass2 stamp: 'HAW 8/30/2020 19:16:42'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Subclass1 stamp: 'HAW 8/30/2020 19:16:42'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushMethodDown stamp: 'HAW 8/30/2020 19:16:42'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:42'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass1 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:42'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Subclass2 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:42'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:42'!
newMethod a = 1! !
!Subclass1 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:42' overrides: 50846782!
newMethod a = 1! !
!Subclass2 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:42' overrides: 50846782!
newMethod a = 1! !

!methodRemoval: ClassToPushMethodDown #newMethod stamp: 'HAW 8/30/2020 19:16:42'!
newMethod a = 1!

!testRun: #PushDownMethodTest #test05AMethodWritesClassToRefactorInstVarShouldBePushedDownToSubclasses stamp: 'HAW 8/30/2020 19:16:42'!
PASSED!

!classRemoval: #Subclass2 stamp: 'HAW 8/30/2020 19:16:43'!
ClassToPushMethodDown subclass: #Subclass2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Subclass1 stamp: 'HAW 8/30/2020 19:16:43'!
ClassToPushMethodDown subclass: #Subclass1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushMethodDown stamp: 'HAW 8/30/2020 19:16:43'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodDown category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:43'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodDown methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:43'!
newMethod
	^ 2 + a.! !

!classDefinition: #Subclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:43'!
ClassToPushMethodDown subclass: #Subclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!Subclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:43' overrides: 50846831!
newMethod^ 1 + a! !

!testRun: #PushDownMethodTest #test06AMethodInClassToRefactorExistsInSubClassesShouldOverrideTheExistingSubClassesMethod stamp: 'HAW 8/30/2020 19:16:43'!
PASSED!

!classRemoval: #Subclass stamp: 'HAW 8/30/2020 19:16:44'!
ClassToPushMethodDown subclass: #Subclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToPushMethodDown stamp: 'HAW 8/30/2020 19:16:44'!
RefactoringClassTestData subclass: #ClassToPushMethodDown
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:44'!
RefactoringClassTestData subclass: #SuperclassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:44'!
SuperclassWithoutInstVar subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:44'!
SuperclassWithoutInstVar subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:44'!
RefactoringClassTestData subclass: #SuperclassWithoutInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushUpInstanceVariableTest #test01AnInstanceVariableThatIsNotUsedOnClassToRefactorShouldBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:44'!
PASSED!

!classRemoval: #ClassToPushInstanceVariableUp stamp: 'HAW 8/30/2020 19:16:45'!
SuperclassWithoutInstVar subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassWithoutInstVar stamp: 'HAW 8/30/2020 19:16:45'!
RefactoringClassTestData subclass: #SuperclassWithoutInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:45'!
RefactoringClassTestData subclass: #SuperclassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:45'!
SuperclassWithoutInstVar subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnoterSubClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:45'!
SuperclassWithoutInstVar subclass: #AnoterSubClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:45'!
SuperclassWithoutInstVar subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnoterSubClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:45'!
SuperclassWithoutInstVar subclass: #AnoterSubClassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:45'!
RefactoringClassTestData subclass: #SuperclassWithoutInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushUpInstanceVariableTest #test02AnInstanceVariableOnMultipleSubclassesShouldBeRemovedFromAllSubclassesAndPushedUpToSuperClass stamp: 'HAW 8/30/2020 19:16:45'!
PASSED!

!classRemoval: #ClassToPushInstanceVariableUp stamp: 'HAW 8/30/2020 19:16:46'!
SuperclassWithoutInstVar subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnoterSubClassWithInstVar stamp: 'HAW 8/30/2020 19:16:46'!
SuperclassWithoutInstVar subclass: #AnoterSubClassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassWithoutInstVar stamp: 'HAW 8/30/2020 19:16:46'!
RefactoringClassTestData subclass: #SuperclassWithoutInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushInstanceVariableUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:46'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushUpInstanceVariableTest #test03AnInstanceVariableDoesNotExistOnClassToRefactorCannotBePushedUp stamp: 'HAW 8/30/2020 19:16:46'!
PASSED!

!classRemoval: #ClassToPushInstanceVariableUp stamp: 'HAW 8/30/2020 19:16:47'!
RefactoringClassTestData subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithVariableAsTemporaryVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:47'!
RefactoringClassTestData subclass: #SuperclassWithVariableAsTemporaryVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SuperclassWithVariableAsTemporaryVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:47'!
newMethod| a |! !

!classDefinition: #ClassToPushInstanceVariableUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:47'!
SuperclassWithVariableAsTemporaryVariable subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #PushUpInstanceVariableTest #test04AnInstanceVariableThatIsUsedOnSuperClassAsTemporaryVariableCannotBePushedUp stamp: 'HAW 8/30/2020 19:16:47'!
PASSED!

!classRemoval: #ClassToPushInstanceVariableUp stamp: 'HAW 8/30/2020 19:16:48'!
SuperclassWithVariableAsTemporaryVariable subclass: #ClassToPushInstanceVariableUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassWithVariableAsTemporaryVariable stamp: 'HAW 8/30/2020 19:16:48'!
RefactoringClassTestData subclass: #SuperclassWithVariableAsTemporaryVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:48'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:48'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:48'!
newMethod! !
!Superclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:48'!
newMethod! !

!methodRemoval: ClassToPushMethodUp #newMethod stamp: 'HAW 8/30/2020 19:16:48'!
newMethod!

!testRun: #PushUpMethodTest #test01AnEmptyMethodOnClassToRefactorShouldBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:48'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:49'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:49'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:49'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:49'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:49'!
newMethod^ 1 + a! !

!testRun: #PushUpMethodTest #test02AMethodAccessesClassToRefactorInstVarCanNotBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:49'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:50'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:50'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:50'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:50'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:50'!
newMethod a = 1! !

!testRun: #PushUpMethodTest #test03AMethodWritesClassToRefactorInstVarCanNotBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:50'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:50'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:51'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:51'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:51'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:51'!
newMethod a = 1! !
!Superclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:51'!
newMethod a = 1! !

!methodRemoval: ClassToPushMethodUp #newMethod stamp: 'HAW 8/30/2020 19:16:51'!
newMethod a = 1!

!testRun: #PushUpMethodTest #test04AMethodWritesSuperClassInstVarShouldBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:51'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:51'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:52'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:52'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:52'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:52'!
newMethod^ 1 + a! !
!Superclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:52'!
newMethod^ 1 + a! !

!methodRemoval: ClassToPushMethodUp #newMethod stamp: 'HAW 8/30/2020 19:16:52'!
newMethod^ 1 + a!

!testRun: #PushUpMethodTest #test05AMethodAccessesSuperClassClassToRefactorInstVarShouldBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:52'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:52'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:53'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:53'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:53'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:53'!
newMethod^ 1 + a! !
!Superclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:53'!
newMethod^ 1 + a! !

!methodRemoval: ClassToPushMethodUp #newMethod stamp: 'HAW 8/30/2020 19:16:53'!
newMethod^ 1 + a!

!testRun: #PushUpMethodTest #test06AMethodAccessesSuperClassClassToRefactorInstVarShouldBePushedUpToSuperclass stamp: 'HAW 8/30/2020 19:16:53'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:53'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:53'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #Superclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:53'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!Superclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:53'!
newMethod^ 1 + a! !

!classDefinition: #ClassToPushMethodUp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:53'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToPushMethodUp methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:53' overrides: 50847346!
newMethod
	^ 2 + a.! !

!testRun: #PushUpMethodTest #test07AMethodInClassToRefactorExistsInSuperClassShouldOverrideTheExistingSuperClassMethod stamp: 'HAW 8/30/2020 19:16:54'!
PASSED!

!classRemoval: #ClassToPushMethodUp stamp: 'HAW 8/30/2020 19:16:54'!
Superclass subclass: #ClassToPushMethodUp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #Superclass stamp: 'HAW 8/30/2020 19:16:54'!
RefactoringClassTestData subclass: #Superclass
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:54'!
RefactoringClassTestData subclass: #ClassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveAllUnreferencedInstanceVariablesTest #test01NoVariableIsRemovedWhenClassHasNoInstanceVariable stamp: 'HAW 8/30/2020 19:16:54'!
PASSED!

!classRemoval: #ClassWithoutInstVar stamp: 'HAW 8/30/2020 19:16:55'!
RefactoringClassTestData subclass: #ClassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:55'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:55'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveAllUnreferencedInstanceVariablesTest #test02UnreferencedVariablesAreRemoved stamp: 'HAW 8/30/2020 19:16:55'!
PASSED!

!classRemoval: #ClassWithInstVar stamp: 'HAW 8/30/2020 19:16:56'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:56'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassWithInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:56'!
m1 ^a! !

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:56'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveAllUnreferencedInstanceVariablesTest #test03VariablesWithReferencesAreNotRemoved stamp: 'HAW 8/30/2020 19:16:56'!
PASSED!

!classRemoval: #ClassWithInstVar stamp: 'HAW 8/30/2020 19:16:57'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:57'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a b'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithReferenceInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:57'!
ClassWithInstVar subclass: #ClassWithReferenceInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassWithReferenceInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:57'!
m1 ^a! !

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:57'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveAllUnreferencedInstanceVariablesTest #test04VariablesWithReferencesInSubclassesAreNotRemoved stamp: 'HAW 8/30/2020 19:16:57'!
PASSED!

!classRemoval: #ClassWithReferenceInstVar stamp: 'HAW 8/30/2020 19:16:57'!
ClassWithInstVar subclass: #ClassWithReferenceInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassWithInstVar stamp: 'HAW 8/30/2020 19:16:57'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:57'!
RefactoringClassTestData subclass: #ClassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveInstanceVariableTest #test01CanNotRemoveAnInstanceVariableNotDefinedInClass stamp: 'HAW 8/30/2020 19:16:57'!
PASSED!

!classRemoval: #ClassWithoutInstVar stamp: 'HAW 8/30/2020 19:16:58'!
RefactoringClassTestData subclass: #ClassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:58'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassWithInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:16:58'!
m1 ^a! !

!testRun: #RemoveInstanceVariableTest #test02CanNotRemoveInstanceVariableWithReferences stamp: 'HAW 8/30/2020 19:16:58'!
PASSED!

!classRemoval: #ClassWithInstVar stamp: 'HAW 8/30/2020 19:16:59'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:59'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:16:59'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveInstanceVariableTest #test03WhenAppliedRemovesInstanceVariable stamp: 'HAW 8/30/2020 19:16:59'!
PASSED!

!classRemoval: #ClassWithInstVar stamp: 'HAW 8/30/2020 19:16:59'!
RefactoringClassTestData subclass: #ClassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveParameterTest #test01CanNotRemoveParameterFromUnaryMessages stamp: 'HAW 8/30/2020 19:16:59'!
PASSED!

!testRun: #RemoveParameterTest #test02CanNotRemoveParameterFromBinaryMessages stamp: 'HAW 8/30/2020 19:17:00'!
PASSED!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:00'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:00'!
m1: parameter! !

!testRun: #RemoveParameterTest #test03CanNotRemoveParameterNotInMessage stamp: 'HAW 8/30/2020 19:17:00'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:01'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:01'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:01'!
m1: parameter! !

!testRun: #RemoveParameterTest #test04AllImplementorsMustImplementSelector stamp: 'HAW 8/30/2020 19:17:01'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:02'!
m1: parameter! !

!testRun: #RemoveParameterTest #test05AllSendersShouldSendSelector stamp: 'HAW 8/30/2020 19:17:02'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:02'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:02'!
m1: parameter ^parameter! !

!testRun: #RemoveParameterTest #test06NoImplementorReferencesParameterToRemove stamp: 'HAW 8/30/2020 19:17:02'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:03'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:03'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:03'!
m1:parameter1 
	m2:parameter2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:03'!
m2:parameter2! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'HAW 8/30/2020 19:17:03'!
m1:parameter1 
	m2:parameter2!

!testRun: #RemoveParameterTest #test07FirstParameterIsRemovedCorrectly stamp: 'HAW 8/30/2020 19:17:03'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:04'!
m1:parameter1 m2:parameter2
	| t1 |! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:04'!
m1:parameter1 
	| t1 |! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'HAW 8/30/2020 19:17:04'!
m1:parameter1 m2:parameter2
	| t1 |!

!testRun: #RemoveParameterTest #test08LastParameterIsRemovedCorrectly stamp: 'HAW 8/30/2020 19:17:04'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:04'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:04'!
m0: parameter0 
	m1:parameter1 
	m2:parameter2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:04'!
m0: parameter0 
	m2:parameter2! !

!methodRemoval: ClassToRemoveParameter #m0:m1:m2: stamp: 'HAW 8/30/2020 19:17:04'!
m0: parameter0 
	m1:parameter1 
	m2:parameter2!

!testRun: #RemoveParameterTest #test09MiddleParameterIsRemovedCorrectly stamp: 'HAW 8/30/2020 19:17:04'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:05'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:05'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:05'!
m1:parameter1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:05'!
m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:17:05'!
m1:parameter1!

!testRun: #RemoveParameterTest #test10ParameterFromOneKeywordSelectorIsRemovedCorrectly stamp: 'HAW 8/30/2020 19:17:05'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06'!
m1:parameter1 m2:parameter2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06'!
sender
		self 
			m1: 1 
			m2: 2 ! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06'!
m2:parameter2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06' prior: 50847831!
sender
		self 
			m2: 2 ! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'HAW 8/30/2020 19:17:06'!
m1:parameter1 m2:parameter2!

!testRun: #RemoveParameterTest #test11ParameterOfSendersOfMoreThanOneKeywordSelectorsIsRemovedCorrectly stamp: 'HAW 8/30/2020 19:17:06'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:06'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06'!
m1:parameter1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06'!
sender
		self 
			m1:
			 (1+2).! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:06' prior: 50847873!
sender
		self 
			m1.! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:17:06'!
m1:parameter1!

!testRun: #RemoveParameterTest #test12ParameterOfSendersOfOneKeywordSelectorsIsRemovedCorrectly stamp: 'HAW 8/30/2020 19:17:06'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:07'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:07'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:07'!
m1:parameter1 m2:parameter2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:07'!
sender
		self m1: (1+1) m2: 2.
		self m1: 3 m2: 4.! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:07'!
m2:parameter2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:07' prior: 50847913!
sender
		self m2: 2.
		self m2: 4.! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'HAW 8/30/2020 19:17:07'!
m1:parameter1 m2:parameter2!

!testRun: #RemoveParameterTest #test13ParameterIsRemovedCorrecltyFromSendersWithMoreThanOneSend stamp: 'HAW 8/30/2020 19:17:07'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:17:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveParameterTest #test14CanNotRemoveParameterIndexLessThanOne stamp: 'HAW 8/30/2020 19:17:08'!
PASSED!

!testRun: #RemoveParameterTest #test15CanNotRemoveParameterIndexBiggerThanOldSelectorNumberOfKeywords stamp: 'HAW 8/30/2020 19:17:08'!
PASSED!

!testRun: #RemoveParameterTest #test16ParameterIndexMustBeInteger stamp: 'HAW 8/30/2020 19:17:08'!
PASSED!

!testRun: #RenameClassTest #test01NewClassNameHasToBeDifferentToOldOne stamp: 'HAW 8/30/2020 19:17:09'!
PASSED!

!testRun: #RenameClassTest #test02NewClassNameHasToBeASymbol stamp: 'HAW 8/30/2020 19:17:09'!
PASSED!

!testRun: #RenameClassTest #test03NewClassNameHasToStartWithUppercaseLetter stamp: 'HAW 8/30/2020 19:17:10'!
PASSED!

!testRun: #RenameClassTest #test04NewClassShouldNotExist stamp: 'HAW 8/30/2020 19:17:10'!
PASSED!

!testRun: #RenameClassTest #test04_01NewClassNameShouldNotBeAGlobalVariable stamp: 'HAW 8/30/2020 19:17:10'!
PASSED!

!testRun: #RenameClassTest #test05NewClassShouldNotBeUndeclare stamp: 'HAW 8/30/2020 19:17:11'!
PASSED!

!classDefinition: #OldClassTest07 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:11'!
RefactoringClassTestData subclass: #OldClassTest07
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRenamed: #OldClassTest07 as: #NewClassTest07 stamp: 'HAW 8/30/2020 19:17:11'!
Smalltalk renameClassNamed: #OldClassTest07 as: #NewClassTest07!

!testRun: #RenameClassTest #test06OldClassIsRenamedToNewClass stamp: 'HAW 8/30/2020 19:17:11'!
PASSED!

!classRemoval: #NewClassTest07 stamp: 'HAW 8/30/2020 19:17:12'!
RefactoringClassTestData subclass: #NewClassTest07
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest07 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:12'!
RefactoringClassTestData subclass: #OldClassTest07
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!OldClassTest07 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:12'!
m1 OldClassTest07 new! !

!classRenamed: #OldClassTest07 as: #NewClassTest07 stamp: 'HAW 8/30/2020 19:17:12'!
Smalltalk renameClassNamed: #OldClassTest07 as: #NewClassTest07!
!NewClassTest07 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:12' prior: 50848006!
m1 NewClassTest07 new! !

!testRun: #RenameClassTest #test07OldClassDirectReferencesAreRenamed stamp: 'HAW 8/30/2020 19:17:12'!
PASSED!

!classRemoval: #NewClassTest07 stamp: 'HAW 8/30/2020 19:17:13'!
RefactoringClassTestData subclass: #NewClassTest07
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest08 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:13'!
RefactoringClassTestData subclass: #OldClassTest08
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!OldClassTest08 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:13'!
m1 #OldClassTest08 size! !

!classRenamed: #OldClassTest08 as: #NewClassTest8 stamp: 'HAW 8/30/2020 19:17:13'!
Smalltalk renameClassNamed: #OldClassTest08 as: #NewClassTest8!
!NewClassTest8 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:13' prior: 50848038!
m1 #NewClassTest8 size! !

!testRun: #RenameClassTest #test08OldClassLiteralReferencesAreRenamed stamp: 'HAW 8/30/2020 19:17:13'!
PASSED!

!classRemoval: #NewClassTest8 stamp: 'HAW 8/30/2020 19:17:13'!
RefactoringClassTestData subclass: #NewClassTest8
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest09 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:13'!
RefactoringClassTestData subclass: #OldClassTest09
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!OldClassTest09 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:13'!
m1 OldClassTest09 new. Object new! !

!classRenamed: #OldClassTest09 as: #NewClassTest09 stamp: 'HAW 8/30/2020 19:17:13'!
Smalltalk renameClassNamed: #OldClassTest09 as: #NewClassTest09!
!NewClassTest09 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:14' prior: 50848070!
m1 NewClassTest09 new. Object new! !

!testRun: #RenameClassTest #test09OtherClassDirectReferencesAreNotRenamed stamp: 'HAW 8/30/2020 19:17:14'!
PASSED!

!classRemoval: #NewClassTest09 stamp: 'HAW 8/30/2020 19:17:14'!
RefactoringClassTestData subclass: #NewClassTest09
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest10 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:14'!
RefactoringClassTestData subclass: #OldClassTest10
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!OldClassTest10 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:14'!
m1 #OldClassTest10 size. #Object size! !

!classRenamed: #OldClassTest10 as: #NewClassTest10 stamp: 'HAW 8/30/2020 19:17:14'!
Smalltalk renameClassNamed: #OldClassTest10 as: #NewClassTest10!
!NewClassTest10 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:14' prior: 50848102!
m1 #NewClassTest10 size. #Object size! !

!testRun: #RenameClassTest #test10OtherLiteralReferencesAreNotRenamed stamp: 'HAW 8/30/2020 19:17:14'!
PASSED!

!classRemoval: #NewClassTest10 stamp: 'HAW 8/30/2020 19:17:15'!
RefactoringClassTestData subclass: #NewClassTest10
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest11 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:15'!
RefactoringClassTestData subclass: #OldClassTest11
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!OldClassTest11 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:15'!
m1 OldClassTest11 new. #OldClassTest11 size! !

!classRenamed: #OldClassTest11 as: #NewClassTest11 stamp: 'HAW 8/30/2020 19:17:15'!
Smalltalk renameClassNamed: #OldClassTest11 as: #NewClassTest11!
!NewClassTest11 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:15' prior: 50848135!
m1 NewClassTest11 new. #NewClassTest11 size! !

!testRun: #RenameClassTest #test11OldClassDirectAndLiteralReferencesAreRenameAtOnce stamp: 'HAW 8/30/2020 19:17:15'!
PASSED!

!classRemoval: #NewClassTest11 stamp: 'HAW 8/30/2020 19:17:16'!
RefactoringClassTestData subclass: #NewClassTest11
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameClassTest #test12CanNotRenameAMetaclass stamp: 'HAW 8/30/2020 19:17:16'!
PASSED!

!testRun: #RenameClassTest #test13NewClassNameHasToBeASymbol stamp: 'HAW 8/30/2020 19:17:16'!
PASSED!

!classDefinition: #OldClassTest14 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:17'!
RefactoringClassTestData subclass: #OldClassTest14
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameClassTest #test14NewClassNameCanNotHaveSpaces stamp: 'HAW 8/30/2020 19:17:17'!
PASSED!

!classRemoval: #OldClassTest14 stamp: 'HAW 8/30/2020 19:17:17'!
RefactoringClassTestData subclass: #OldClassTest14
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:17'!
RefactoringClassTestData subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:17'!
m1 ^OldClassTest15! !

!classDefinition: #OldClassTest15 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:17'!
RefactoringClassTestData subclass: #OldClassTest15
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRenamed: #OldClassTest15 as: #NewClassTest15 stamp: 'HAW 8/30/2020 19:17:17'!
Smalltalk renameClassNamed: #OldClassTest15 as: #NewClassTest15!

!testRun: #RenameClassTest #test15ItDoesNotRenameReferencesToClassVariableWithSameName stamp: 'HAW 8/30/2020 19:17:17'!
PASSED!

!classRemoval: #NewClassTest15 stamp: 'HAW 8/30/2020 19:17:18'!
RefactoringClassTestData subclass: #NewClassTest15
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassVar stamp: 'HAW 8/30/2020 19:17:18'!
RefactoringClassTestData subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: 'OldClassTest15'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVarSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:18'!
RefactoringClassTestData subclass: #ClassReferencingClassVarSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:18'!
ClassReferencingClassVarSuperclass subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:18'!
m1 ^OldClassTest16! !

!classDefinition: #OldClassTest16 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:18'!
RefactoringClassTestData subclass: #OldClassTest16
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRenamed: #OldClassTest16 as: #NewClassTest16 stamp: 'HAW 8/30/2020 19:17:18'!
Smalltalk renameClassNamed: #OldClassTest16 as: #NewClassTest16!

!testRun: #RenameClassTest #test16ItDoesNotRenameReferencesToClassVariableWithSameNameDefinedInAnySuperclass stamp: 'HAW 8/30/2020 19:17:18'!
PASSED!

!classRemoval: #NewClassTest16 stamp: 'HAW 8/30/2020 19:17:19'!
RefactoringClassTestData subclass: #NewClassTest16
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassVar stamp: 'HAW 8/30/2020 19:17:19'!
ClassReferencingClassVarSuperclass subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassVarSuperclass stamp: 'HAW 8/30/2020 19:17:20'!
RefactoringClassTestData subclass: #ClassReferencingClassVarSuperclass
	instanceVariableNames: ''
	classVariableNames: 'OldClassTest16'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVarSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:20'!
RefactoringClassTestData subclass: #ClassReferencingClassVarSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:20'!
ClassReferencingClassVarSuperclass subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:20'!
m1 ^NewClassTest17! !

!classDefinition: #OldClassTest17 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:20'!
RefactoringClassTestData subclass: #OldClassTest17
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRenamed: #OldClassTest17 as: #NewClassTest17 stamp: 'HAW 8/30/2020 19:17:20'!
Smalltalk renameClassNamed: #OldClassTest17 as: #NewClassTest17!

!testRun: #RenameClassTest #test17ItDoesNotRenameReferencesToClassVariableWithSameNameAsNewClassDefinedInAnySuperclass stamp: 'HAW 8/30/2020 19:17:20'!
PASSED!

!classRemoval: #NewClassTest17 stamp: 'HAW 8/30/2020 19:17:20'!
RefactoringClassTestData subclass: #NewClassTest17
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassVar stamp: 'HAW 8/30/2020 19:17:21'!
ClassReferencingClassVarSuperclass subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassVarSuperclass stamp: 'HAW 8/30/2020 19:17:21'!
RefactoringClassTestData subclass: #ClassReferencingClassVarSuperclass
	instanceVariableNames: ''
	classVariableNames: 'NewClassTest17'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest18 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:21'!
RefactoringClassTestData subclass: #OldClassTest18
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!OldClassTest18 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:21'!
m1 ^OldClassTest18! !

!classRenamed: #OldClassTest18 as: #NewClassTest18 stamp: 'HAW 8/30/2020 19:17:21'!
Smalltalk renameClassNamed: #OldClassTest18 as: #NewClassTest18!
!NewClassTest18 methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:21' prior: 50848370!
m1 ^NewClassTest18! !

!testRun: #RenameClassTest #test18WorksCorrectlyWhenSourceCodeEndsWithClassToRename stamp: 'HAW 8/30/2020 19:17:21'!
PASSED!

!classRemoval: #NewClassTest18 stamp: 'HAW 8/30/2020 19:17:22'!
RefactoringClassTestData subclass: #NewClassTest18
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #OldClassTest18 category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:22'!
RefactoringClassTestData subclass: #OldClassTest18
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameClassTest #test19RenamesClassWhenMethodReferencesClassAndDoesNothing stamp: 'HAW 8/30/2020 19:17:22'!
PASSED!

!classRemoval: #OldClassTest18 stamp: 'HAW 8/30/2020 19:17:22'!
RefactoringClassTestData subclass: #OldClassTest18
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameGlobalTest #test00GlobalCanNotBeClass stamp: 'HAW 8/30/2020 19:17:22'!
PASSED!

!testRun: #RenameGlobalTest #test01NewNameHasToBeDifferentToOldOne stamp: 'HAW 8/30/2020 19:17:23'!
PASSED!

!testRun: #RenameGlobalTest #test02NewNameHasToBeASymbol stamp: 'HAW 8/30/2020 19:17:23'!
PASSED!

!testRun: #RenameGlobalTest #test03NewNameShouldNotBeAClass stamp: 'HAW 8/30/2020 19:17:23'!
PASSED!

!testRun: #RenameGlobalTest #test04NewNameShouldNotBeAGlobalVariable stamp: 'HAW 8/30/2020 19:17:24'!
PASSED!

!testRun: #RenameGlobalTest #test06OldNameIsRenamedToNewName stamp: 'HAW 8/30/2020 19:17:24'!
PASSED!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:25'!
m1 ^OldNameToRename__! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:25' prior: 50848445!
m1 ^NewNameToRename__! !

!testRun: #RenameGlobalTest #test07OldDirectReferencesAreRenamed stamp: 'HAW 8/30/2020 19:17:25'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:17:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:26'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:26'!
m1 ^#OldNameToRename__! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:26' prior: 50848472!
m1 ^#NewNameToRename__! !

!testRun: #RenameGlobalTest #test08OldNameLiteralReferencesAreRenamed stamp: 'HAW 8/30/2020 19:17:26'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:17:26'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameGlobalTest #test09NewNameHasToBeASymbol stamp: 'HAW 8/30/2020 19:17:26'!
PASSED!

!testRun: #RenameGlobalTest #test10NewNameCanNotHaveSpaces stamp: 'HAW 8/30/2020 19:17:27'!
PASSED!

!classDefinition: #ClassReferencingClassVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:27'!
RefactoringClassTestData subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:27'!
m1 ^OldNameToRename__! !

!testRun: #RenameGlobalTest #test11ItDoesNotRenameReferencesToClassVariableWithSameName stamp: 'HAW 8/30/2020 19:17:27'!
PASSED!

!classRemoval: #ClassReferencingClassVar stamp: 'HAW 8/30/2020 19:17:28'!
RefactoringClassTestData subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: 'OldNameToRename__'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVarSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:28'!
RefactoringClassTestData subclass: #ClassReferencingClassVarSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:28'!
ClassReferencingClassVarSuperclass subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:28'!
m1 ^OldNameRenamed__! !

!testRun: #RenameGlobalTest #test12ItDoesNotRenameReferencesToClassVariableWithSameNameDefinedInAnySuperclass stamp: 'HAW 8/30/2020 19:17:28'!
PASSED!

!classRemoval: #ClassReferencingClassVar stamp: 'HAW 8/30/2020 19:17:28'!
ClassReferencingClassVarSuperclass subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassVarSuperclass stamp: 'HAW 8/30/2020 19:17:29'!
RefactoringClassTestData subclass: #ClassReferencingClassVarSuperclass
	instanceVariableNames: ''
	classVariableNames: 'OldNameRenamed__'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameGlobalTest #test13OldNameMustBeDefined stamp: 'HAW 8/30/2020 19:17:29'!
PASSED!

!classDefinition: #ClassReferencingClassVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:29'!
RefactoringClassTestData subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassVar class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:29'!
m1 ^OldNameToRename__! !

!testRun: #RenameGlobalTest #test14ItDoesNotRenameReferencesToClassVariableFromClassSideWithSameName stamp: 'HAW 8/30/2020 19:17:29'!
PASSED!

!classRemoval: #ClassReferencingClassVar stamp: 'HAW 8/30/2020 19:17:30'!
RefactoringClassTestData subclass: #ClassReferencingClassVar
	instanceVariableNames: ''
	classVariableNames: 'OldNameToRename__'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameGlobalTest #test15OldNameCanNotBeEmpty stamp: 'HAW 8/30/2020 19:17:30'!
PASSED!

!classDefinition: #ClassWithoutInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:30'!
RefactoringClassTestData subclass: #ClassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test01CanNotRenameAnInstanceVariableNotDefinedInClass stamp: 'HAW 8/30/2020 19:17:30'!
PASSED!

!classRemoval: #ClassWithoutInstVar stamp: 'HAW 8/30/2020 19:17:31'!
RefactoringClassTestData subclass: #ClassWithoutInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:31'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test02NewVariableNameCanNotBeEmpty stamp: 'HAW 8/30/2020 19:17:31'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:31'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:31'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test03NewVariableNameCanNotContainBlanks stamp: 'HAW 8/30/2020 19:17:31'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:32'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:32'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test04NewVariableNameCanNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:17:32'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:33'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:33'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test05ValidNewVariableNameGetBlanksTrimmed stamp: 'HAW 8/30/2020 19:17:33'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:33'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:33'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test06NewVariableNameCanNotBeDefinedInClass stamp: 'HAW 8/30/2020 19:17:33'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:34'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:34'!
RefactoringClassTestData subclass: #SuperclassWithInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:34'!
SuperclassWithInstVar subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test07NewVariableNameCanNotBeDefinedInSuperclasses stamp: 'HAW 8/30/2020 19:17:34'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:34'!
SuperclassWithInstVar subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassWithInstVar stamp: 'HAW 8/30/2020 19:17:35'!
RefactoringClassTestData subclass: #SuperclassWithInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:35'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:35'!
ClassToRenameInstVar subclass: #SubclassWithInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test08NewVariableNameCanNotBeDefinedInAnySubclass stamp: 'HAW 8/30/2020 19:17:35'!
PASSED!

!classRemoval: #SubclassWithInstVar stamp: 'HAW 8/30/2020 19:17:35'!
ClassToRenameInstVar subclass: #SubclassWithInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:36'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:36'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:36'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test09RenameCreatesNewInstanceVariableAndDeletesOldOne stamp: 'HAW 8/30/2020 19:17:36'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:36'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:36'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:36'!
m1 ^old! !

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:36'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:36' prior: 50848834!
m1 ^new! !

!testRun: #RenameInstanceVariableTest #test10ReadReferencesToOldVariableAreRenamed stamp: 'HAW 8/30/2020 19:17:36'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:37'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:37'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:37'!
m1 old := 10! !

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:37'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:37' prior: 50848871!
m1 new := 10! !

!testRun: #RenameInstanceVariableTest #test11WriteReferencesToOldVariableAreRenamed stamp: 'HAW 8/30/2020 19:17:37'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:38'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:38'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassWithInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:38'!
ClassToRenameInstVar subclass: #SubclassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassWithInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:38'!
m1 old := 10. ^old! !

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:38'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassWithInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:38' prior: 50848917!
m1 new := 10. ^new! !

!testRun: #RenameInstanceVariableTest #test12ReferencesInSubclassesAreRenamed stamp: 'HAW 8/30/2020 19:17:38'!
PASSED!

!classRemoval: #SubclassWithInstVar stamp: 'HAW 8/30/2020 19:17:38'!
ClassToRenameInstVar subclass: #SubclassWithInstVar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:39'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:39'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old keep'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:39'!
m1 keep := old. ^keep! !

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:39'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new keep'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:39' prior: 50848962!
m1 keep := new. ^keep! !

!testRun: #RenameInstanceVariableTest #test13ReferencesToOtherVariablesAreNotRenamed stamp: 'HAW 8/30/2020 19:17:39'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:39'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new keep'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:39'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:39'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameInstanceVariableTest #test14NewVariableOfExistingInstancesReferToOldVariableValue stamp: 'HAW 8/30/2020 19:17:39'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:40'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:40'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:40'!
m1 | new | new := 10.! !

!testRun: #RenameInstanceVariableTest #test15FailsWhenNewVariableEqualsTemporaryVariableOfAMethodInClass stamp: 'HAW 8/30/2020 19:17:40'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:40'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:40'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:40'!
m1:new! !

!testRun: #RenameInstanceVariableTest #test16FailsWhenNewVariableEqualsArgumentOfAMethodInClass stamp: 'HAW 8/30/2020 19:17:40'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:41'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:41'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:41'!
m1 [ :new | ] value: 1! !

!testRun: #RenameInstanceVariableTest #test17FailsWhenNewVariableEqualsArgumentOfABlockInAMethodInClass stamp: 'HAW 8/30/2020 19:17:41'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:42'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:42'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:42'!
m1 [ | new | ] value! !

!testRun: #RenameInstanceVariableTest #test18FailsWhenNewVariableEqualsTemporaryOfABlockInAMethodInClass stamp: 'HAW 8/30/2020 19:17:42'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:42'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:42'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassOfClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:42'!
ClassToRenameInstVar subclass: #SubclassOfClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassOfClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:42'!
m1 | new | ! !

!testRun: #RenameInstanceVariableTest #test19FailsWhenNewVariableIsHiddenInAnyMethodOfAnySubclass stamp: 'HAW 8/30/2020 19:17:42'!
PASSED!

!classRemoval: #SubclassOfClassToRefactor stamp: 'HAW 8/30/2020 19:17:43'!
ClassToRenameInstVar subclass: #SubclassOfClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:43'!
RefactoringClassTestData subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:43'!
Object subclass: #ClassToRenameInstVar
	instanceVariableNames: 'old'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameInstVar category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:43'!
Object subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameInstVar class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:43' overrides: 16806529!
wantsChangeSetLogging ^false! !

!testRun: #RenameInstanceVariableTest #test20ClassChangeIsAddedWhenRenamingAnInstanceVariable stamp: 'HAW 8/30/2020 19:17:43'!
PASSED!

!classRemoval: #ClassToRenameInstVar stamp: 'HAW 8/30/2020 19:17:44'!
Object subclass: #ClassToRenameInstVar
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:44'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:44'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:44'!
newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:44'!
oldXyz__!

!testRun: #RenameSelectorTest #test01MessageWithNoSendersCreatesNewMethodAndRemovesOldOne stamp: 'HAW 8/30/2020 19:17:44'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:45'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:45'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45' prior: 50849238!
m1__ self newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:45'!
oldXyz__!

!testRun: #RenameSelectorTest #test02SendersOfMessageAreRenamed stamp: 'HAW 8/30/2020 19:17:45'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:45'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:45'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45' prior: 50849277!
m1__ self oldXyz__. self toKeep! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:45' prior: 50849281!
m1__ self newXyz__. self toKeep! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:45'!
oldXyz__!

!testRun: #RenameSelectorTest #test03OtherMessagesSendsAreNotRenamed stamp: 'HAW 8/30/2020 19:17:45'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:46'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameSelectorTest #test04OldSelectorCanNotBeEmpty stamp: 'HAW 8/30/2020 19:17:46'!
PASSED!

!testRun: #RenameSelectorTest #test05NewSelectorCanNotBeEmpty stamp: 'HAW 8/30/2020 19:17:46'!
PASSED!

!testRun: #RenameSelectorTest #test06CanRenameWithoutImplementors stamp: 'HAW 8/30/2020 19:17:47'!
PASSED!

!testRun: #RenameSelectorTest #test07AllImplementorsMustImplementOldSelector stamp: 'HAW 8/30/2020 19:17:47'!
PASSED!

!testRun: #RenameSelectorTest #test08AllSendersShouldSendOldSelector stamp: 'HAW 8/30/2020 19:17:48'!
PASSED!

!testRun: #RenameSelectorTest #test09NewSelectorMustBeOfSameTypeAsOldSelector stamp: 'HAW 8/30/2020 19:17:48'!
PASSED!

!testRun: #RenameSelectorTest #test10NewSelectorMustHaveSameNumberOfArgumentsAsOldSelector stamp: 'HAW 8/30/2020 19:17:48'!
PASSED!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:49'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'oldSelectorCategory' stamp: 'HAW 8/30/2020 19:17:49'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49' prior: 50849345!
m1__ self newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:49'!
oldXyz__!

!testRun: #RenameSelectorTest #test11NewImplementorsKeepMethodCategory stamp: 'HAW 8/30/2020 19:17:49'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:49'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:49'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49' prior: 50849380!
oldXyz__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49'!
newXyz__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:49' prior: 50849392!
newXyz__ self newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:49'!
oldXyz__ self oldXyz__!

!testRun: #RenameSelectorTest #test12RenamesRecursiveMethodsWhenNotInSenders stamp: 'HAW 8/30/2020 19:17:49'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:50'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:50'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:50'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:50'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:50' prior: 50849425!
oldXyz__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:50'!
newXyz__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:50' prior: 50849433!
oldXyz__ self newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:50' prior: 50849437!
newXyz__ self newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:50'!
oldXyz__ self newXyz__!

!testRun: #RenameSelectorTest #test13RenamesRecursiveMethodsWhenInSenders stamp: 'HAW 8/30/2020 19:17:50'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:51'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:51'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:51'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:51'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:51' prior: 50849474!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:51'!
m1 #oldXyz__ size! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:51'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:51' prior: 50849486!
m1 #newXyz__ size! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:51'!
oldXyz__!

!testRun: #RenameSelectorTest #test14RenamesSymbolsEqualToOldSelector stamp: 'HAW 8/30/2020 19:17:51'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:51'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:52'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
m1__ self oldXyz__! !

!classDefinition: #ClassToAvoidRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:52'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAvoidRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52' prior: 50849525!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52' prior: 50849533!
m1__ self newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:52'!
oldXyz__!

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:52'!
oldXyz__!

!testRun: #RenameSelectorTest #test15ScopeToRenameCanBeClassOnly stamp: 'HAW 8/30/2020 19:17:52'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:52'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAvoidRenameSelector stamp: 'HAW 8/30/2020 19:17:52'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:52'!
RefactoringClassTestData subclass: #SuperclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
oldXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
m1__ self oldXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
oldXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:52'!
m1__ self oldXyz__! !

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:53'!
SuperclassToRenameSelector subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849601!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849605!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849609!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849613!
m1__ self oldXyz__! !

!classDefinition: #SubclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:53'!
ClassToRenameSelector subclass: #SubclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849627!
oldXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849631!
m1__ self oldXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849636!
oldXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849640!
m1__ self oldXyz__! !

!classDefinition: #ClassToAvoidRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:53'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAvoidRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53'!
m1__ self oldXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53'!
newXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849685!
newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849689!
newXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849693!
newXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' overrides: 50849697!
newXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' prior: 50849605!
m1__ self newXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' prior: 50849613!
m1__ self newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' prior: 50849631 overrides: 50849710!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' prior: 50849640 overrides: 50849715!
m1__ self newXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' prior: 50849658 overrides: 50849720!
m1__ self newXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:53' prior: 50849668 overrides: 50849725!
m1__ self newXyz__! !

!methodRemoval: SuperclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:53'!
oldXyz__!

!methodRemoval: SuperclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:53'!
oldXyz__!

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:53'!
oldXyz__!

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:53'!
oldXyz__!

!methodRemoval: SubclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:53'!
oldXyz__!

!methodRemoval: SubclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:53'!
oldXyz__!

!testRun: #RenameSelectorTest #test16ScopeToRenameCanBeHierarchyOnly stamp: 'HAW 8/30/2020 19:17:53'!
PASSED!

!classRemoval: #SubclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:53'!
ClassToRenameSelector subclass: #SubclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:53'!
SuperclassToRenameSelector subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:54'!
RefactoringClassTestData subclass: #SuperclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAvoidRenameSelector stamp: 'HAW 8/30/2020 19:17:54'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:54'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
m1__ self oldXyz__! !

!classDefinition: #AnotherclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:54'!
RefactoringClassTestData subclass: #AnotherclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__! !
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
m1__ self oldXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
m1__ self oldXyz__! !

!classDefinition: #ClassToAvoidRenameSelector category: #'__Refactoring-TestData__-toAvoid' stamp: 'HAW 8/30/2020 19:17:54'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-toAvoid'!
!ClassToAvoidRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
m1__ self oldXyz__! !
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
newXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54'!
newXyz__! !
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54' prior: 50849830!
m1__ self newXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54' prior: 50849838!
m1__ self newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54' prior: 50849805!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:54' prior: 50849813!
m1__ self newXyz__! !

!methodRemoval: AnotherclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__!

!methodRemoval: AnotherclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__!

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__!

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:54'!
oldXyz__!

!testRun: #RenameSelectorTest #test17ScopeToRenameCanBeCategoryOnly stamp: 'HAW 8/30/2020 19:17:54'!
PASSED!

!classRemoval: #ClassToAvoidRenameSelector stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-toAvoid'!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnotherclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #AnotherclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassToRenameSelector category: #'__Refactoring-TestData__-Another' stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #SuperclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-Another'!
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:55'!
SuperclassToRenameSelector subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849939!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849943!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849947!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849951!
m1__ self oldXyz__! !

!classDefinition: #SubclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:55'!
ClassToRenameSelector subclass: #SubclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849965!
oldXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849969!
m1__ self oldXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849974!
oldXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50849978!
m1__ self oldXyz__! !

!classDefinition: #AnotheclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #AnotheclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnotheclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__! !
!AnotheclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !
!AnotheclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__! !
!AnotheclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !

!classDefinition: #OtherCatClassToRenameSelector category: #'__Refactoring-TestData__-Another' stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #OtherCatClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-Another'!
!OtherCatClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__! !
!OtherCatClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !
!OtherCatClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__! !
!OtherCatClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !

!classDefinition: #ClassToAvoidRenameSelector category: #'__Refactoring-TestData__-toAvoid' stamp: 'HAW 8/30/2020 19:17:55'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-toAvoid'!
!ClassToAvoidRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!AnotheclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!OtherCatClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!AnotheclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50850091!
newXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' overrides: 50850075!
newXyz__! !
!OtherCatClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55'!
newXyz__! !
!AnotheclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50850023!
m1__ self newXyz__! !
!AnotheclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50850031!
m1__ self newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50849969 overrides: 50849943!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50849978 overrides: 50849951!
m1__ self newXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50849996 overrides: 50850126!
m1__ self newXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50849943!
m1__ self newXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50849951!
m1__ self newXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50850006 overrides: 50850131!
m1__ self newXyz__! !
!OtherCatClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50850057!
m1__ self newXyz__! !
!OtherCatClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:55' prior: 50850049!
m1__ self newXyz__! !

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__!

!methodRemoval: AnotheclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:55'!
oldXyz__!

!methodRemoval: SubclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: SuperclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: SuperclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: OtherCatClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: AnotheclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: SubclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!methodRemoval: OtherCatClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:56'!
oldXyz__!

!testRun: #RenameSelectorTest #test18ScopeToRenameCanBeCategoriesAndHierarchyOnly stamp: 'HAW 8/30/2020 19:17:56'!
PASSED!

!classRemoval: #ClassToAvoidRenameSelector stamp: 'HAW 8/30/2020 19:17:56'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-toAvoid'!

!classRemoval: #AnotheclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:56'!
RefactoringClassTestData subclass: #AnotheclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SubclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:57'!
ClassToRenameSelector subclass: #SubclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:57'!
SuperclassToRenameSelector subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:57'!
RefactoringClassTestData subclass: #SuperclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-Another'!

!classRemoval: #OtherCatClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:57'!
RefactoringClassTestData subclass: #OtherCatClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__-Another'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:58'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
m1__ self oldXyz__! !

!classDefinition: #AnotherclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:17:58'!
RefactoringClassTestData subclass: #AnotherclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__! !
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
m1__ self oldXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
newXyz__! !
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
newXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58' prior: 50850261!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58' prior: 50850269!
m1__ self newXyz__! !
!AnotherclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58' prior: 50850286!
m1__ self newXyz__! !
!AnotherclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:17:58' prior: 50850294!
m1__ self newXyz__! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__!

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__!

!methodRemoval: AnotherclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__!

!methodRemoval: AnotherclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:17:58'!
oldXyz__!

!testRun: #RenameSelectorTest #test19ScopeToRenameCanBeTheCompleteSystem stamp: 'HAW 8/30/2020 19:17:58'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:17:58'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnotherclassToRenameSelector stamp: 'HAW 8/30/2020 19:17:59'!
RefactoringClassTestData subclass: #AnotherclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameSelectorTest #test20CanNotRenameToItSelf stamp: 'HAW 8/30/2020 19:17:59'!
PASSED!

!testRun: #RenameSelectorTest #test21NewSelectorCanNotBeImplementedOnAnyClassImplementingOldSelector stamp: 'HAW 8/30/2020 19:17:59'!
PASSED!

!testRun: #RenameSelectorTest #test22WarnsWhenOverridesSuperclassImplementation stamp: 'HAW 8/30/2020 19:17:59'!
PASSED!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:00'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00' prior: 50850385!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
m1 ^#(#oldXyz__)! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00' prior: 50850397!
m1 ^#(#newXyz__)! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:00'!
oldXyz__!

!testRun: #RenameSelectorTest #test23OldSelectorIsRenamedWhenDefinedInLiteralArray stamp: 'HAW 8/30/2020 19:18:00'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:00'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:00'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00' prior: 50850432!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
m1 ^#(#oldXyz__ #oldXyz__)! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:00' prior: 50850444!
m1 ^#(#newXyz__ #newXyz__)! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:00'!
oldXyz__!

!testRun: #RenameSelectorTest #test24OldSelectorIsRenamedWhenDefinedInLiteralArrayMoreThanOnce stamp: 'HAW 8/30/2020 19:18:00'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:01'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:01'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:01'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:01'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:01' prior: 50850480!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:01'!
m1 ^#(#oldXyz__ #oldXyz__), #(#oldXyz__ #oldXyz__)! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:01'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:01' prior: 50850492!
m1 ^#(#newXyz__ #newXyz__), #(#newXyz__ #newXyz__)! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:01'!
oldXyz__!

!testRun: #RenameSelectorTest #test25OldSelectorIsRenamedWhenDefinedInMoreThanOneLiteralArrayMoreThanOnce stamp: 'HAW 8/30/2020 19:18:01'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:02'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:02'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02' prior: 50850530!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
m1 ^#(#oldXyz__ #oldXyz__1)! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02' prior: 50850542!
m1 ^#(#newXyz__ #oldXyz__1)! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:02'!
oldXyz__!

!testRun: #RenameSelectorTest #test26DoesNotRenameLiteralsThatBeginsWithOldSelectorInsideLiteralArray stamp: 'HAW 8/30/2020 19:18:02'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:02'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:02'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
m1__ self oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02' prior: 50850578!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
m1 ^#(#oldXyz__ #oldXyz__:)! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:02' prior: 50850590!
m1 ^#(#newXyz__ #oldXyz__:)! !

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:02'!
oldXyz__!

!testRun: #RenameSelectorTest #test27DoesNotRenameLiteralsThatBeginsWithOldSelectorAndEndWithColonInsideLiteralArray stamp: 'HAW 8/30/2020 19:18:02'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:03'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:03'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:03'!
&& aParameter! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:03'!
m1 ^self && 1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:03'!
abc: aParameter! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:03' prior: 50850631!
m1 ^self abc: 1! !

!methodRemoval: ClassToRenameSelector #&& stamp: 'HAW 8/30/2020 19:18:03'!
&& aParameter!

!testRun: #RenameSelectorTest #test28CanRenameFromBinaryToKeywordOfOneParameter stamp: 'HAW 8/30/2020 19:18:03'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:04'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:04'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:04'!
abc: aParameter! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:04'!
m1 ^self abc: 1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:04'!
&& aParameter! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:04' prior: 50850670!
m1 ^self && 1! !

!methodRemoval: ClassToRenameSelector #abc: stamp: 'HAW 8/30/2020 19:18:04'!
abc: aParameter!

!testRun: #RenameSelectorTest #test29CanRenameFromKeywordOfOneParameterToBinary stamp: 'HAW 8/30/2020 19:18:04'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:04'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:04'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:04'!
&& aParameter! !

!testRun: #RenameSelectorTest #test30CanNotRenameFromBinaryToKeywordOfMoreThanOneParameter stamp: 'HAW 8/30/2020 19:18:04'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:05'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:05'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:05'!
abc: p1 def: p2! !

!testRun: #RenameSelectorTest #test31CanNotRenameFromKeywordOfOneParameterToBinary stamp: 'HAW 8/30/2020 19:18:05'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:06'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SuperclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:06'!
RefactoringClassTestData subclass: #SuperclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06'!
m1__ self oldXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06'!
m1__ self oldXyz__! !

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:06'!
SuperclassToRenameSelector subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850754!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850758!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850762!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850766!
m1__ self oldXyz__! !

!classDefinition: #SubclassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:06'!
SuperclassToRenameSelector subclass: #SubclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850754!
oldXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850758!
m1__ self oldXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850762!
oldXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850766!
m1__ self oldXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06'!
newXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850825!
newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850829!
newXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850825!
newXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' overrides: 50850829!
newXyz__! !
!SuperclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' prior: 50850758!
m1__ self newXyz__! !
!SuperclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' prior: 50850766!
m1__ self newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' prior: 50850784 overrides: 50850850!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' prior: 50850793 overrides: 50850855!
m1__ self newXyz__! !
!SubclassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' prior: 50850811 overrides: 50850850!
m1__ self newXyz__! !
!SubclassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:06' prior: 50850821 overrides: 50850855!
m1__ self newXyz__! !

!methodRemoval: SuperclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__!

!methodRemoval: SuperclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__!

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__!

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__!

!methodRemoval: SubclassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__!

!methodRemoval: SubclassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:18:06'!
oldXyz__!

!testRun: #RenameSelectorTest #test32HierarchyScopeRenamesSelectorsFromSuperclassDefiningSelector stamp: 'HAW 8/30/2020 19:18:06'!
PASSED!

!classRemoval: #SubclassToRenameSelector stamp: 'HAW 8/30/2020 19:18:06'!
SuperclassToRenameSelector subclass: #SubclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:07'!
SuperclassToRenameSelector subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #SuperclassToRenameSelector stamp: 'HAW 8/30/2020 19:18:07'!
RefactoringClassTestData subclass: #SuperclassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:07'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
m1__ self oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
m1__ self oldXyz__! !

!classDefinition: #ClassToAvoidRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:07'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAvoidRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__! !
!ClassToAvoidRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
m1__ self oldXyz__! !
!ClassToAvoidRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__! !
!ClassToAvoidRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
m1__ self oldXyz__! !
!ClassToAvoidRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07' overrides: 16782761!
compilerClass ^nil! !
!ClassToAvoidRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07'!
newXyz__! !
!ClassToAvoidRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07' prior: 50850971!
m1__ self newXyz__! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07' prior: 50850938!
m1__ self newXyz__! !
!ClassToRenameSelector class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:07' prior: 50850946!
m1__ self newXyz__! !

!methodRemoval: ClassToAvoidRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__!

!methodRemoval: ClassToRenameSelector #oldXyz__ stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__!

!methodRemoval: ClassToRenameSelector class #oldXyz__ stamp: 'HAW 8/30/2020 19:18:07'!
oldXyz__!

!testRun: #RenameSelectorTest #test33DoNotRenameSendersAndImplementorsWhoseCompilerClassIsDifferentToCompiler stamp: 'HAW 8/30/2020 19:18:07'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:18:08'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAvoidRenameSelector stamp: 'HAW 8/30/2020 19:18:08'!
RefactoringClassTestData subclass: #ClassToAvoidRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameTemporaryTest #test01VariableToRenameHasToBeDefined stamp: 'HAW 8/30/2020 19:18:08'!
PASSED!

!testRun: #RenameTemporaryTest #test02NewVariableNameCanNotBeEmpty stamp: 'HAW 8/30/2020 19:18:08'!
PASSED!

!testRun: #RenameTemporaryTest #test03NewVariableHasToBeValid stamp: 'HAW 8/30/2020 19:18:09'!
PASSED!

!testRun: #RenameTemporaryTest #test04NewVariableNameCanNotBeDefinedInMethod stamp: 'HAW 8/30/2020 19:18:09'!
PASSED!

!classDefinition: #ClassToRenameTemp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:10'!
RefactoringClassTestData subclass: #ClassToRenameTemp
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameTemporaryTest #test05FailsIfNewTemporaryIsEqualToInstanceVariableInClass stamp: 'HAW 8/30/2020 19:18:10'!
PASSED!

!classRemoval: #ClassToRenameTemp stamp: 'HAW 8/30/2020 19:18:10'!
RefactoringClassTestData subclass: #ClassToRenameTemp
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRefactorSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:10'!
RefactoringClassTestData subclass: #ClassToRefactorSuperclass
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameTemp category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:10'!
ClassToRefactorSuperclass subclass: #ClassToRenameTemp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameTemporaryTest #test06FailsIfNewTemporaryIsEqualToInstanceVariableInAnySuperclass stamp: 'HAW 8/30/2020 19:18:10'!
PASSED!

!classRemoval: #ClassToRenameTemp stamp: 'HAW 8/30/2020 19:18:11'!
ClassToRefactorSuperclass subclass: #ClassToRenameTemp
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRefactorSuperclass stamp: 'HAW 8/30/2020 19:18:11'!
RefactoringClassTestData subclass: #ClassToRefactorSuperclass
	instanceVariableNames: 'new'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameTemporaryTest #test07RenameCreatesNewTemporaryVariableAndDeletesOldOne stamp: 'HAW 8/30/2020 19:18:11'!
PASSED!

!testRun: #RenameTemporaryTest #test08RenameChangesReferencesFromOldVariableToNewVariable stamp: 'HAW 8/30/2020 19:18:12'!
PASSED!

!testRun: #RenameTemporaryTest #test09RenamesArguments stamp: 'HAW 8/30/2020 19:18:12'!
PASSED!

!testRun: #RenameTemporaryTest #test10NewVariableNameCanNotBeDefinedAsBlockArgument stamp: 'HAW 8/30/2020 19:18:12'!
PASSED!

!testRun: #RenameTemporaryTest #test11RenamesBlockArguments stamp: 'HAW 8/30/2020 19:18:13'!
PASSED!

!testRun: #RenameTemporaryTest #test12RenamesBlockTemporaries stamp: 'HAW 8/30/2020 19:18:13'!
PASSED!

!testRun: #RenameTemporaryTest #test13OldNodeMustBePartOfMethodNode stamp: 'HAW 8/30/2020 19:18:14'!
PASSED!

!testRun: #RenameTemporaryTest #test14OldVariableNodeMustBeArgOrTempNode stamp: 'HAW 8/30/2020 19:18:14'!
PASSED!

!testRun: #RenameTemporaryTest #test15RenameVariablesWithSameNameInDifferentBlocksCorrectly stamp: 'HAW 8/30/2020 19:18:15'!
PASSED!

!testRun: #RenameTemporaryTest #test16CantRenameVariableToANameAlreadyUsedInAnUpperBlock stamp: 'HAW 8/30/2020 19:18:15'!
PASSED!

!testRun: #RenameTemporaryTest #test17RenamesOneCharVariableAfterAReturnWithoutCharsAfterThatCorrectly stamp: 'HAW 8/30/2020 19:18:15'!
PASSED!

!testRun: #RenameTemporaryTest #test18CantRenameVariableToAReservedName stamp: 'HAW 8/30/2020 19:18:16'!
PASSED!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:16'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:17'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #SafelyRemoveClassTest #test02ClassesWithNoReferencesAndNoSubclassesAreSafetelyRemoved stamp: 'HAW 8/30/2020 19:18:17'!
PASSED!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:17'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:17'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #SafelyRemoveClassTest #test03RemovingTheMetaclassRemovesTheClass stamp: 'HAW 8/30/2020 19:18:17'!
PASSED!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:18'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:18'!
RefactoringClassTestData subclass: #ClassReferencingClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassToRemove methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:18'!
m1 ^ClassToRemove! !

!testRun: #SafelyRemoveClassTest #test04CanNotRemoveClassWithReferencesOutsideHierarchy stamp: 'HAW 8/30/2020 19:18:18'!
PASSED!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:19'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassToRemove stamp: 'HAW 8/30/2020 19:18:19'!
RefactoringClassTestData subclass: #ClassReferencingClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:19'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemove methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:19'!
m1 ^ClassToRemove! !

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:19'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #SafelyRemoveClassTest #test05CanRemoveClassWithReferencesFromItself stamp: 'HAW 8/30/2020 19:18:19'!
PASSED!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:20'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveSubclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:20'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #SafelyRemoveClassTest #test06WarnIfClassToRemoveHasSubclasses stamp: 'HAW 8/30/2020 19:18:20'!
PASSED!

!classRemoval: #ClassToRemoveSubclass stamp: 'HAW 8/30/2020 19:18:20'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:21'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:21'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveSubclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:21'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassToRemoveSubclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:21'!
RefactoringClassTestData subclass: #ClassReferencingClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassToRemoveSubclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:21'!
m1 ^ClassToRemoveSubclass! !

!testRun: #SafelyRemoveClassTest #test07CanNotRemoveClassWhenSubclassesHaveReferencesOutsideTheHierarchy stamp: 'HAW 8/30/2020 19:18:21'!
PASSED!

!classRemoval: #ClassToRemoveSubclass stamp: 'HAW 8/30/2020 19:18:21'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:22'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassToRemoveSubclass stamp: 'HAW 8/30/2020 19:18:22'!
RefactoringClassTestData subclass: #ClassReferencingClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:22'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveSubclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:22'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveSubclass stamp: 'HAW 8/30/2020 19:18:22'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:23'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #SafelyRemoveClassTest #test08HierarchyIsRemovedIfSubclassesWarningIsResumed stamp: 'HAW 8/30/2020 19:18:23'!
PASSED!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:23'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveSubclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:23'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemove methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:23'!
m1 ^ClassToRemoveSubclass! !
!ClassToRemoveSubclass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:23'!
m2 ^ClassToRemove! !

!classRemoval: #ClassToRemoveSubclass stamp: 'HAW 8/30/2020 19:18:24'!
ClassToRemove subclass: #ClassToRemoveSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:24'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #SafelyRemoveClassTest #test09CanRemoveIfReferencesToSubclassesAreInTheHierarchy stamp: 'HAW 8/30/2020 19:18:24'!
PASSED!

!classDefinition: #ClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:24'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassReferencingClassToRemove category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:24'!
RefactoringClassTestData subclass: #ClassReferencingClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassReferencingClassToRemove methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:24'!
m1 ^#ClassToRemove! !

!testRun: #SafelyRemoveClassTest #test10WarnWhenHasReferencesToName stamp: 'HAW 8/30/2020 19:18:24'!
PASSED!

!classRemoval: #ClassToRemove stamp: 'HAW 8/30/2020 19:18:25'!
RefactoringClassTestData subclass: #ClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassReferencingClassToRemove stamp: 'HAW 8/30/2020 19:18:25'!
RefactoringClassTestData subclass: #ClassReferencingClassToRemove
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:25'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:25'!
m1| a |! !
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:25' prior: 50851475!
m1 ! !

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:25'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #TemporaryToInstanceVariableTest #test01ApplyChangesTemporaryVariableToInstanceVariable stamp: 'HAW 8/30/2020 19:18:25'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:26'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:26'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:26'!
m1| a |a := 2.
	^a! !
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:26' prior: 50851512!
m1 a := 2.
	^a! !

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:26'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #TemporaryToInstanceVariableTest #test02ApplyDoesntChangeRestOfSourceCode stamp: 'HAW 8/30/2020 19:18:26'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:27'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:27'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:27'!
m1! !

!testRun: #TemporaryToInstanceVariableTest #test03TemporaryToChangeShouldExist stamp: 'HAW 8/30/2020 19:18:27'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:27'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:27'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:27'!
m1| a |! !
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:27'!
m2| a |! !

!testRun: #TemporaryToInstanceVariableTest #test04TemporaryShouldNotExistInOtherClassMethod stamp: 'HAW 8/30/2020 19:18:27'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:28'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:28'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:28'!
ClassToChangeVariable subclass: #SubclassToRefactor
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:28'!
m1| a |! !

!testRun: #TemporaryToInstanceVariableTest #test05InstanceVariableShouldNotExistInSubclass stamp: 'HAW 8/30/2020 19:18:28'!
PASSED!

!classRemoval: #SubclassToRefactor stamp: 'HAW 8/30/2020 19:18:28'!
ClassToChangeVariable subclass: #SubclassToRefactor
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:29'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:29'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #SubclassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:29'!
ClassToChangeVariable subclass: #SubclassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:29'!
m1| a |! !
!SubclassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:29'!
m2| a |! !

!testRun: #TemporaryToInstanceVariableTest #test06TemporaryShouldNotExistInSubclassMethod stamp: 'HAW 8/30/2020 19:18:29'!
PASSED!

!classRemoval: #SubclassToRefactor stamp: 'HAW 8/30/2020 19:18:29'!
ClassToChangeVariable subclass: #SubclassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:30'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:30'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:30'!
m1| a |! !
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:30' prior: 50851685!
m1 ! !

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:30'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #TemporaryToInstanceVariableTest #test07RemovesPipesWhenRemovingLastTemporaryInMethod stamp: 'HAW 8/30/2020 19:18:30'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:30'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:30'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:30'!
m1| a b |! !
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:30' prior: 50851722!
m1|  b |! !

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:30'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #TemporaryToInstanceVariableTest #test08DoesntRemoveOtherVariables stamp: 'HAW 8/30/2020 19:18:30'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:31'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:31'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:31'!
m1
	[ | a | ].
	[ | a | ].! !

!testRun: #TemporaryToInstanceVariableTest #test09TemporaryShouldNotExistInOtherBlockInSameMethod stamp: 'HAW 8/30/2020 19:18:31'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:32'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:32'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:32'!
m1
	[ | a | ].! !
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:32' prior: 50851784!
m1
	[   ].! !

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:32'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #TemporaryToInstanceVariableTest #test10RemovesPipesWhenRemovingLastTemporaryInBlock stamp: 'HAW 8/30/2020 19:18:32'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:32'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: 'a'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:32'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:32'!
m1 [ | a | ]. [ :a | ].! !

!testRun: #TemporaryToInstanceVariableTest #test11TemporaryShouldNotExistAsArgumentInOtherBlocksInSameMethod stamp: 'HAW 8/30/2020 19:18:32'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:33'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToChangeVariable category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:33'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToChangeVariable methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:33'!
m1: a! !

!testRun: #TemporaryToInstanceVariableTest #test12CantExtractArgument stamp: 'HAW 8/30/2020 19:18:33'!
PASSED!

!classRemoval: #ClassToChangeVariable stamp: 'HAW 8/30/2020 19:18:34'!
RefactoringClassTestData subclass: #ClassToChangeVariable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:34'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:34'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:34'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test01MethodObjectClassNameMustNotBeEmpty stamp: 'HAW 8/30/2020 19:18:34'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:34'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:35'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:35'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:35'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:35'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test02MethodObjectClassNameMustBeASymbol stamp: 'HAW 8/30/2020 19:18:35'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:35'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:36'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test03MethodObjectClassNameMustStartWithUppercaseLetter stamp: 'HAW 8/30/2020 19:18:36'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:36'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:36'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test04MethodObjectClassNameMustNotHaveSeparators stamp: 'HAW 8/30/2020 19:18:36'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:37'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:37'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:37'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:37'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:37'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test05MethodObjectClassNameMustNotExist stamp: 'HAW 8/30/2020 19:18:37'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:38'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:38'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:38'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:38'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:38'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test06AllVariablesToParametrizeMustHaveACorrespondingMethodObjectInstanceVariableName stamp: 'HAW 8/30/2020 19:18:38'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:39'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:39'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:39'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:39'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:39'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test07AllInstanceVariableNamesMustCorrespondToVariableToParametrize stamp: 'HAW 8/30/2020 19:18:39'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:40'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:40'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:40'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:40'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:40'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test08MethodObjectInstanceVariableNamesMustNotBeEmpty stamp: 'HAW 8/30/2020 19:18:40'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:41'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:41'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:41'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:41'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:41'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test09MethodObjectInstanceVariableNamesCanNotContainBlanks stamp: 'HAW 8/30/2020 19:18:41'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:42'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:42'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:42'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:42'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:42'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test10MethodObjectInstanceVariableNamesCanNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:18:42'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:43'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:43'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:43'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: 'anInstVarName'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:43'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:43'!
m1
		self isNil.! !

!testRun: #ExtractToMethodObjectTest #test11MethodObjectInstanceVariableNamesCanNotBeDefinedInSuperclasses stamp: 'HAW 8/30/2020 19:18:43'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:44'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: 'anInstVarName'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:44'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:44'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:44'!
m1
		self isNil.
		anInstVar isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:44'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test12MethodObjectInstanceVariableNamesCanNotBeDuplicated stamp: 'HAW 8/30/2020 19:18:44'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:45'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:18:45'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:45'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:45'!
m1
		| aTemporal |

		aTemporal := 1.
		self isNil.

		^aTemporal + 2! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:45'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test13MethodObjectInstanceVariableNamesCanNotBeNamedAsMethodTemporal stamp: 'HAW 8/30/2020 19:18:45'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:46'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:18:46'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:46'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:46'!
m1
		^[
			| aBlockTemporal |

			self isNil.
			aBlockTemporal.]! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:46'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test14MethodObjectInstanceVariableNamesCanNotBeNamedAsBlockTemporal stamp: 'HAW 8/30/2020 19:18:46'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:46'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:18:47'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:47'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:47'!
m1
		^[:aBlockArgument |
			self isNil.
			aBlockArgument.]! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:47'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test15MethodObjectInstanceVariableNamesCanNotBeNamedAsBlockArgument stamp: 'HAW 8/30/2020 19:18:47'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:47'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:18:48'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:48'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:48'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test16MethodObjectInstanceCreationMessageMustHaveAKeywordForEveryVariableToParametrize stamp: 'HAW 8/30/2020 19:18:48'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:48'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:48'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:49'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test17MethodObjectInstanceCreationMessageMustHaveOnlyOneKeywordForEveryVariableToParametrize stamp: 'HAW 8/30/2020 19:18:49'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:49'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:49'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:49'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test18MethodObjectInstanceCreationMessageMustNotHaveKeywordForAnUnknownVariableToParametrize stamp: 'HAW 8/30/2020 19:18:49'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:50'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:50'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:50'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:50'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:50'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test19MethodObjectInstanceCreationMessageKeywordsCanNotHaveInvalidCharacters stamp: 'HAW 8/30/2020 19:18:50'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:51'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:51'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:51'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:51'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:51'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test20MethodObjectInstanceCreationMessageSelectorStartsWithAnInvalidStartOfSelector stamp: 'HAW 8/30/2020 19:18:51'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:52'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:52'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:52'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:52'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:52'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test21MethodObjectInstanceCreationMessageKeywordsCannotBeEmpty stamp: 'HAW 8/30/2020 19:18:52'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:53'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:53'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:53'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:53'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:53'!
m1! !

!testRun: #ExtractToMethodObjectTest #test22MethodObjectSuperclassCannotBeMeta stamp: 'HAW 8/30/2020 19:18:53'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:54'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:54'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:54'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:54'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:54'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:54'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:54'!
defaultEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:54' prior: 50852738!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test23CreatesMethodObjectClass stamp: 'HAW 8/30/2020 19:18:54'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:18:55'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:55'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:55'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:55'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:55'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:55'!
m1! !

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:55'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:55'!
defaultEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:55' prior: 50852808!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test24CreatesMethodObjectClassAsSubclassOfTheChosenSuperclass stamp: 'HAW 8/30/2020 19:18:55'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:18:56'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:56'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:56'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:57'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:57'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:57'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:57'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:57'!
defaultEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:57' prior: 50852861!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test25CreatesMethodObjectClassInTheChosenCategory stamp: 'HAW 8/30/2020 19:18:57'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:18:57'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:57'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:58'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:58'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:58'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:58'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:58'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:58'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:58'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:58'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:58' prior: 50852923!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test26MethodObjectClassInstanceCreationMessageReceivesTheSameNumberOfArgumentsAsVariablesToParametrizeInMethodToExtract stamp: 'HAW 8/30/2020 19:18:58'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:18:58'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:18:59'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:18:59'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:59'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:59'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:59'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:18:59'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:59'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:59'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:59'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:18:59' prior: 50852999!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test27MethodObjectClassInstanceCreationMessageSelectorConsistsOfTheChosenKeywords stamp: 'HAW 8/30/2020 19:18:59'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:00'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:00'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:00'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:00'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:00'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:00'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:00'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:00'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:00'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:00'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:00' prior: 50853074!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test28MethodObjectClassInstanceCreationMessageCreatesARefactoringInstance stamp: 'HAW 8/30/2020 19:19:00'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:01'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:01'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:02'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:02'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:02'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:02'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:02'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:02'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:02'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:02'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:02' prior: 50853149!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test29MethodObjectInitializationMessageReceivesTheSameNumberOfArgumentsAsVariablesToParametrizeInMethodToExtract stamp: 'HAW 8/30/2020 19:19:02'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:02'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:02'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:03'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:03'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:03'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:03'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:03'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:03'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:03'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:03'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:03' prior: 50853225!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test30MethodObjectInitializationMessageSelectorConsistsOfTheChosenKeywordsPrefixedWithInitializationPrefix stamp: 'HAW 8/30/2020 19:19:03'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:04'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:04'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:04'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:04'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:04'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:04'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:04'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:04'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:04'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:04'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:04' prior: 50853301!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test31MethodObjectInitializationMessageAssignsTheInstanceVariables stamp: 'HAW 8/30/2020 19:19:04'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:05'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:05'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:05'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:05'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:05'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:05'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:05'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:05'!
aCustomEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:05' prior: 50853376!
m1
	(MethodObject new) aCustomEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test32MethodObjectEvaluationMessageHasTheChosenSelector stamp: 'HAW 8/30/2020 19:19:05'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:06'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:06'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:07'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:07'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:07'!
m1
	self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:07'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:07'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:07'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:07'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:07'!
defaultEvaluationSelector
	thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:07' prior: 50853438!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test33MethodObjectEvaluationMethodSourceCodeHasTheSameFormatAsTheExtractedMethod stamp: 'HAW 8/30/2020 19:19:07'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:07'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:07'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:08'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:08'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:08'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:08'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:08'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:08'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:08'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:08'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:08' prior: 50853513!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test34MethodObjectEvaluationMethodSourceCodeReferencesCorrespondingInstanceVariableInsteadOfSelf stamp: 'HAW 8/30/2020 19:19:08'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:08'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:09'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:09'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:09'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:09'!
m1
		anInstVar isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:09'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:09'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'aCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:09'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:09'!
initializeWith: aParamName
	aCorrespondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:09'!
defaultEvaluationSelector
		aCorrespondingInstVar isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:09' prior: 50853589!
m1
	(MethodObject with: anInstVar) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test35MethodObjectEvaluationMethodSourceCodeReferencesCorrespondingInstanceVariableInsteadOfClassToRefactorInstanceVariable stamp: 'HAW 8/30/2020 19:19:09'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:10'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'aCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:10'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:10'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:10'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:10'!
m1: anArg
		anArg isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:10'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:10'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'anArgReplacement'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:10'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:10'!
initializeWith: aParamName
	anArgReplacement := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:10'!
defaultEvaluationSelector
		anArgReplacement isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:10' prior: 50853667!
m1: anArg
	(MethodObject with: anArg) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test36MethodObjectEvaluationMethodSourceCodeReferencesCorrespondingInstanceVariableInsteadOfExtractedMethodArgument stamp: 'HAW 8/30/2020 19:19:10'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:11'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'anArgReplacement'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:11'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:11'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #APool category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:11'!
SharedPool subclass: #APool
	instanceVariableNames: ''
	classVariableNames: 'APoolVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:11'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'APool'
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:11'!
m1
		APoolVar isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:11'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:11'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'aCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:11'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:11'!
initializeWith: aParamName
	aCorrespondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:11'!
defaultEvaluationSelector
		aCorrespondingInstVar isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:11' prior: 50853752!
m1
	(MethodObject with: APoolVar) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test37MethodObjectEvaluationMethodSourceCodeReferencesCorrespondingInstanceVariableInsteadOfClassToRefactorPoolVariable stamp: 'HAW 8/30/2020 19:19:11'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:12'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'APool'
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:12'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'aCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:13'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #APool stamp: 'HAW 8/30/2020 19:19:13'!
SharedPool subclass: #APool
	instanceVariableNames: ''
	classVariableNames: 'APoolVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:13'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:13'!
m1
		"A comment talking about self"
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:13'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:13'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:13'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:13'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:13'!
defaultEvaluationSelector
		"A comment talking about self"
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:13' prior: 50853836!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test38MethodObjectEvaluationMethodSourceCodeCommentsReferencingParametrizedVariableAreNotReplaced stamp: 'HAW 8/30/2020 19:19:13'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:14'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:14'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:14'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:14'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test39MethodObjectEvaluationMethodSourceCodePreservesBlockArgumentsShadowing stamp: 'HAW 8/30/2020 19:19:14'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:15'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:15'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test40MethodObjectEvaluationMethodSourceCodePreservesBlockTemporalsShadowing stamp: 'HAW 8/30/2020 19:19:15'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:15'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:16'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:16'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:16'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:16'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:16'!
defaultEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:16' prior: 50853954!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test41RefactoredMethodUnarySelectorIsPreserved stamp: 'HAW 8/30/2020 19:19:16'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:16'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:16'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:17'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:17'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:17'!
!!@ anArg ^anArg.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:17'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:17'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:17'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:17'!
initializeWith: aParamName
	correspondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:17'!
defaultEvaluationSelector ^correspondingInstVar.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:17' prior: 50854016!
!!@ anArg
	^(MethodObject with: anArg) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test42RefactoredMethodBinarySelectorIsPreserved stamp: 'HAW 8/30/2020 19:19:17'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:17'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:18'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:18'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:18'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:18'!
m1: anArg ^anArg.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:18'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:18'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:18'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:18'!
initializeWith: aParamName
	correspondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:18'!
defaultEvaluationSelector ^correspondingInstVar.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:18' prior: 50854092!
m1: anArg
	^(MethodObject with: anArg) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test43RefactoredMethodKeywordSelectorIsPreserved stamp: 'HAW 8/30/2020 19:19:18'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:19'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:19'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:19'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:19'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:19'!
!!@ anArg ^anArg.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:19'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:19'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:19'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:19'!
initializeWith: aParamName
	correspondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:19'!
defaultEvaluationSelector ^correspondingInstVar.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:19' prior: 50854168!
!!@ anArg
	^(MethodObject with: anArg) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test44WhenBinaryMethodIsRefactoredArgumentNameIsPreserved stamp: 'HAW 8/30/2020 19:19:19'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:20'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:20'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:21'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:21'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:21'!
m1: anArg ^anArg.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:21'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:21'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:21'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:21'!
initializeWith: aParamName
	correspondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:21'!
defaultEvaluationSelector ^correspondingInstVar.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:21' prior: 50854244!
m1: anArg
	^(MethodObject with: anArg) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test45WhenKeywordsMethodIsRefactoredArgumentNamesArePreserved stamp: 'HAW 8/30/2020 19:19:21'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:21'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:22'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:22'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:22'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:22'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:22'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:22'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:22'!
defaultEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:22' prior: 50854320!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test46WhenThereAreNoVariablesToParametrizeTheRefactoredMethodUsesTheNewMessageToCreateTheMethodObjectInstance stamp: 'HAW 8/30/2020 19:19:22'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:22'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:23'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:23'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:23'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:23'!
m1 ^self isNil! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:23'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:23'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:23'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:23'!
initializeWith: aParamName
	correspondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:23'!
defaultEvaluationSelector ^correspondingInstVar isNil! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:23' prior: 50854383!
m1
	^(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test47WhenThereAreVariablesToParametrizeTheRefactoredMethodUsesTheChosenMessageToCreateTheMethodObjectInstance stamp: 'HAW 8/30/2020 19:19:23'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:24'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'correspondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:24'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:24'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:24'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:24'!
m1: anArg ^(self isNil) or: (anArg isNil)! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:24'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:24'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'anArgCorrespondingInstVar selfCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:24'!
with: anArgParamName andWith: aSelfParamName
	^self new initializeWith: anArgParamName andWith: aSelfParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:24'!
initializeWith: anArgParamName andWith: aSelfParamName
	anArgCorrespondingInstVar := anArgParamName.
	selfCorrespondingInstVar := aSelfParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:24'!
defaultEvaluationSelector ^(selfCorrespondingInstVar isNil) or: (anArgCorrespondingInstVar isNil)! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:24' prior: 50854460!
m1: anArg
	^(MethodObject with: anArg andWith: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test48WhenThereAreMultipleVariablesToParametrizeTheRefactoredMethodPassesTheVariablesInTheChosenOrderToTheMessageToCreateTheMethodObjectInstance stamp: 'HAW 8/30/2020 19:19:24'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:25'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'anArgCorrespondingInstVar selfCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:25'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:25'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:26'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:26'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:26'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:26'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:26'!
defaultEvaluationSelector! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:26' prior: 50854547!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test49TheRefactoredMethodUsesTheChosenEvaluationSelectorToEvaluateTheMethodObjectInstance stamp: 'HAW 8/30/2020 19:19:26'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:26'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:26'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:27'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:27'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:27'!
m1
		| a |

		a := 1 + 1.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:27'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:27'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:27'!
defaultEvaluationSelector
		| a |

		a := 1 + 1.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:27' prior: 50854610!
m1
	(MethodObject new) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test50TheRefactoredMethodPreservesTheImplicitReturn stamp: 'HAW 8/30/2020 19:19:27'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:27'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:28'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:28'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:28'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:28'!
m1 ^super isNil! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:28'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test51TheMethodToExtractMustNotReferenceSuper stamp: 'HAW 8/30/2020 19:19:28'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:29'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:29'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:29'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:29'!
m1
		anInstVar := 2.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:29'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test52TheMethodToExtractMustNotContainInstVarAssignments stamp: 'HAW 8/30/2020 19:19:29'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:30'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:30'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:30'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: 'AClassVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:30'!
m1
		AClassVar := 2.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:30'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test53TheMethodToExtractMustNotContainClassVarAssignments stamp: 'HAW 8/30/2020 19:19:30'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:30'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: 'AClassVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:31'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #APool category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:31'!
SharedPool subclass: #APool
	instanceVariableNames: ''
	classVariableNames: 'APoolVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:31'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'APool'
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:31'!
m1
		APoolVar := 2.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:31'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test54TheMethodToExtractMustNotContainPoolVarAssignments stamp: 'HAW 8/30/2020 19:19:31'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:31'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'APool'
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:32'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #APool stamp: 'HAW 8/30/2020 19:19:32'!
SharedPool subclass: #APool
	instanceVariableNames: ''
	classVariableNames: 'APoolVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:32'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: 'AClassVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:32'!
m1
		AClassVar isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:32'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:32'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'aCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:32'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:32'!
initializeWith: aParamName
	aCorrespondingInstVar := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:32'!
defaultEvaluationSelector
		aCorrespondingInstVar isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:32' prior: 50854843!
m1
	(MethodObject with: AClassVar) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test55MethodObjectEvaluationMethodSourceCodeReferencesCorrespondingInstanceVariableInsteadOfClassToRefactorClassVariable stamp: 'HAW 8/30/2020 19:19:32'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:33'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: 'AClassVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:33'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'aCorrespondingInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:33'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:33'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:33'!
m1 self = anInstVar ifTrue: [^1] ifFalse: [^2]! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:33'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test56MethodObjectInstanceCreationMessageParameterNamesMustNotRepeat stamp: 'HAW 8/30/2020 19:19:33'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:34'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:34'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:34'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:34'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:34'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test57MethodObjectInstanceCreationMessageParameterNamesMustNotBeEmpty stamp: 'HAW 8/30/2020 19:19:34'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:35'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:35'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:35'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:35'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:35'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test58MethodObjectInstanceCreationMessageParameterNamesMustNotContainSeparators stamp: 'HAW 8/30/2020 19:19:35'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:35'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:36'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:36'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:36'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:36'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test59MethodObjectInstanceCreationMessageParameterNamesMustNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:19:36'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:36'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:37'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:37'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:37'!
m1 self = anInstVar ifTrue: [^1] ifFalse: [^2]! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:37'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test60MethodObjectInstanceCreationMessageParameterNamesMustNotBeEqualToAMethodObjectInstanceVariable stamp: 'HAW 8/30/2020 19:19:37'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:37'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:38'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:38'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:38'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:38'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:38'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:38'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:38'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:38'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:38' prior: 50855121!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test61MethodObjectClassInstanceCreationMessageParameterNamesAreTheChosenOnes stamp: 'HAW 8/30/2020 19:19:38'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:38'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:39'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:39'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:39'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:39'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:39'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:39'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:39'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:39'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:39'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:39' prior: 50855196!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test62MethodObjectInstanceCreationMessageParameterNamesAreTheChosenOnes stamp: 'HAW 8/30/2020 19:19:39'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:40'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:40'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:40'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:40'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:40'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:40'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:40'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:40'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:40'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:40'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:40' prior: 50855271!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test63MethodObjectInstanceInitializationMessageIsCategorizedAsInitialization stamp: 'HAW 8/30/2020 19:19:40'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:41'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:41'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:41'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:41'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:41'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:41'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:41'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:41'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:41'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:41'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:41' prior: 50855346!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test64MethodObjectInstanceCreationMessageIsCategorizedAsInstanceCreation stamp: 'HAW 8/30/2020 19:19:41'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:42'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:42'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:43'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:43'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:43'!
m1
		self isNil.! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:43'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #MethodObject category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:43'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!MethodObject class methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:43'!
with: aParamName
	^self new initializeWith: aParamName! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:43'!
initializeWith: aParamName
	thePreviousSelf := aParamName.! !
!MethodObject methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:43'!
defaultEvaluationSelector
		thePreviousSelf isNil.! !
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:43' prior: 50855421!
m1
	(MethodObject with: self) defaultEvaluationSelector! !

!testRun: #ExtractToMethodObjectTest #test65MethodObjectEvaluationMessageIsCategorizedAsEvaluating stamp: 'HAW 8/30/2020 19:19:43'!
PASSED!

!classRemoval: #MethodObject stamp: 'HAW 8/30/2020 19:19:43'!
MethodObjectSuperclass subclass: #MethodObject
	instanceVariableNames: 'thePreviousSelf'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:43'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:44'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:44'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:44'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:44'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test66MethodObjectEvaluationSelectorMustNotBeEmpty stamp: 'HAW 8/30/2020 19:19:44'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:44'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:45'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:45'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:45'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:45'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test67MethodObjectEvaluationSelectorMustNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:19:45'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:45'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:46'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:46'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:46'!
m1! !

!classDefinition: #MethodObjectSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:46'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #ExtractToMethodObjectTest #test68MethodObjectEvaluationSelectorMustNotStartWithAnInvalidStartOfSelector stamp: 'HAW 8/30/2020 19:19:46'!
PASSED!

!classRemoval: #MethodObjectSuperclass stamp: 'HAW 8/30/2020 19:19:46'!
RefactoringClassTestData subclass: #MethodObjectSuperclass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:19:47'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:47'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IfNilChecksFinderTest #test01InstanceVariableMustBelongToTheClass stamp: 'HAW 8/30/2020 19:19:47'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:47'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:47'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IfNilChecksFinderTest #test02WhenThereAreNoIfNilChecksTheResultIsEmpty stamp: 'HAW 8/30/2020 19:19:47'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:48'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:48'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:48'!
m1 randomInstVar ifNil: [ 1 + 1 ]! !

!testRun: #IfNilChecksFinderTest #test03ResultIncludesIfNilMessageSending stamp: 'HAW 8/30/2020 19:19:48'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:48'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:48'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:48'!
m1 randomInstVar ifNotNil: [ 1 + 1 ]! !

!testRun: #IfNilChecksFinderTest #test04ResultIncludesIfNotNilMessageSending stamp: 'HAW 8/30/2020 19:19:48'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:49'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:49'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:49'!
m1 randomInstVar ifNil: [ 2 + 2 ] ifNotNil: [ 1 + 1 ]! !

!testRun: #IfNilChecksFinderTest #test05ResultIncludesIfNilIfNotNilMessageSending stamp: 'HAW 8/30/2020 19:19:49'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:50'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:50'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:50'!
m1 randomInstVar ifNotNil: [ 2 + 2 ] ifNil: [ 1 + 1 ]! !

!testRun: #IfNilChecksFinderTest #test06ResultIncludesIfNotNilIfNilMessageSending stamp: 'HAW 8/30/2020 19:19:50'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:50'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:50'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:50'!
m1 randomInstVar isNil ifTrue: [ 2 + 2 ]! !

!testRun: #IfNilChecksFinderTest #test07ResultIncludesIsNilIfTrueMessageSending stamp: 'HAW 8/30/2020 19:19:50'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:51'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:51'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:51'!
m1 randomInstVar isNil ifFalse: [ 2 + 2 ]! !

!testRun: #IfNilChecksFinderTest #test08ResultIncludesIsNilIfFalseMessageSending stamp: 'HAW 8/30/2020 19:19:51'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:52'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:52'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:52'!
m1 randomInstVar isNil ifTrue: [1 + 1] ifFalse: [ 2 + 2 ]! !

!testRun: #IfNilChecksFinderTest #test09ResultIncludesIsNilIfTrueIfFalseMessageSending stamp: 'HAW 8/30/2020 19:19:52'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:52'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:52'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:52'!
m1 randomInstVar isNil ifFalse: [1 + 1] ifTrue: [ 2 + 2 ]! !

!testRun: #IfNilChecksFinderTest #test10ResultIncludesIsNilIfFalseIfTrueMessageSending stamp: 'HAW 8/30/2020 19:19:52'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:53'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:53'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:53'!
m1 randomInstVar ifNil: [1 + 1].randomInstVar ifNotNil: [1 + 1].! !

!testRun: #IfNilChecksFinderTest #test11WhenThereAreMultipleIfNilChecksInTheSameMethodTheResultIncludesAllOfThem stamp: 'HAW 8/30/2020 19:19:53'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:54'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:54'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:54'!
m1 randomInstVar ifNil: [1 + 1]! !
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:54'!
m2 randomInstVar ifNil: [2 + 2]! !

!testRun: #IfNilChecksFinderTest #test12WhenThereAreIfNilChecksInMultipleMethodsTheResultIncludesAllOfThem stamp: 'HAW 8/30/2020 19:19:54'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:54'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ContextClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:54'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ContextClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:54'!
m1 randomInstVar ifNil: [1 + 1].randomInstVar ifNil: [1 + 1].! !

!testRun: #IfNilChecksFinderTest #test13WhenThereAreMultipleIfNilChecksInTheSameMethodWithTheSameCodeTheResultIncludesAllOfThem stamp: 'HAW 8/30/2020 19:19:54'!
PASSED!

!classRemoval: #ContextClass stamp: 'HAW 8/30/2020 19:19:55'!
RefactoringClassTestData subclass: #ContextClass
	instanceVariableNames: 'randomInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:55'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:55'!
m1 anInstVar ifNil: [ super isNil ]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:55'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:55'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test01BlocksToExtractMustNotContainReferencesToSuper stamp: 'HAW 8/30/2020 19:19:55'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:19:56'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:19:56'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:19:56'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:56'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:56'!
m1 anInstVar ifNil: [ anInstVar := 1 ]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:56'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:56'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test02BlocksToExtractMustNotContainAssignmentsToVariablesThatAreNotTemporals stamp: 'HAW 8/30/2020 19:19:56'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:19:57'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:19:57'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:19:57'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:57'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:57'!
m1 anInstVar ifNil: [
			1 = 2 ifFalse: [ |aTemp| aTemp := 3]]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:57'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:57'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test03BlocksToExtractCanAssignToTemporalsOfNestedBlocks stamp: 'HAW 8/30/2020 19:19:57'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:19:58'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:19:58'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:19:59'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:59'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:19:59'!
m1 anInstVar ifNil: [ |aTemp| aTemp := 2]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:59'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:19:59'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test04BlocksToExtractCanAssignToTemporalsOfBlocks stamp: 'HAW 8/30/2020 19:19:59'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:19:59'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:20:00'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:00'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:00'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:00'!
m1 anInstVar ifNil: [^anInstVar is Nil]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:00'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:00'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test07BlocksToExtractMustNotContainReturnStatements stamp: 'HAW 8/30/2020 19:20:00'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:20:01'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:20:01'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:01'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactorSuperclass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:01'!
RefactoringClassTestData subclass: #AClassToRefactorSuperclass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:01'!
AClassToRefactorSuperclass subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:01'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:01'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:01'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test08InstanceVariableMustBelongToTheClassToRefactor stamp: 'HAW 8/30/2020 19:20:01'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:20:02'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:20:02'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:02'!
AClassToRefactorSuperclass subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactorSuperclass stamp: 'HAW 8/30/2020 19:20:03'!
RefactoringClassTestData subclass: #AClassToRefactorSuperclass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:03'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:03'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:03'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test09ConcreteClassMustBeDifferentToNullClass stamp: 'HAW 8/30/2020 19:20:03'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:03'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:03'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:03'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClasOutsideTheHierarchy category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:04'!
RefactoringClassTestData subclass: #AClasOutsideTheHierarchy
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClasOutsideTheHierarchy methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:04'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:04'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:04'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test10MethodsMustBelongToTheHierarchyToRefactor stamp: 'HAW 8/30/2020 19:20:04'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:04'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:04'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:05'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClasOutsideTheHierarchy stamp: 'HAW 8/30/2020 19:20:05'!
RefactoringClassTestData subclass: #AClasOutsideTheHierarchy
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:05'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:05'!
m1 anInstVar ifNil: [anInstVar isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:05'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:05'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test13MessageNodesMustNotBeDuplicated stamp: 'HAW 8/30/2020 19:20:05'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:06'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:06'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:06'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:06'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:06'!
m1 self ifNil: [anInstVar isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:06'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:06'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test14MessageNodesReceiverMustBeTheInstVar stamp: 'HAW 8/30/2020 19:20:06'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:07'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:07'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:07'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:07'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:07'!
m1 anInstVar ifNil: [ 1 + 1 ]! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:07'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:07'!
unaryPolymorphicSelector! !

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:07'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test15ConcreteClassMustNotContainAnyPolymorphicSelector stamp: 'HAW 8/30/2020 19:20:07'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:20:08'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:20:08'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:09'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:09'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:09'!
m1 anInstVar ifNil: [ 1 + 1 ]! !

!classDefinition: #NullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:09'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!NullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:09'!
unaryPolymorphicSelector! !

!classDefinition: #ConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:09'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #IntroduceNullObjectTest #test16NullClassMustNotContainAnyPolymorphicSelector stamp: 'HAW 8/30/2020 19:20:09'!
PASSED!

!classRemoval: #NullClass stamp: 'HAW 8/30/2020 19:20:09'!
RefactoringClassTestData subclass: #NullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ConcreteClass stamp: 'HAW 8/30/2020 19:20:10'!
RefactoringClassTestData subclass: #ConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:10'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:10'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10'!
m1 anInstVar ifNil: [ 1 + 1 ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:10'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:10'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10'!
replaceIfNilSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10'!
replaceIfNilSelector
	1 + 1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10' prior: 50856619!
m1 anInstVar replaceIfNilSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10' prior: 50856649!
m1 anInstVar replaceIfNilSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10' prior: 50856654!
m1 anInstVar replaceIfNilSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:10'!
getReference! !

!testRun: #IntroduceNullObjectTest #test17WhenThereAreNoVariablesToParametrizeReplacesIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:10'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:10'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:11'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:11'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:11'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11'!
m1 anInstVar ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:11'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:11'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11' prior: 50856711!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11' prior: 50856739!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11' prior: 50856743!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:11'!
getReference! !

!testRun: #IntroduceNullObjectTest #test18WhenThereAreVariablesToParametrizeReplacesIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:11'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:12'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:12'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:12'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:12'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12'!
m1 anInstVar ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:12'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:12'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12' prior: 50856800!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12' prior: 50856828!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12' prior: 50856832!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:12'!
getReference! !

!testRun: #IntroduceNullObjectTest #test19WhenIfNilCheckHasOneKeywordReplacesIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:12'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:13'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:13'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:13'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:13'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:13'!
m1 anInstVar ifNil: [ self isNil ] ifNotNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:13'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:14'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14' prior: 50856889!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14' prior: 50856919!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14' prior: 50856923!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:14'!
getReference! !

!testRun: #IntroduceNullObjectTest #test20WhenIfNilCheckHasTwoKeywordsReplacesIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:14'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:14'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:14'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:15'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:15'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:15'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:15'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15' prior: 50856980!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15' prior: 50857010!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15' prior: 50857014!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:15'!
getReference! !

!testRun: #IntroduceNullObjectTest #test21WhenIfNilCheckHasIsNilReplacesIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:15'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:15'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:16'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:16'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:16'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16' prior: 50857071!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16' prior: 50857101!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16' prior: 50857105!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:16'!
getReference! !

!testRun: #IntroduceNullObjectTest #test22PolymorphicMessageIsAddedToTheConcreteClass stamp: 'HAW 8/30/2020 19:20:16'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:17'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:17'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:17'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:17'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:17'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:17'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17' prior: 50857161!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17' prior: 50857191!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17' prior: 50857195!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:17'!
getReference! !

!testRun: #IntroduceNullObjectTest #test23PolymorphicMessageIsAddedToTheConcreteClassWithChosenParameterNames stamp: 'HAW 8/30/2020 19:20:17'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:18'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:18'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:18'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:19'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:19'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19' prior: 50857252!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19' prior: 50857282!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19' prior: 50857286!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:19'!
getReference! !

!testRun: #IntroduceNullObjectTest #test24PolymorphicMessageIsAddedToTheConcreteClassReplacingParametrizedVariables stamp: 'HAW 8/30/2020 19:20:19'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:19'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:19'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:20'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:20'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20'!
m1 anInstVar ifNil: [ self isNil ] ifNotNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:20'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:20'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20' prior: 50857343!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20' prior: 50857373!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20' prior: 50857377!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:20'!
getReference! !

!testRun: #IntroduceNullObjectTest #test25ReplacesIfNilIfNotNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:20'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:20'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:21'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:21'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:21'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21'!
m1 anInstVar ifNotNil: [ self isNil ] ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:21'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:21'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21' prior: 50857433!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21' prior: 50857463!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21' prior: 50857467!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:21'!
getReference! !

!testRun: #IntroduceNullObjectTest #test26ReplacesIfNotNilIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:21'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:22'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:22'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:22'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:22'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22'!
m1 anInstVar ifNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:22'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:22'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22' prior: 50857523!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22' prior: 50857551!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22' prior: 50857555!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:22'!
getReference! !

!testRun: #IntroduceNullObjectTest #test27ReplacesIfNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:22'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:23'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:23'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:24'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:24'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24'!
m1 anInstVar ifNotNil: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:24'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:24'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24'!
with: p1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24' prior: 50857611!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24' prior: 50857640!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24' prior: 50857644!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:24'!
getReference! !

!testRun: #IntroduceNullObjectTest #test28ReplacesIfNotNilWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:24'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:24'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:25'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25'!
m1 anInstVar isNil ifTrue: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:25'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:25'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25' prior: 50857700!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25' prior: 50857728!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25' prior: 50857732!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:25'!
getReference! !

!testRun: #IntroduceNullObjectTest #test29ReplacesIsNilIfTrueWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:25'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:26'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:26'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:26'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:26'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26'!
m1 anInstVar isNil ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:26'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:26'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26'!
with: p1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26' prior: 50857788!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26' prior: 50857817!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26' prior: 50857821!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:26'!
getReference! !

!testRun: #IntroduceNullObjectTest #test30ReplacesIsNilIfFalseWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:26'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:27'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:27'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:28'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:28'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28'!
m1 anInstVar isNil ifTrue: [self isNil] ifFalse: [self isNil]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:28'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:28'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28' prior: 50857877!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28' prior: 50857907!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28' prior: 50857911!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:28'!
getReference! !

!testRun: #IntroduceNullObjectTest #test31ReplacesIsNilIfTrueIfFalseWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:28'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:28'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:29'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:29'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:29'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29'!
m1 anInstVar isNil ifFalse: [self isNil] ifTrue: [self isNil]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:29'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:29'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29' prior: 50857967!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29' prior: 50857997!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29' prior: 50858001!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:29'!
getReference! !

!testRun: #IntroduceNullObjectTest #test32ReplacesIsNilIfFalseIfTrueWithPolymorphicMessageSend stamp: 'HAW 8/30/2020 19:20:29'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:30'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:30'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:30'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:30'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:30'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:30'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30' prior: 50858057!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30' prior: 50858087!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30' prior: 50858091!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:30'!
getReference! !

!testRun: #IntroduceNullObjectTest #test33PolymorphicMessageIsAddedToTheNullClass stamp: 'HAW 8/30/2020 19:20:30'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:31'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:31'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:31'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:31'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:31'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:31'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31' prior: 50858147!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31' prior: 50858177!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31' prior: 50858181!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:31'!
getReference! !

!testRun: #IntroduceNullObjectTest #test34PolymorphicMessageIsAddedToTheNullClassWithChosenParameterNames stamp: 'HAW 8/30/2020 19:20:31'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:32'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:32'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33'!
m1 anInstVar isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:33'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:33'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33' prior: 50858238!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33' prior: 50858268!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33' prior: 50858272!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:33'!
getReference! !

!testRun: #IntroduceNullObjectTest #test35PolymorphicMessageIsAddedToTheNullClassReplacingParametrizedVariables stamp: 'HAW 8/30/2020 19:20:33'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:33'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:34'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:34'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:34'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34'!
m1 anInstVar isNil ifFalse: [self isNil]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:34'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:34'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34'!
with: p1
	p1 isNil! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34'!
with: p1! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34' prior: 50858329!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34' prior: 50858358!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34' prior: 50858362!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:34'!
getReference! !

!testRun: #IntroduceNullObjectTest #test36WhenNoNullBlockIsPresentEmptyPolymorphicMessageIsAddedToTheNullClass stamp: 'HAW 8/30/2020 19:20:34'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:35'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:35'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35'!
m1 anInstVar isNil ifTrue: [self isNil]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:35'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:35'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35'!
with: p1! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35'!
with: p1
	p1 isNil! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35' prior: 50858419!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35' prior: 50858447!
m1 anInstVar with: self! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35' prior: 50858451!
m1 anInstVar with: self! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:35'!
getReference! !

!testRun: #IntroduceNullObjectTest #test37WhenNoConcreteBlockIsPresentEmptyPolymorphicMessageIsAddedToTheConcreteClass stamp: 'HAW 8/30/2020 19:20:35'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:36'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:36'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:36'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:36'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36'!
m1 anInstVar ifNil: [1+1. 2+2]! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:36'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:36'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36' prior: 50858508!
m1 anInstVar unaryPolymorphicSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36' prior: 50858538!
m1 anInstVar unaryPolymorphicSelector! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36' prior: 50858543!
m1 anInstVar unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:36'!
getReference! !

!testRun: #IntroduceNullObjectTest #test38WhenThereAreMultipleStatementsPolymorphicMessageIsAddedToTheNullClass stamp: 'HAW 8/30/2020 19:20:36'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:37'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:37'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:38'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:38'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38'!
m1
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := nil.! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:38'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:38'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38' prior: 50858600!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := nil.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38' prior: 50858630!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := ANullClass new.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38' prior: 50858636!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := ANullClass new.! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:38'!
getReference! !

!testRun: #IntroduceNullObjectTest #test39ReplacesNilAssignmentsWithNullObject stamp: 'HAW 8/30/2020 19:20:38'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:38'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:39'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:39'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:39'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39'!
m1
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := nil.
	anInstVar := nil.! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:39'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:39'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39' prior: 50858694!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := nil.
	anInstVar := nil.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39' prior: 50858725!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := ANullClass new.
	anInstVar := ANullClass new.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39' prior: 50858731!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := ANullClass new.
	anInstVar := ANullClass new.! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:39'!
getReference! !

!testRun: #IntroduceNullObjectTest #test40ReplacesMultipleNilAssignmentsWithNullObject stamp: 'HAW 8/30/2020 19:20:39'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:40'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:40'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:40'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:40'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40'!
m1
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := self doSomething.! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:40'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:40'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40' prior: 50858791!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := self doSomething.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40' prior: 50858822!
m1
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40' prior: 50858828!
m1
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:40'!
getReference! !

!testRun: #IntroduceNullObjectTest #test41ReplacesAssignmentWithNullObject stamp: 'HAW 8/30/2020 19:20:40'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:41'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:41'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:41'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:41'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:41'!
m1
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := self doSomething.
	anInstVar := self doSomething +  ivar different.! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:41'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:41'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:41'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:41'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:41' prior: 50858888!
m1
	anInstVar unaryPolymorphicSelector.
	anInstVar := self doSomething.
	anInstVar := self doSomething +  ivar different.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:41' prior: 50858920!
m1
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).
	self assignOptionalField: (self doSomething + ivar different).! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:42'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:42' prior: 50858928!
m1
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).
	self assignOptionalField: (self doSomething + ivar different).! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:42'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:42'!
getReference! !

!testRun: #IntroduceNullObjectTest #test42ReplacesMultipleAssignmentsInTheSameMethodWithNullObject stamp: 'HAW 8/30/2020 19:20:42'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:42'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:42'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:43'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:43'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
m11
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := self doSomething.
	anInstVar := self doSomething +  ivar different.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
m12
	anInstVar ifNil: [1+1. 2+2].
	anInstVar := self doSomething.
	anInstVar := self doSomething +  ivar different.! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:43'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:43'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50858992!
m11
	anInstVar unaryPolymorphicSelector.
	anInstVar := self doSomething.
	anInstVar := self doSomething +  ivar different.! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50859022!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50859026!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50858999!
m12
	anInstVar unaryPolymorphicSelector.
	anInstVar := self doSomething.
	anInstVar := self doSomething +  ivar different.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50859031!
m11
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).
	self assignOptionalField: (self doSomething + ivar different).! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50859048!
m12
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).
	self assignOptionalField: (self doSomething + ivar different).! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50859056!
m11
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).
	self assignOptionalField: (self doSomething + ivar different).! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43' prior: 50859064!
m12
	anInstVar unaryPolymorphicSelector.
	self assignOptionalField: (self doSomething).
	self assignOptionalField: (self doSomething + ivar different).! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:43'!
getReference! !

!testRun: #IntroduceNullObjectTest #test43ReplacesMultipleAssignmentsInMultipleMethodsWithNullObject stamp: 'HAW 8/30/2020 19:20:43'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:44'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:44'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:44'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:44'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44'!
m1
	anInstVar ifNil: [1+1. 2+2].
	^anInstVar! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:44'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:44'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44' prior: 50859136!
m1
	anInstVar unaryPolymorphicSelector.
	^anInstVar! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44' prior: 50859166!
m1
	anInstVar unaryPolymorphicSelector.
	^anInstVar! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44' prior: 50859171!
m1
	anInstVar unaryPolymorphicSelector.
	^anInstVar getReference! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:44'!
getReference! !

!testRun: #IntroduceNullObjectTest #test44ReplacesReturnOfIvarWithGetReference stamp: 'HAW 8/30/2020 19:20:44'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:45'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:45'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:45'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:45'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45'!
m1
	anInstVar ifNil: [1+1. 2+2].
	self do: anInstVar.! !

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:45'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:45'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45'!
unaryPolymorphicSelector! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45'!
unaryPolymorphicSelector
	1+1. 2+2! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45' prior: 50859229!
m1
	anInstVar unaryPolymorphicSelector.
	self do: anInstVar.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45' prior: 50859259!
m1
	anInstVar unaryPolymorphicSelector.
	self do: anInstVar.! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45'!
assignOptionalField: maybeNil

	anInstVar := maybeNil ifNil: [ ANullClass new ].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45' prior: 50859265!
m1
	anInstVar unaryPolymorphicSelector.
	self do: anInstVar getReference.! !
!ANullClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45'!
getReference
	^nil! !
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:45'!
getReference! !

!testRun: #IntroduceNullObjectTest #test45ReplacesIvarAsParamWithGetReference stamp: 'HAW 8/30/2020 19:20:45'!
PASSED!

!classRemoval: #ANullClass stamp: 'HAW 8/30/2020 19:20:46'!
RefactoringClassTestData subclass: #ANullClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:46'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:20:47'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:47'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:47'!
m1 self ifNil: [1 + 1]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test01WhenThereAreNoVariablesToExtractFindsNothing stamp: 'HAW 8/30/2020 19:20:47'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:47'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:47'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:47'!
m1 self ifNil: [| a | a := 2. a + 1]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test02WhenThereAreOnlyTemporariesFindsNothing stamp: 'HAW 8/30/2020 19:20:47'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:48'!
m1 self ifNil: [| a | a := 2. a + self]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test03WhenABlockReferencesNonTemporariesTheyAreFound stamp: 'HAW 8/30/2020 19:20:48'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:49'!
m1 self ifNil: [| a | a := 2. a ifNil: [ self + 2]]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test04WhenANestedBlockReferencesNonTemporariesTheyAreFound stamp: 'HAW 8/30/2020 19:20:49'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:49'!
m1 self ifNil: [| a | a := nil]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test05NilIsNotFound stamp: 'HAW 8/30/2020 19:20:49'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:50'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:50'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:50'!
m1 self ifNil: [false or: [true]]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test06TrueAndFalseAreNotFound stamp: 'HAW 8/30/2020 19:20:50'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:50'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:51'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:20:51'!
m1 self ifNil: [| a | a := 2. a + anInstVar]! !

!testRun: #MessageSendingBlocksVariablesToExtractFinderTest #test07WhenABlockReferencesInstanceVariablesTheyAreFound stamp: 'HAW 8/30/2020 19:20:51'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:20:51'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:51'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test01AbstractClassClassNameMustNotBeEmpty stamp: 'HAW 8/30/2020 19:20:51'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:52'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:52'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test02AbstractClassClassNameMustBeASymbol stamp: 'HAW 8/30/2020 19:20:52'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:53'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:53'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test03AbstractClassClassNameMustStartWithUppercaseLetter stamp: 'HAW 8/30/2020 19:20:53'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:53'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:53'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test04AbstractClassClassNameMustNotHaveSeparators stamp: 'HAW 8/30/2020 19:20:53'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:54'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:54'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test05AbstractClassClassNameMustNotExist stamp: 'HAW 8/30/2020 19:20:54'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:54'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:54'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test06NullObjectClassNameMustNotBeEmpty stamp: 'HAW 8/30/2020 19:20:54'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:55'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:55'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test07NullObjectClassNameMustBeASymbol stamp: 'HAW 8/30/2020 19:20:55'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:56'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:56'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test08NullObjectClassNameMustStartWithUppercaseLetter stamp: 'HAW 8/30/2020 19:20:56'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:56'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:56'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test09NullObjectClassNameMustNotHaveSeparators stamp: 'HAW 8/30/2020 19:20:56'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:57'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:57'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test10NullObjectClassNameMustNotExist stamp: 'HAW 8/30/2020 19:20:57'!
PASSED!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:58'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:58'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:58'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:58'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test11CreatesAbstractClass stamp: 'HAW 8/30/2020 19:20:58'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:20:59'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:20:59'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:20:59'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:59'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:59'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:20:59'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test12CreatesAbstractClassInChosenCategory stamp: 'HAW 8/30/2020 19:20:59'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:00'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:00'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:00'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:00'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:00'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:00'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test13CreatesAbstractClassAsSubclassOfConcreteClassPreviousSuperclass stamp: 'HAW 8/30/2020 19:21:00'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:01'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:01'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:02'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:02'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:02'!
m1! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:02'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:02'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:02'!
m1
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:02' overrides: 50859859!
m1! !

!testRun: #NullObjectHierarchyCreatorTest #test14AbstractClassDefinesAllTheSelectorsOfConcreteClass stamp: 'HAW 8/30/2020 19:21:02'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:02'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:03'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:03'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:03'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:03'!
m1: anArg! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:03'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:03'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:03'!
m1: anArg
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:03' overrides: 50859923!
m1: anArg! !

!testRun: #NullObjectHierarchyCreatorTest #test15AbstractClassMethodParametersNamesArePreservedFromConcreteClass stamp: 'HAW 8/30/2020 19:21:03'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:03'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:04'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:04'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:04'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:04'!
m1: anArg
		^1 + 2! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:04'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:04'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:04'!
m1: anArg
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:04' overrides: 50859988!
m1: anArg! !

!testRun: #NullObjectHierarchyCreatorTest #test16AbstractClassMethodsDelegateResponsibility stamp: 'HAW 8/30/2020 19:21:04'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:05'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:05'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:05'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:05'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:05'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:05'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test17CreatesNullObjectClass stamp: 'HAW 8/30/2020 19:21:05'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:06'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:06'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:06'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:06'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:06'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:06'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test18CreatesNullObjectClassInChosenCategory stamp: 'HAW 8/30/2020 19:21:06'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:07'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:07'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:08'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:08'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:08'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:08'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test19CreatesNullObjectClassClassAsSubclassOfAbstractClass stamp: 'HAW 8/30/2020 19:21:08'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:08'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:09'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:09'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:09'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:09'!
m1! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:09'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:09'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:09'!
m1
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:09' overrides: 50860208!
m1! !

!testRun: #NullObjectHierarchyCreatorTest #test20NullObjectClassDefinesAllTheSelectorsOfConcreteClass stamp: 'HAW 8/30/2020 19:21:09'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:09'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:10'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:10'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:10'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:10'!
m1: anArg! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:10'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:10'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:10'!
m1: anArg
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:10' overrides: 50860272!
m1: anArg! !

!testRun: #NullObjectHierarchyCreatorTest #test21NullObjectClassMethodParametersNamesArePreservedFromConcreteClass stamp: 'HAW 8/30/2020 19:21:10'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:11'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:11'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:11'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:11'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:11'!
m1: anArg
		^1 + 2! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:11'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:11'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:11'!
m1: anArg
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:11' overrides: 50860337!
m1: anArg! !

!testRun: #NullObjectHierarchyCreatorTest #test22NullObjectClassMethodsAreEmpty stamp: 'HAW 8/30/2020 19:21:11'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:12'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:12'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:12'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:12'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:12'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:12'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #NullObjectHierarchyCreatorTest #test23ConcreteClassSubclassesTheAbstractClass stamp: 'HAW 8/30/2020 19:21:12'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:13'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:13'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:14'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AConcreteClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:14'!
RefactoringClassTestData subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AConcreteClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:14'!
m1: anArg
		^1 + 2! !

!classDefinition: #AnAbstractClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:14'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ANullObjectClassName category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:14'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AnAbstractClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:14'!
m1: anArg
	self subclassResponsibility.! !
!ANullObjectClassName methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:14' overrides: 50860453!
m1: anArg! !

!testRun: #NullObjectHierarchyCreatorTest #test24ConcreteClassMethodsArePreserved stamp: 'HAW 8/30/2020 19:21:14'!
PASSED!

!classRemoval: #ANullObjectClassName stamp: 'HAW 8/30/2020 19:21:14'!
AnAbstractClassName subclass: #ANullObjectClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AnAbstractClassName stamp: 'HAW 8/30/2020 19:21:15'!
RefactoringClassTestData subclass: #AnAbstractClassName
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #AConcreteClass stamp: 'HAW 8/30/2020 19:21:15'!
AnObsoleteAnAbstractClassName subclass: #AConcreteClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:15'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:15'!
m1 self ifNil: [1 + 1].! !
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:15'!
m2 1 + 1.! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test01MessageNodeMustBelongToTheMethodNode stamp: 'HAW 8/30/2020 19:21:15'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:16'!
m1 anInstVar ifTrue: [1 + 1].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test02MessageNodeMustRepresentASupportedMessageSent stamp: 'HAW 8/30/2020 19:21:16'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:16'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:16'!
m1 anInstVar ifNil: [self isNil]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test03AllVariablesToParametrizeHaveACorrespondingKeyword stamp: 'HAW 8/30/2020 19:21:16'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:17'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:17'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:17'!
m1 anInstVar ifNil: [self isNil].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test04AllKeywordsMustHaveACorrespondingVariableToParametrize stamp: 'HAW 8/30/2020 19:21:17'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:18'!
m1 anInstVar ifNil: [self isNil].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test05CreatesReplaceIfNilWithPolymorphismParameters stamp: 'HAW 8/30/2020 19:21:18'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:18'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:18'!
m1 anInstVar ifNil: [self or: [true]].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test06ReplaceIfNilWithPolymorphismParametersOnBlocksWithBooleanConstants stamp: 'HAW 8/30/2020 19:21:18'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:19'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:19'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:19'!
m1 anInstVar ifNil: [ | tempVar | tempVar := 1 + 1. self isNil].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test07ParameterNamesMustNotBeEqualToABlockTemporal stamp: 'HAW 8/30/2020 19:21:19'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:20'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:20'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:20'!
m1
		anInstVar ifNil: [self ifNil: [ | tempVar | tempVar := 1 + 1]].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test08ParameterNamesMustNotBeEqualToANestedBlockTemporal stamp: 'HAW 8/30/2020 19:21:20'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:20'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:20'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:20'!
m1
		anInstVar ifNil: [self allInstVarNames collect: [:arg | arg asSymbol]].! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test09ParameterNamesMustNotBeEqualToNestedBlocksArguments stamp: 'HAW 8/30/2020 19:21:20'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:21'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:21'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:21'!
m1 anInstVar ifNil: [1 + 1] ifNotNil: [2 + 2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test10RangeOfMessageSendForIfNilIfNotNil stamp: 'HAW 8/30/2020 19:21:21'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:22'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:22'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:22'!
m1 anInstVar ifNotNil: [1 + 1] ifNil: [2 + 2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test11RangeOfMessageSendForIfNotNilIfNil stamp: 'HAW 8/30/2020 19:21:22'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:22'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:22'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:22'!
m1 anInstVar ifNotNil: [1 + 1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test12RangeOfMessageSendForIfNotNil stamp: 'HAW 8/30/2020 19:21:22'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:23'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:23'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:23'!
m1 anInstVar ifNil: [1 + 1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test13RangeOfMessageSendForIfNil stamp: 'HAW 8/30/2020 19:21:23'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:24'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:24'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:24'!
m1 anInstVar isNil ifTrue: [1 + 1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test14RangeOfMessageSendForIsNilIfTrue stamp: 'HAW 8/30/2020 19:21:24'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:24'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:24'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:24'!
m1 anInstVar isNil ifTrue: [1 + 1] ifFalse: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test15RangeOfMessageSendForIsNilIfTrueIfFalse stamp: 'HAW 8/30/2020 19:21:24'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:25'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:25'!
m1 anInstVar       ifNil: [1 + 1]          ifNotNil: [2 + 2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test16WhenThereAreExtraSpacesRangeOfMessageSendForIfNilIfNotNil stamp: 'HAW 8/30/2020 19:21:25'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:26'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:26'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:26'!
m1 anInstVar    isNil       ifTrue: [1 + 1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test17WhenThereAreExtraSpacesRangeOfMessageSendForIsNilIfTrue stamp: 'HAW 8/30/2020 19:21:26'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:27'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:27'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:27'!
m1 anInstVar ifNil: [1 + 1] ifNotNil: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test18ConcreteBlockSourceCodeForIfNilIfNotNil stamp: 'HAW 8/30/2020 19:21:27'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:27'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:27'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:27'!
m1 anInstVar ifNotNil: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test19ConcreteBlockSourceCodeForIfNotNil stamp: 'HAW 8/30/2020 19:21:27'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:28'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:28'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:28'!
m1 anInstVar ifNotNil: [2+2] ifNil: [1+1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test20ConcreteBlockSourceCodeForIfNotNilIfNil stamp: 'HAW 8/30/2020 19:21:28'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:29'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:29'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:29'!
m1 anInstVar isNil ifFalse: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test21ConcreteBlockSourceCodeForIsNilIfFalse stamp: 'HAW 8/30/2020 19:21:29'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:29'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:29'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:29'!
m1 anInstVar isNil ifTrue: [1+1] ifFalse: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test22ConcreteBlockSourceCodeForIsNilIfTrueIfFalse stamp: 'HAW 8/30/2020 19:21:29'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:30'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:30'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:30'!
m1 anInstVar ifNil: [1+1] ifNotNil: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test23NullBlockSourceCodeForIfNilIfNotNil stamp: 'HAW 8/30/2020 19:21:30'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:31'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:31'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:31'!
m1 anInstVar ifNil: [1+1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test24NullBlockSourceCodeForIfNil stamp: 'HAW 8/30/2020 19:21:31'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:31'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:31'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:31'!
m1 anInstVar ifNotNil: [2+2] ifNil: [1+1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test25NullBlockSourceCodeForIfNotNilIfNil stamp: 'HAW 8/30/2020 19:21:31'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:32'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:32'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:32'!
m1 anInstVar isNil ifTrue: [1+1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test26NullBlockSourceCodeForIsNilIfTrue stamp: 'HAW 8/30/2020 19:21:32'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:33'!
m1 anInstVar isNil ifFalse: [2+2] ifTrue: [1+1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test27NullBlockSourceCodeForIsNilIfFalseIfTrue stamp: 'HAW 8/30/2020 19:21:33'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:33'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:33'!
m1 anInstVar ifNotNil: [1+1]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test28NullBlockSourceCodeForIfNotNil stamp: 'HAW 8/30/2020 19:21:33'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:34'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:34'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:34'!
m1 anInstVar ifNil: [1] ifNotNil: [2+2. 1+1.]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test29WhenThereAreMultipleStatementsConcreteBlockSourceCodeForIfNilIfNotNil stamp: 'HAW 8/30/2020 19:21:34'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:35'!
m1 anInstVar ifNotNil: [2+2. 1+1.]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test30WhenThereAreMultipleStatementsConcreteBlockSourceCodeForIfNotNil stamp: 'HAW 8/30/2020 19:21:35'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:35'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:35'!
m1 anInstVar isNil ifFalse: [2+2. 1+1.]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test31WhenThereAreMultipleStatementsConcreteBlockSourceCodeForIsNilIfFalse stamp: 'HAW 8/30/2020 19:21:35'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:36'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:36'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:36'!
m1 anInstVar ifNil: [1+1. 2+2.] ifNotNil: [2+2]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test32WhenThereAreMultipleStatementsNullBlockSourceCodeForIfNilIfNotNil stamp: 'HAW 8/30/2020 19:21:36'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:37'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:37'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:37'!
m1 anInstVar ifNil: [1+1. 2+2.]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test33WhenThereAreMultipleStatementsNullBlockSourceCodeForIfNil stamp: 'HAW 8/30/2020 19:21:37'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:37'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClassToRefactor category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:37'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClassToRefactor methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:37'!
m1 anInstVar isNil ifTrue: [1+1. 2+2.]! !

!testRun: #ReplaceIfNilWithPolymorphismParametersTest #test34WhenThereAreMultipleStatementsNullBlockSourceCodeForIsNilIfTrue stamp: 'HAW 8/30/2020 19:21:37'!
PASSED!

!classRemoval: #AClassToRefactor stamp: 'HAW 8/30/2020 19:21:38'!
RefactoringClassTestData subclass: #AClassToRefactor
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #VariableToParametrizeKeywordDefinitionTest #test01ParameterNameMustNotBeEmpty stamp: 'HAW 8/30/2020 19:21:38'!
PASSED!

!testRun: #VariableToParametrizeKeywordDefinitionTest #test02ParameterNameMustNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:21:38'!
PASSED!

!testRun: #VariableToParametrizeKeywordDefinitionTest #test03ParameterNameMustNotContainSeparators stamp: 'HAW 8/30/2020 19:21:39'!
PASSED!

!testRun: #VariableToParametrizeKeywordDefinitionTest #test04KeywordMustNotBeEmpty stamp: 'HAW 8/30/2020 19:21:39'!
PASSED!

!testRun: #VariableToParametrizeKeywordDefinitionTest #test05KeywordMustNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:21:40'!
PASSED!

!testRun: #VariableToParametrizeKeywordDefinitionTest #test06CreatesADefinition stamp: 'HAW 8/30/2020 19:21:40'!
PASSED!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:40'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:40'!
m1! !

!testRun: #VariablesToExtractFinderTest #test01WhenTheMethodHasNoVariablesItReturnsAnEmptySet stamp: 'HAW 8/30/2020 19:21:40'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:41'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:41'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:41'!
m1
		| aTempVar |

		aTempVar := 2.

		^aTempVar.! !

!testRun: #VariablesToExtractFinderTest #test02WhenTheMethodHasOnlyTemporaryVariablesItReturnsAnEmptySet stamp: 'HAW 8/30/2020 19:21:41'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:42'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:42'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:42'!
m1

		self m2.! !

!testRun: #VariablesToExtractFinderTest #test03WhenTheMethodReferencesSelfPseudoVariableItFindsIt stamp: 'HAW 8/30/2020 19:21:42'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:42'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:42'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:42'!
m1: anArg

		^anArg + 2! !

!testRun: #VariablesToExtractFinderTest #test04WhenTheMethodHasArgumentsTheyAreIncludedAsVariablesToExtract stamp: 'HAW 8/30/2020 19:21:42'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:43'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:43'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:43'!
m1

		^anInstVar isNil! !

!testRun: #VariablesToExtractFinderTest #test05WhenTheMethodReferencesAnInstanceVariableItFindsIt stamp: 'HAW 8/30/2020 19:21:43'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:44'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:44'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: 'AClassVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:44'!
m1

		^AClassVar isNil! !

!testRun: #VariablesToExtractFinderTest #test06WhenTheMethodReferencesAClassVariableItFindsIt stamp: 'HAW 8/30/2020 19:21:44'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:45'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: 'AClassVar'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ASharedPool category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:45'!
SharedPool subclass: #ASharedPool
	instanceVariableNames: ''
	classVariableNames: 'APoolVariable'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:45'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'ASharedPool'
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:45'!
m1
		^APoolVariable isNil! !

!testRun: #VariablesToExtractFinderTest #test07WhenTheMethodReferencesAPoolVariableItFindsIt stamp: 'HAW 8/30/2020 19:21:45'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:45'!
Object subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'ASharedPool'
	category: '__Refactoring-TestData__'!

!classRemoval: #ASharedPool stamp: 'HAW 8/30/2020 19:21:46'!
SharedPool subclass: #ASharedPool
	instanceVariableNames: ''
	classVariableNames: 'APoolVariable'
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:46'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:46'!
m1

		^true not! !

!testRun: #VariablesToExtractFinderTest #test08DoesNotFindPseudoVariablesButSelf stamp: 'HAW 8/30/2020 19:21:46'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:46'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:46'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:46'!
m1
		^anInstVar! !

!testRun: #VariablesToExtractFinderTest #test09WhenReturnsAnInstVarFindsIt stamp: 'HAW 8/30/2020 19:21:46'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:47'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: 'anInstVar'
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:47'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:47'!
m1
		^Object! !

!testRun: #VariablesToExtractFinderTest #test10DoesNotFindClasses stamp: 'HAW 8/30/2020 19:21:47'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #AClass category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:48'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!AClass methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:48'!
m1
		^Smalltalk! !

!testRun: #VariablesToExtractFinderTest #test11DoesNotFindGlobals stamp: 'HAW 8/30/2020 19:21:48'!
PASSED!

!classRemoval: #AClass stamp: 'HAW 8/30/2020 19:21:49'!
RefactoringClassTestData subclass: #AClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test01SelectorMustNotBeEmpty stamp: 'HAW 8/30/2020 19:21:49'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test02SelectorMustNotContainInvalidCharacters stamp: 'HAW 8/30/2020 19:21:49'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test03SelectorMustNotStartWithInvalidStartOfSelector stamp: 'HAW 8/30/2020 19:21:49'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test04CreatesVariablesToParametrizeKeywordsDefinitionsWithSelector stamp: 'HAW 8/30/2020 19:21:50'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test05FirstKeywordMustNotStartWithAnInvalidStartOfSelector stamp: 'HAW 8/30/2020 19:21:50'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test06ParameterNamesMustNotBeRepeated stamp: 'HAW 8/30/2020 19:21:51'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test07VariablesToParametrizeMustNotBeRepeated stamp: 'HAW 8/30/2020 19:21:51'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test08CreatesVariablesToParametrizeKeywordsDefinitionsWithDefinitions stamp: 'HAW 8/30/2020 19:21:52'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test09WhenNoVariablesToParametrizeBuildsSelector stamp: 'HAW 8/30/2020 19:21:52'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test10WhenVariablesToParametrizeBuildsSelectorFromKeywordsInOrder stamp: 'HAW 8/30/2020 19:21:52'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test11WhenVariablesToParametrizeBuildsMessageSending stamp: 'HAW 8/30/2020 19:21:53'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test12WhenNoVariablesToParametrizeBuildsMessageHeader stamp: 'HAW 8/30/2020 19:21:53'!
PASSED!

!testRun: #VariablesToParametrizeKeywordsDefinitionsTest #test13WhenVariablesToParametrizeBuildsMessageHeader stamp: 'HAW 8/30/2020 19:21:54'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:54'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:54'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:54'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:54'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:54' prior: 50861716!
m3 | x | self m1: 1. false ifTrue: [ x m1 ]! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:21:54'!
m1!

!testRun: #AddParameterWithActualScopeTest #test01DoesNotChangePossibleMessageSendWhenInstructedToDoSo stamp: 'HAW 8/30/2020 19:21:54'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:21:55'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:55'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55'!
m3 | x | self m1: 1 m3: 3. false ifTrue: [ x m1: 1 m3: 3 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55'!
m1: p1 m2: p2 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55' prior: 50861757!
m3 | x | self m1: 1 m2: 2 m3: 3. false ifTrue: [ x m1: 1 m3: 3 ]! !

!methodRemoval: ClassToAddParameter #m1:m3: stamp: 'HAW 8/30/2020 19:21:55'!
m1: p1 m3: p3!

!testRun: #AddParameterWithActualScopeTest #test01_01_DoesNotChangePossibleMessageSendWhenInstructedToDoSoWithKeywordMessages stamp: 'HAW 8/30/2020 19:21:55'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:21:55'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:55'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:55'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:55'!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!testRun: #AddParameterWithActualScopeTest #test02CanNotAddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'HAW 8/30/2020 19:21:55'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:21:56'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:21:56'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:56'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:56'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:56'!
m1: p1 m3: p3! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:56'!
m1: p1 m3: p3! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:56'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1 m3: 3! !

!testRun: #AddParameterWithActualScopeTest #test02_01_CanNotAddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsForKeywordMessage stamp: 'HAW 8/30/2020 19:21:56'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:21:57'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:21:57'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:57'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:57'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:57'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:57'!
m3 | x | x := ClassOfSender new. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:57'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:57' prior: 50861905!
m3 | x | x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:21:57'!
m1!

!testRun: #AddParameterWithActualScopeTest #test03AddParameterWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'HAW 8/30/2020 19:21:57'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:21:58'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:21:58'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:58'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:58'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:58'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:58'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:58'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:58'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:58'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:58' prior: 50861963!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:21:58'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:21:58'!
m1!

!testRun: #AddParameterWithActualScopeTest #test04AddParameterWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'HAW 8/30/2020 19:21:58'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:21:59'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:21:59'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:59'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:21:59'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:59'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:59'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:59'!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:59'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:59'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:21:59' prior: 50862027!
m3 | x y | x := self. y := ClassOfSender new. x m1: 1. y m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:21:59'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:21:59'!
m1!

!testRun: #AddParameterWithActualScopeTest #test05AddParameterInDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'HAW 8/30/2020 19:21:59'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:00'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:00'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:01'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:01'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:01'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:01'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:01'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:01'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:01'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:01' prior: 50862092!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1: 1. y m1: 1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:22:01'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:22:01'!
m1!

!testRun: #AddParameterWithActualScopeTest #test06AddParameterInDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'HAW 8/30/2020 19:22:01'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:01'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:01'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:02'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02' prior: 50862146!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1 ]! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:22:02'!
m1!

!testRun: #AddParameterWithActualScopeTest #test07AddParameterToPossibleMessageSendIfInstructedToDoSo stamp: 'HAW 8/30/2020 19:22:02'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:02'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:02'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:02'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:02' prior: 50862194!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:22:02'!
m1!

!testRun: #AddParameterWithActualScopeTest #test08AddParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'HAW 8/30/2020 19:22:02'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:03'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:03'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:03'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:03'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:03'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:03'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:03'!
m3 self m1. ClassOfSender new m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:03'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:03' prior: 50862254!
m3 self m1: 1. ClassOfSender new m1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:22:03'!
m1!

!testRun: #AddParameterWithActualScopeTest #test09AddParameterOnlyToValidMessageSendWhenMoreSendsInSameMethod stamp: 'HAW 8/30/2020 19:22:03'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:04'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:04'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:04'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:04'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:04'!
m3 |x| self m1. x m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:04'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:04' prior: 50862300!
m3 |x| self m1: 1. x m1! !

!methodRemoval: ClassToAddParameter #m1 stamp: 'HAW 8/30/2020 19:22:04'!
m1!

!testRun: #AddParameterWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenAddingParameterToMethodWithSureAndPossibleSenders stamp: 'HAW 8/30/2020 19:22:04'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:05'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:05'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:05'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:05'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:05'!
m1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:05'!
m3 | x | x := self. x := ClassOfSender new. x m1; printString! !

!testRun: #AddParameterWithActualScopeTest #test11CanNotAddParameterWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'HAW 8/30/2020 19:22:05'!
PASSED!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:05'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:06'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #AddParameterWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'HAW 8/30/2020 19:22:06'!
PASSED!

!classDefinition: #ClassToAddParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:06'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:06'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:06'!
m1: p1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:06'!
m3 self m1: 1! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:06'!
m1: p1 m2: p2 ! !
!ClassToAddParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:06' prior: 50862400!
m3 self m1: 1 m2: 2! !

!methodRemoval: ClassToAddParameter #m1: stamp: 'HAW 8/30/2020 19:22:06'!
m1: p1!

!testRun: #AddParameterWithActualScopeTest #test13AddLastParameterCorrectly stamp: 'HAW 8/30/2020 19:22:06'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:07'!
ClassToAddParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToAddParameter stamp: 'HAW 8/30/2020 19:22:07'!
RefactoringClassTestData subclass: #ClassToAddParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:07'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:07'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:07'!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1 ]! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:07'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:07' prior: 50862446!
m3 | x | self m1. false ifTrue: [ x m1: 1 ]! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:07'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test01DoesNotChangePossibleMessageSendWhenInstructedToDoSo stamp: 'HAW 8/30/2020 19:22:07'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:08'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:08'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:08'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:08'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:08'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !

!testRun: #RemoveParameterWithActualScopeTest #test02CanNotRemoveParameterWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'HAW 8/30/2020 19:22:08'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:09'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:09'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:09'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:09'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:09'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:09'!
m3 | x | x := ClassOfSender new. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:09'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:09' prior: 50862545!
m3 | x | x := ClassOfSender new. x m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:09'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test03RemovesParameterWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'HAW 8/30/2020 19:22:09'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:10'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:10'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:10'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:10'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:10'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:10'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:10'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:10'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:10'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:10' prior: 50862605!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:10'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'HAW 8/30/2020 19:22:10'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test04RemovesParameterWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'HAW 8/30/2020 19:22:10'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:11'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:11'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:11'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:11'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:11'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:11'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:11'!
m3 | x y | x := self. y := ClassOfSender new. x m1: 1. y m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:11'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:11'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:11' prior: 50862671!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:11'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'HAW 8/30/2020 19:22:11'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test05RemovesParameterInDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'HAW 8/30/2020 19:22:11'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:12'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:12'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:12'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:12'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:12'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:12'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:12'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1: 1. y m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:12'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:12'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:12' prior: 50862738!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:12'!
m1: p1!

!methodRemoval: ClassOfSender #m1: stamp: 'HAW 8/30/2020 19:22:12'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test06RemovesParameterInDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'HAW 8/30/2020 19:22:12'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:13'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:13'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:13'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:13'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:13'!
m3 | x | self m1: 1. false ifTrue: [ x m1: 1]! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:13'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:13' prior: 50862795!
m3 | x | self m1. false ifTrue: [ x m1]! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:13'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test07RemovesParameterToPossibleMessageSendIfInstructedToDoSo stamp: 'HAW 8/30/2020 19:22:13'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:13'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:14'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:14'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:14'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:14'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:14'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:14' prior: 50862845!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!methodRemoval: ClassOfSender #m1: stamp: 'HAW 8/30/2020 19:22:14'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test08RemovesParameterWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'HAW 8/30/2020 19:22:14'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:14'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:14'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:15'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:15'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:15'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:15'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:15'!
m3 self m1: 1. ClassOfSender new m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:15'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:15' prior: 50862907!
m3 self m1. ClassOfSender new m1: 1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:15'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test09RemovesParameterOnlyToValidMessageSendWhenMoreSendsInSameMethod stamp: 'HAW 8/30/2020 19:22:15'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:15'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:16'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:16'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16'!
m3 |x| self m1: 1. x m1: 1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16'!
m1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16' prior: 50862956!
m3 |x| self m1. x m1: 1! !

!methodRemoval: ClassToRemoveParameter #m1: stamp: 'HAW 8/30/2020 19:22:16'!
m1: p1!

!testRun: #RemoveParameterWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenRemovingParameterToMethodWithSureAndPossibleSenders stamp: 'HAW 8/30/2020 19:22:16'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:16'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:16'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:16'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16'!
m1: p1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16'!
m1: p1! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:16'!
m3 | x | x := self. x := ClassOfSender new. x m1: 1; printString! !

!testRun: #RemoveParameterWithActualScopeTest #test11CanNotRemoveParameterWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'HAW 8/30/2020 19:22:16'!
PASSED!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:17'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:17'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RemoveParameterWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'HAW 8/30/2020 19:22:17'!
PASSED!

!classDefinition: #ClassToRemoveParameter category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:18'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:18'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:18'!
m1: p1 m2: p2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:18'!
m3 self m1: 1 m2: 2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:18'!
m2: p2! !
!ClassToRemoveParameter methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:18' prior: 50863059!
m3 self m2: 2! !

!methodRemoval: ClassToRemoveParameter #m1:m2: stamp: 'HAW 8/30/2020 19:22:18'!
m1: p1 m2: p2!

!testRun: #RemoveParameterWithActualScopeTest #test13RemovesOtherThanLastParameterCorrectly stamp: 'HAW 8/30/2020 19:22:18'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:18'!
ClassToRemoveParameter subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRemoveParameter stamp: 'HAW 8/30/2020 19:22:19'!
RefactoringClassTestData subclass: #ClassToRemoveParameter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:19'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19' prior: 50863104!
m3 | x | self m2. false ifTrue: [ x m1 ]! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:19'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test01DoesNotRenamesPossibleMessageSendWhenInstructedToDoSo stamp: 'HAW 8/30/2020 19:22:19'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:19'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:19'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:19'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:19'!
m3 | x | x := self. x := ClassOfSender new. x m1! !

!testRun: #RenameSelectorWithActualScopeTest #test02CanNotRenameWithReceiverTypeOfMessageSendNotIncludedInImplementors stamp: 'HAW 8/30/2020 19:22:19'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:20'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:20'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:20'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:20'!
ClassToRenameSelector subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:20'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:20'!
m3 | x | x := ClassOfSender new. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:20'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:20' prior: 50863201!
m3 | x | x := ClassOfSender new. x m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:20'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test03RenamesWhenReceiverTypeOfMessageSendIsSubtypeOfImplementorsType stamp: 'HAW 8/30/2020 19:22:20'!
PASSED!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:21'!
ClassToRenameSelector subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:21'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:21'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:21'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:21'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:21'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:21'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:21'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:21'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:21' prior: 50863260!
m3 | x | x := self. x := ClassOfSender new. x m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:21'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:22:21'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test04RenamesWhenReceiverTypeOfMessageSendIsEqualToImplementorsTypes stamp: 'HAW 8/30/2020 19:22:21'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:22'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:22'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:22'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:22'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:22'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:22'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:22'!
m3 | x y | x := self. y := ClassOfSender new. x m1. y m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:22'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:22'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:22' prior: 50863324!
m3 | x y | x := self. y := ClassOfSender new. x m2. y m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:22'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:22:22'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test05RenamesDifferentMessageSendsWithReceiverTypeIsIncludedInImplementorsType stamp: 'HAW 8/30/2020 19:22:22'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:23'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:23'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:23'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:23'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:23'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:23'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:23'!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m1. y m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:23'!
m2! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:23'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:23' prior: 50863389!
m3 | x y | x := y:= self. x := y := ClassOfSender new. x m2. y m2! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:23'!
m1!

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:22:23'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test06RenamesDifferentMessageSendsWithReceiverTypeEqualToImplementorsType stamp: 'HAW 8/30/2020 19:22:23'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:24'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:24'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:24'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:24'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:24'!
m3 | x | self m1. false ifTrue: [ x m1 ]! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:24'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:24' prior: 50863443!
m3 | x | self m2. false ifTrue: [ x m2 ]! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:24'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test07RenamePossibleMessageSendIfInstructedToDoSo stamp: 'HAW 8/30/2020 19:22:24'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:25'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:25'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:25'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:25'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:25'!
m3 | x | x := self. x := ClassOfSender new. x m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:25'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:25' prior: 50863491!
m3 | x | x := self. x := ClassOfSender new. x m2! !

!methodRemoval: ClassOfSender #m1 stamp: 'HAW 8/30/2020 19:22:25'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test08RenamesWithReceiverTypeOfMessageSendNotIncludedInImplementorsButSelectorNotImplementedInTypeHierarchy stamp: 'HAW 8/30/2020 19:22:25'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:26'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:26'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:26'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:26'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:26'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:26'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:26'!
m3 self m1. ClassOfSender new m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:26'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:26' prior: 50863551!
m3 self m2. ClassOfSender new m1! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:26'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test09RenamesOnlyValidMessageSendWhenMoreSendsInSameMethod stamp: 'HAW 8/30/2020 19:22:26'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:27'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:27'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:27'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:27'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:27'!
m3 |x| self m1. x m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:27'!
m2! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:27' prior: 50863597!
m3 |x| self m2. x m1! !

!methodRemoval: ClassToRenameSelector #m1 stamp: 'HAW 8/30/2020 19:22:27'!
m1!

!testRun: #RenameSelectorWithActualScopeTest #test10UsesTheModifiedSourceCodeWhenRenamingAMethodWithSureAndPossibleSenders stamp: 'HAW 8/30/2020 19:22:27'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:28'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassToRenameSelector category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:28'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classDefinition: #ClassOfSender category: #'__Refactoring-TestData__' stamp: 'HAW 8/30/2020 19:22:28'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:28'!
m1! !
!ClassOfSender methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:28'!
m1! !
!ClassToRenameSelector methodsFor: 'as yet unclassified' stamp: 'HAW 8/30/2020 19:22:28'!
m3 | x | x := self. x := ClassOfSender new. x m1; printString! !

!testRun: #RenameSelectorWithActualScopeTest #test11CanNotRenameWithReceiverTypeOfCascadeMessageSendNotIncludedInImplementors stamp: 'HAW 8/30/2020 19:22:28'!
PASSED!

!classRemoval: #ClassToRenameSelector stamp: 'HAW 8/30/2020 19:22:29'!
RefactoringClassTestData subclass: #ClassToRenameSelector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!classRemoval: #ClassOfSender stamp: 'HAW 8/30/2020 19:22:29'!
RefactoringClassTestData subclass: #ClassOfSender
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: '__Refactoring-TestData__'!

!testRun: #RenameSelectorWithActualScopeTest #test12SuperclassInstanceCreationMessagesShouldNotBeUsed stamp: 'HAW 8/30/2020 19:22:29'!
PASSED!

----QUIT----(30 August 2020 19:22:29) CuisUniversity-4365.image priorSource: 15901735!

----STARTUP---- (31 August 2020 17:05:02) as C:\Users\ebonansea\Downloads\windows64\windows64\CuisUniversity-4365.image!


ObjectBuilder create: #Pepe!

ObjectBuilder create: #Pepe
	collaboratorNames: ''
	in: 'DenotativeObject-TestSupport'
	!

Pepe
	collaboratorNames: ''
	in: 'Actividad 1'!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'Enzo Bonansea 8/31/2020 20:57:32'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'Enzo Bonansea 8/31/2020 20:57:32'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59'!
hola
	"pepe responder chau"
	^'Chau'.! !

Pepe hola!

Pepe hola!

 'Chau' !

ObjectBuilder create: #Bill
	collaboratorNames: ''
	in: 'Actividad 2'
	!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:21:52'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:21:52'!
Bill class
	instanceVariableNames: ''!

Bill
	collaboratorNames: ''
	in: 'Actividad 2'	!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:26:20'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:26:20'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:30:39'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18'!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17'!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46'!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50863748!
energia
	^diasDeVida! !

Bill
	collaboratorNames: 'diasDeVida := 28'
	in: 'Actividad 2'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:33:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'Enzo Bonansea 8/31/2020 21:33:23'!
Bill class
	instanceVariableNames: 'diasDeVida'!

Bill energia!

	diasDeVida:= 28!

Bill energia!

Bill !

Bill -> diasDeVida = 28!

Bill -> diasDeVida = 28!

Bill energia!

Bill energia!

diasDeVida := 28!

Bill energia!

diasDeVida := 28.!

diasDeVida := 28.!

Bill energia!

diasDeVida!

diasDeVida := 28!

self !

Bill self!

Bill initialize!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !

Bill initialize!

Bill energia!

Bill caminar:1!

Bill energia!

Bill comer:1!

Bill energia !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50863736!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

Bill energia!

Bill initialize!

Bill energia!

Bill comer:1!

Bill energia!

Bill energia!

!methodRemoval: Bill class #initialize stamp: 'Enzo Bonansea 8/31/2020 22:04:50'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'Enzo Bonansea 8/31/2020 22:05:06'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

----STARTUP---- (7 September 2020 16:12:21) as C:\Users\ebonansea\Downloads\windows64\windows64\CuisUniversity-4365.image!


!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'EB 9/7/2020 16:12:36'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'EB 9/7/2020 16:12:36'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'EB 9/7/2020 16:12:36'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59'!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:36'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18'!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17'!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46'!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50863916!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:37'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:37'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:37'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/7/2020 16:12:37'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50863904!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'EB 9/7/2020 16:12:37'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'EB 9/7/2020 16:12:37'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

ObjectBuilder create: #AlanTuring
	collaboratorNames: ''
	in: 'Ejercicio 3'
	!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'EB 9/7/2020 16:15:00'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'EB 9/7/2020 16:15:01'!
AlanTuring class
	instanceVariableNames: ''!

AlanTuring dateOfBirth.!

AlanTuring printString.!

AlanTuring dateOfBirth.!

AlanTuring dateOfBirth.!

AlanTuring dateOfBirth.!

	self shouldBeImplemented.!

	self shouldBeImplemented.!
!AlanTuring class methodsFor: 'personal info' stamp: 'EB 9/7/2020 16:25:57'!
dateOfBirth
	^June/23/1912.! !

AlanTuring dateOfBirth.!

AlanTuring dateOfBirth.!

ObjectBuilder create: #AlonsoChurch asChildOf: DenotativeObject collaboratorNames: '' in: 'Ejercicio 3'!

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'EB 9/7/2020 16:29:31'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'EB 9/7/2020 16:29:31'!
AlonsoChurch class
	instanceVariableNames: ''!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:29:41'!
dateOfBirth
	^June/14/1903! !

AlonsoChurch dateOfBirth inspect.!

'Hola'!

100 factorial.
!

'hola' size even.
!

'hola' size odd.!

'Hola' size + 'Chau 'size.
!

'hola', 'chau'.
!

'hola', 'chau' size.
!

'hola', 'chau' size.!

'hola', 'chau' size.!

('hola', 'chau') size.
!

('hola', 'chau') size.
!

'hola gente!!' copyFrom: 'hola' size + 1 to: 11.!

 6+2*5.
!

AlanTuring hola.
!

AlanTuring hola.
!

	^'No entiendo lo que me decis'!

AlanTuring hola.!
!AlanTuring class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:43:45' overrides: 50817518!
doesNotUnderstand: aMessage
	^'No entiendo lo que me decis'! !

AlanTuring hola.!

AlanTuring chau.!

----STARTUP---- (10 September 2020 15:18:11) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'EB 9/10/2020 15:18:21'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'EB 9/10/2020 15:18:21'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:21'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:21'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:21'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:21'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59'!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18'!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17'!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46'!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50864140!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50864128!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'EB 9/10/2020 15:18:22'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'EB 9/10/2020 15:18:22'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'EB 9/10/2020 15:18:22'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:22'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'EB 9/10/2020 15:18:22'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59' prior: 50864077!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:22'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:23'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18' prior: 50864177!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17' prior: 50864134!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46' prior: 50864145!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50864300!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:23'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:23'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:23'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'EB 9/10/2020 15:18:23'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50864287!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'EB 9/10/2020 15:18:23'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'EB 9/10/2020 15:18:23'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
AlanTuring class
	instanceVariableNames: ''!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
AlanTuring class
	instanceVariableNames: ''!
!AlanTuring class methodsFor: 'personal info' stamp: 'EB 9/7/2020 16:25:57'!
dateOfBirth
	^June/23/1912.! !

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
AlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'EB 9/10/2020 15:18:23'!
AlonsoChurch class
	instanceVariableNames: ''!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:29:41'!
dateOfBirth
	^June/14/1903! !
!AlanTuring class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:43:45' overrides: 50817518!
doesNotUnderstand: aMessage
	^'No entiendo lo que me decis'! !

!classRemoval: #Bill stamp: 'EB 9/10/2020 15:22:36'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classRemoval: #Pepe stamp: 'EB 9/10/2020 15:22:40'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

AlanTuring methodNamed: #dateOfBirth.!

AlonsoChurch methodNamed: #dateOfBirth.
!

AlonsoChurch methodNamed: #dateOfBirth.!

AlanTuring methodNamed: #dateOfBirth.
!

AlanTuring methodNamed: #dateOfBirth.
!

AlanTuring!

self sourceCode.
!

self linesOfCode.!

self!

DenotativeObjectBrowser linesOfCode!

DenotativeObjectBrowser sourceCode!

AlanTuring methodNamed: #dateOfBirth.
!

self valueWithReceiver: AlanTuring arguments: #().!

self valueWithReceiver: AlonsoChurch arguments: #().!

self valueWithReceiver: AlanTuring arguments: #(). !

AlanTuring methodNamed: #dateOfBirth.
!

self!

Assert submorphsToLayout !

Assert submorphs!

self setSelectionIndex: 1.!

self setSelectionIndex: 3.!

self selection: #fail.!

self selection:1.!

self list!

self getList !

self getListSize !

self!

self getListSize !

self getListSize !

self setSelectionIndex: 1.!

self setSelectionIndex: 2. true !

self setSelectionIndex: 24. true  true !

self setSelectionIndex: 24.!

self setSelectionIndex: 25. !

self methodNamed: #setSelectionIndex sourceCode!

self selection: #fail.!

self setSelectionIndex: 5!

self selection: #fail!

DenotativeObjectBrowser methodNamed: #Browse.!

self!

self!

DenotativeObject subclass: #CloneOfAlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

!classDefinition: #CloneOfAlonsoChurch category: #Actividades stamp: 'EB 9/10/2020 16:01:10'!
DenotativeObject subclass: #CloneOfAlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

CloneOfAlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: 'CloneOfAlonsoChurch class' category: #Actividades stamp: 'EB 9/10/2020 16:01:10'!
CloneOfAlonsoChurch class
	instanceVariableNames: ''!
!CloneOfAlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/10/2020 16:01:10'!
dateOfBirth
	^June/14/1903! !

(June/23/2019) = (June/23/2019).!

(June/23/2019) == (June/23/2019).!

!methodRemoval: AlonsoChurch class #dateOfBirth stamp: 'EB 9/10/2020 16:04:59'!
dateOfBirth
	^June/14/1903!

	^June/14/1903!

	^June/14/1903!

!classRemoval: #AlonsoChurch stamp: 'EB 9/10/2020 16:10:08'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

!classDefinition: #AlonsoChurch category: #Actividades stamp: 'EB 9/10/2020 16:10:15'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

AlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: 'AlonsoChurch class' category: #Actividades stamp: 'EB 9/10/2020 16:10:15'!
AlonsoChurch class
	instanceVariableNames: ''!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/10/2020 16:10:15'!
dateOfBirth
	^June/14/1903! !

!classDefinition: 'AlonsoChurch class' category: #Actividades stamp: 'EB 9/10/2020 16:12:50'!
AlonsoChurch class
	instanceVariableNames: 'aPerson'!

	^self dateOfBirth distanceTo: aPerson dateOfBirth.!

	^self dateOfBirth distanceTo: aPerson dateOfBirth.!

	^self dateOfBirth distanceTo: aPerson dateOfBirth.!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/10/2020 16:17:43'!
ageDifferenceWith: person
	^self dateOfBirth distanceTo: person dateOfBirth.! !

self actionSelector !

self send.!

self send.!

self send.!

self send. nil !

 nil !

self send.!

self actionSelector !

self actionSelector !

ObjectBuilder create: #VerdaderoYFalsoTest
	collaboratorNames: ''
	in: 'Ejercicio verdadero y falso'
	!

!classDefinition: #VerdaderoYFalsoTest category: #'Ejercicio verdadero y falso' stamp: 'EB 9/10/2020 21:13:16'!
DenotativeObject subclass: #VerdaderoYFalsoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!

!classDefinition: 'VerdaderoYFalsoTest class' category: #'Ejercicio verdadero y falso' stamp: 'EB 9/10/2020 21:13:16'!
VerdaderoYFalsoTest class
	instanceVariableNames: ''!

!classDefinition: #Falso category: #'Ejercicio verdadero y falso' stamp: 'EB 9/10/2020 21:16:58'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!

!classDefinition: #Verdadero category: #'Ejercicio verdadero y falso' stamp: 'EB 9/10/2020 21:17:01'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!
!VerdaderoYFalsoTest class methodsFor: 'nil' stamp: 'EB 9/10/2020 21:16:56'!
test01NoVerdaderoEsFalso
	Assert that: Falso isEqualTo: Verdadero no! !

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'EB 9/10/2020 21:17:25'!
ERROR!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'EB 9/10/2020 21:17:25'!
ERROR!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'EB 9/10/2020 21:18:49'!
ERROR!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'EB 9/10/2020 21:18:49'!
ERROR!
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'EB 9/10/2020 21:19:09'!
no
	self shouldBeImplemented.! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'EB 9/10/2020 21:19:45' prior: 50864594!
no
	^Falso! !

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'EB 9/10/2020 21:19:49'!
PASSED!

----STARTUP---- (12 September 2020 18:37:27) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:06'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59'!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18'!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17'!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46'!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50864705!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50864693!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'eb 9/12/2020 18:38:06'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'eb 9/12/2020 18:38:06'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:06'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:06'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59' prior: 50864642!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:06'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18' prior: 50864742!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17' prior: 50864699!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46' prior: 50864710!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50864865!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:07'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50864852!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'eb 9/12/2020 18:38:07'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'eb 9/12/2020 18:38:07'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
AlanTuring class
	instanceVariableNames: ''!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
AlanTuring class
	instanceVariableNames: ''!
!AlanTuring class methodsFor: 'personal info' stamp: 'EB 9/7/2020 16:25:57'!
dateOfBirth
	^June/23/1912.! !

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
AlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:07'!
AlonsoChurch class
	instanceVariableNames: ''!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:29:41'!
dateOfBirth
	^June/14/1903! !
!AlanTuring class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:43:45' overrides: 50817518!
doesNotUnderstand: aMessage
	^'No entiendo lo que me decis'! !

!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:08'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:08'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:08'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59' prior: 50864800!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18' prior: 50864902!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17' prior: 50864858!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46' prior: 50864870!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50865083!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:08'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50865070!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'eb 9/12/2020 18:38:08'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'eb 9/12/2020 18:38:09'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

!classDefinition: #Pepe category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'Pepe class' category: #'DenotativeObject-TestSupport' stamp: 'eb 9/12/2020 18:38:09'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:09'!
Pepe class
	instanceVariableNames: ''!

!classDefinition: #Pepe category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: 'Pepe class' category: #'Actividad 1' stamp: 'eb 9/12/2020 18:38:09'!
Pepe class
	instanceVariableNames: ''!
!Pepe class methodsFor: 'no messages' stamp: 'Enzo Bonansea 8/31/2020 21:00:59' prior: 50865018!
hola
	"pepe responder chau"
	^'Chau'.! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: ''!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: ''!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'nil' stamp: 'Enzo Bonansea 8/31/2020 21:30:18' prior: 50865120!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := unaCantidadDeKilosDeCerebro * 4! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:17' prior: 50865076!
caminar: unaCantidadDeKilometros
	diasDeVida := diasDeVida - (3 + unaCantidadDeKilometros)! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:46' prior: 50865088!
energia
	^diasDeVida! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:32:57' prior: 50865243!
energia
	^diasDeVida! !

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: 'diasDeVida'!

!classDefinition: #Bill category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classDefinition: 'Bill class' category: #'Actividad 2' stamp: 'eb 9/12/2020 18:38:09'!
Bill class
	instanceVariableNames: 'diasDeVida'!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:47:18' overrides: 16883149!
initialize
	diasDeVida := 28! !
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 21:48:42' prior: 50865230!
comer: unaCantidadDeKilosDeCerebro
	diasDeVida := diasDeVida + (unaCantidadDeKilosDeCerebro * 4)! !

!methodRemoval: Bill class #initialize stamp: 'eb 9/12/2020 18:38:09'!
initialize
	diasDeVida := 28!
!Bill class methodsFor: 'as yet unclassified' stamp: 'Enzo Bonansea 8/31/2020 22:05:06' overrides: 50817062!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.! !

!methodRemoval: Bill class #initializeCollaboratorsFromFile stamp: 'eb 9/12/2020 18:38:10'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	diasDeVida := 32.!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
AlanTuring class
	instanceVariableNames: ''!

!classDefinition: #AlanTuring category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
DenotativeObject subclass: #AlanTuring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlanTuring class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
AlanTuring class
	instanceVariableNames: ''!
!AlanTuring class methodsFor: 'personal info' stamp: 'EB 9/7/2020 16:25:57' prior: 50864948!
dateOfBirth
	^June/23/1912.! !

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
AlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: #AlonsoChurch category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: 'AlonsoChurch class' category: #'Ejercicio 3' stamp: 'eb 9/12/2020 18:38:10'!
AlonsoChurch class
	instanceVariableNames: ''!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:29:41' prior: 50864975!
dateOfBirth
	^June/14/1903! !
!AlanTuring class methodsFor: 'nil' stamp: 'EB 9/7/2020 16:43:45' prior: 50864979 overrides: 50817518!
doesNotUnderstand: aMessage
	^'No entiendo lo que me decis'! !

!classRemoval: #Bill stamp: 'eb 9/12/2020 18:38:10'!
DenotativeObject subclass: #Bill
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 2'!

!classRemoval: #Pepe stamp: 'eb 9/12/2020 18:38:11'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividad 1'!

!classDefinition: #CloneOfAlonsoChurch category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
DenotativeObject subclass: #CloneOfAlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

!classDefinition: #CloneOfAlonsoChurch category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
DenotativeObject subclass: #CloneOfAlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

!classDefinition: 'CloneOfAlonsoChurch class' category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
CloneOfAlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: 'CloneOfAlonsoChurch class' category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
CloneOfAlonsoChurch class
	instanceVariableNames: ''!
!CloneOfAlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/10/2020 16:01:10'!
dateOfBirth
	^June/14/1903! !

!methodRemoval: AlonsoChurch class #dateOfBirth stamp: 'eb 9/12/2020 18:38:11'!
dateOfBirth
	^June/14/1903!

!classRemoval: #AlonsoChurch stamp: 'eb 9/12/2020 18:38:11'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio 3'!

!classDefinition: #AlonsoChurch category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

!classDefinition: #AlonsoChurch category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
DenotativeObject subclass: #AlonsoChurch
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Actividades'!

!classDefinition: 'AlonsoChurch class' category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
AlonsoChurch class
	instanceVariableNames: ''!

!classDefinition: 'AlonsoChurch class' category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
AlonsoChurch class
	instanceVariableNames: ''!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/10/2020 16:10:15'!
dateOfBirth
	^June/14/1903! !

!classDefinition: 'AlonsoChurch class' category: #Actividades stamp: 'eb 9/12/2020 18:38:11'!
AlonsoChurch class
	instanceVariableNames: 'aPerson'!
!AlonsoChurch class methodsFor: 'nil' stamp: 'EB 9/10/2020 16:17:43'!
ageDifferenceWith: person
	^self dateOfBirth distanceTo: person dateOfBirth.! !

!classDefinition: #VerdaderoYFalsoTest category: #'Ejercicio verdadero y falso' stamp: 'eb 9/12/2020 18:38:12'!
DenotativeObject subclass: #VerdaderoYFalsoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!

!classDefinition: 'VerdaderoYFalsoTest class' category: #'Ejercicio verdadero y falso' stamp: 'eb 9/12/2020 18:38:12'!
VerdaderoYFalsoTest class
	instanceVariableNames: ''!

!classDefinition: #VerdaderoYFalsoTest category: #'Ejercicio verdadero y falso' stamp: 'eb 9/12/2020 18:38:12'!
DenotativeObject subclass: #VerdaderoYFalsoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!

!classDefinition: 'VerdaderoYFalsoTest class' category: #'Ejercicio verdadero y falso' stamp: 'eb 9/12/2020 18:38:12'!
VerdaderoYFalsoTest class
	instanceVariableNames: ''!

!classDefinition: #Falso category: #'Ejercicio verdadero y falso' stamp: 'eb 9/12/2020 18:38:12'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!

!classDefinition: #Verdadero category: #'Ejercicio verdadero y falso' stamp: 'eb 9/12/2020 18:38:12'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Ejercicio verdadero y falso'!
!VerdaderoYFalsoTest class methodsFor: 'nil' stamp: 'EB 9/10/2020 21:16:56'!
test01NoVerdaderoEsFalso
	Assert that: Falso isEqualTo: Verdadero no! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'EB 9/10/2020 21:19:09'!
no
	self shouldBeImplemented.! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'EB 9/10/2020 21:19:45' prior: 50865498!
no
	^Falso! !

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\Solucion Verdadero Falso.st----!

Verdadero siVerdadero: ["hola"]!

Verdadero siVerdadero: ['hola']!

#NoEvaluado!

#NoEvaluado!

#NoEvaluado!

----End fileIn of C:\Program Files\CuisUniversity\Packages\TerseGuide.pck.st----!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:26'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

!testRun: #DenotativeObjectTestCase #performRealTest stamp: 'eb 9/12/2020 19:22:27'!
PASSED!

----QUIT----(12 September 2020 19:28:29) CuisUniversity-4365.image priorSource: 17024812!

----STARTUP---- (14 September 2020 20:42:30) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


ObjectBuilder create: #I
	collaboratorNames: ''
	in: 'Numeros de Peano'
	!

!classDefinition: #I category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:26:22'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'I class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:26:22'!
I class
	instanceVariableNames: ''!

I next.!
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:26:53'!
next
	self shouldBeImplemented.! !
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:28:58' prior: 50868730!
next

	^[ObjectBuilder create: (self printString,'I') asChildOf: self printString in: 'Numeros de Peano']
! !
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:29:06' prior: 50868734!
next
	^[ObjectBuilder create: (self printString,'I') asChildOf: self printString in: 'Numeros de Peano']
! !

I next.!

ObjectBuilder create: #anObject collaboratorNames: '' in: 'DenotativeObject-TestSupport'
	!

!classDefinition: #anObject category: #'DenotativeObject-TestSupport' stamp: 'eb 9/14/2020 21:30:03'!
DenotativeObject subclass: #anObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

!classDefinition: 'anObject class' category: #'DenotativeObject-TestSupport' stamp: 'eb 9/14/2020 21:30:03'!
anObject class
	instanceVariableNames: ''!

!classRemoval: #anObject stamp: 'eb 9/14/2020 21:30:15'!
DenotativeObject subclass: #anObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'DenotativeObject-TestSupport'!

I next.!
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:30:58' prior: 50868740!
next
	^[ObjectBuilder create: (self printString,'I') asChildOf: (self printString) in: 'Numeros de Peano']
! !

I next.!
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:31:08' prior: 50868769!
next
	^ObjectBuilder create: (self printString,'I') asChildOf: (self printString) in: 'Numeros de Peano'
! !

I next.!
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:31:27' prior: 50868776!
next
	^[ObjectBuilder create: (self printString,'I') asChildOf: (self printString) in: 'Numeros de Peano']value
! !

I next.!
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:32:17' prior: 50868783!
next
	^self createChildNamed: self name, 'I'
! !

I next.!

!classDefinition: #II category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:32:26'!
I subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'II class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:32:26'!
II class
	instanceVariableNames: ''!

I+I.!
!I class methodsFor: 'as yet unclassified' stamp: 'eb 9/14/2020 21:33:32'!
+ anI 
	self shouldBeImplemented.! !

!methodRemoval: I class #+ stamp: 'eb 9/14/2020 21:33:42'!
+ anI 
	self shouldBeImplemented.!

I+I.!
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:33:49'!
+ anI 
	self shouldBeImplemented.! !
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:34:14' prior: 50868812!
+ aNumber 
	^self next.! !

I+I.!

!classDefinition: #II category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:34:27'!
I subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'II class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:34:27'!
II class
	instanceVariableNames: ''!

II prev.!
!II class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:36:06'!
prev
	self shouldBeImplemented.! !
!II class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:36:24' prior: 50868830!
prev
	^I.! !
!II class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:36:37' prior: 50868834!
prev
	^I.! !

II prev.!

II next.!

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:36:50'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:36:51'!
III class
	instanceVariableNames: ''!
!II class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:39:07' overrides: 50868816!
+ aNumber
	^ self prev + aNumber next.! !

II+II!

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:12'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:12'!
III class
	instanceVariableNames: ''!

!classDefinition: #II category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:12'!
I subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'II class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:12'!
II class
	instanceVariableNames: ''!

II prev.!

II next.!

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:32'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:32'!
III class
	instanceVariableNames: ''!

II+II.!

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:39'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:39'!
III class
	instanceVariableNames: ''!

!classDefinition: #II category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:40'!
I subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'II class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:39:40'!
II class
	instanceVariableNames: ''!
!II class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:40:02' prior: 50868852 overrides: 50868816!
+ aNumber
	^ (self prev) + (aNumber next).! !

II+II. II !

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:03'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:03'!
III class
	instanceVariableNames: ''!

!classDefinition: #II category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:03'!
I subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'II class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:03'!
II class
	instanceVariableNames: ''!
!II class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:40:09' prior: 50868911 overrides: 50868816!
+ aNumber
	^ self prev + aNumber next.! !
!I class methodsFor: 'operations' stamp: 'eb 9/14/2020 21:40:40' prior: 50868816!
+ aNumber 
	^aNumber next.! !

II+II. II !

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:48'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:48'!
III class
	instanceVariableNames: ''!

!classDefinition: #IIII category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:48'!
III subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'IIII class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:48'!
IIII class
	instanceVariableNames: ''!

II+II. !

!classDefinition: #III category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:53'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'III class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:53'!
III class
	instanceVariableNames: ''!

!classDefinition: #IIII category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:53'!
III subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numeros de Peano'!

!classDefinition: 'IIII class' category: #'Numeros de Peano' stamp: 'eb 9/14/2020 21:40:53'!
IIII class
	instanceVariableNames: ''!
!I class methodsFor: 'nil' stamp: 'eb 9/14/2020 21:46:08'!
* aNumber
	^ aNumber! !

!methodRemoval: I class #* stamp: 'eb 9/14/2020 21:50:39'!
* aNumber
	^ aNumber!

----QUIT----(15 September 2020 07:55:00) CuisUniversity-4365.image priorSource: 17185916!

----STARTUP---- (17 September 2020 18:36:25) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


Object subclass: #Semaforo
	instanceVariableNames: 'rojo amarillo verde'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!

!classDefinition: #Semaforo category: #'actividad-1' stamp: 'eb 9/17/2020 18:38:09'!
Object subclass: #Semaforo
	instanceVariableNames: 'rojo amarillo verde'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!
!Semaforo class methodsFor: 'nil' stamp: 'eb 9/17/2020 18:40:14' overrides: 16783533!
new
	^super new initializeValues.! !

Semaforo new!
!Semaforo methodsFor: 'nil' stamp: 'eb 9/17/2020 18:41:32'!
initializeVariables
	rojo := 'Rojo'.
	amarillo := 'Amarillo'.
	verde := 'Verde'.
	 ! !
!Semaforo class methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 18:41:42' prior: 50869014 overrides: 16783533!
new
	^super new initializeVariables.! !

Semaforo new!
!Semaforo methodsFor: 'nil' stamp: 'eb 9/17/2020 18:42:31'!
luzActual
	^amarillo.! !

Semaforo new luzActual!

TestCase subclass: #SemaforoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!

!classDefinition: #SemaforoTest category: #'actividad-1' stamp: 'eb 9/17/2020 18:43:25'!
TestCase subclass: #SemaforoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!
!SemaforoTest methodsFor: 'no messages' stamp: 'eb 9/17/2020 18:44:53'!
test01luzActualEsAmarillaAlCrear
	Assert that: Semaforo new luzActual isEqualTo: 'Amarillo'.! !

!testRun: #SemaforoTest #test01luzActualEsAmarillaAlCrear stamp: 'eb 9/17/2020 18:44:56'!
PASSED!
!Semaforo commentStamp: '<historical>' prior: 0!
Fibonacci new primeros20numeros.!

!classDefinition: #Fibonacci category: #'actividad-2' stamp: 'eb 9/17/2020 19:33:27'!
Object subclass: #Fibonacci
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-2'!

Fibonacci new primeros20numeros.!
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:33:54'!
primeros20numeros
	self shouldBeImplemented.! !
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:39:28' prior: 50869064!
primeros20numeros
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs at: 1 put: 0.
	fibs at: 2 put: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[fibs at: fibActual put: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value].
	^fibs.
	! !
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:40:25' prior: 50869069!
primeros20numeros
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs add: 0.
	fibs add: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[fibs add: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value].
	^fibs.
	! !

----STARTUP---- (17 September 2020 19:41:17) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #Semaforo category: #'actividad-1' stamp: 'eb 9/17/2020 19:41:20'!
Object subclass: #Semaforo
	instanceVariableNames: 'rojo amarillo verde'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!

!classDefinition: #Semaforo category: #'actividad-1' stamp: 'eb 9/17/2020 19:41:21'!
Object subclass: #Semaforo
	instanceVariableNames: 'rojo amarillo verde'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!
!Semaforo class methodsFor: 'nil' stamp: 'eb 9/17/2020 18:40:14' overrides: 16783533!
new
	^super new initializeValues.! !
!Semaforo methodsFor: 'nil' stamp: 'eb 9/17/2020 18:41:32'!
initializeVariables
	rojo := 'Rojo'.
	amarillo := 'Amarillo'.
	verde := 'Verde'.
	 ! !
!Semaforo class methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 18:41:42' prior: 50869109 overrides: 16783533!
new
	^super new initializeVariables.! !
!Semaforo methodsFor: 'nil' stamp: 'eb 9/17/2020 18:42:31'!
luzActual
	^amarillo.! !

!classDefinition: #SemaforoTest category: #'actividad-1' stamp: 'eb 9/17/2020 19:41:21'!
TestCase subclass: #SemaforoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!

!classDefinition: #SemaforoTest category: #'actividad-1' stamp: 'eb 9/17/2020 19:41:21'!
TestCase subclass: #SemaforoTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-1'!
!SemaforoTest methodsFor: 'no messages' stamp: 'eb 9/17/2020 18:44:53'!
test01luzActualEsAmarillaAlCrear
	Assert that: Semaforo new luzActual isEqualTo: 'Amarillo'.! !
!Semaforo commentStamp: '<historical>' prior: 0!
Fibonacci new primeros20numeros.!

!classDefinition: #Fibonacci category: #'actividad-2' stamp: 'eb 9/17/2020 19:41:21'!
Object subclass: #Fibonacci
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'actividad-2'!
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:33:54'!
primeros20numeros
	self shouldBeImplemented.! !
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:39:28' prior: 50869157!
primeros20numeros
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs at: 1 put: 0.
	fibs at: 2 put: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[fibs at: fibActual put: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value].
	^fibs.
	! !
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:40:25' prior: 50869162!
primeros20numeros
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs add: 0.
	fibs add: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[fibs add: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value].
	^fibs.
	! !
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:42:17' prior: 50869174!
primeros20numeros
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs add: 0.
	fibs add: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[
			fibs add: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value.
			fibActual := fibActual + 1.
		].
	^fibs.
	! !

Fibonacci new primeros20numeros .!

Fibonacci new primeros20numeros .!
!Fibonacci methodsFor: 'as yet unclassified' stamp: 'eb 9/17/2020 19:46:00'!
primeros20numeros: tope
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs add: 0.
	fibs add: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[
			fibs add: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value.
			fibActual := fibActual + 1.
		].
	^fibs.
	! !

!methodRemoval: Fibonacci #primeros20numeros stamp: 'eb 9/17/2020 19:46:00'!
primeros20numeros
	| fibs fibActual |
	fibs := OrderedCollection new.
	fibs add: 0.
	fibs add: 1.
	fibActual := 3.
	[fibActual <= 20]
	whileTrue:
		[
			fibs add: [(fibs at: (fibActual - 1)) + (fibs at: (fibActual - 2))] value.
			fibActual := fibActual + 1.
		].
	^fibs.
	!

----QUIT----(18 September 2020 09:03:41) CuisUniversity-4365.image priorSource: 17195017!

----STARTUP---- (19 September 2020 19:01:47) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Downloads\2020-2c-master\2020-2c-master\13-CodigoRepetido\CodigoRepetido-Ejercicio.st----!
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 19:27:30'!
xxx: aBlock yyy: miliseconds

	| customerBook millisecondsBeforeRunning millisecondsAfterRunning |
	
	customerBook := CustomerBook new.
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 19:28:05' prior: 50869509!
xxx: aBlock yyy: miliseconds

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 19:28:41'!
closureExecution: aBlock takesLessThan: miliseconds

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)! !

!methodRemoval: CustomerBookTest #xxx:yyy: stamp: 'eb 9/19/2020 19:28:55'!
xxx: aBlock yyy: miliseconds

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:29:23' prior: 50869264!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook millisecondsBeforeRunning millisecondsAfterRunning |
	
	customerBook := CustomerBook new.
	
	
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:30:43' prior: 50869567!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self closureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: 50.
	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 19:30:53'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 19:30:53'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:31:27' prior: 50869281!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	self closureExecution: [customerBook removeCustomerNamed: paulMcCartney]  takesLessThan: 100.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 19:31:35'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 19:31:35'!
PASSED!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 19:37:20'!
xxx: blockThatFails yyy: expectedError zzz: expectedConditionsBlock.
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 19:37:25' prior: 50869658!
xxx: blockThatFails yyy: expectedError zzz: expectedConditionsBlock
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 19:38:34'!
assertThat: blockThatFails throws: expectedError withPostcondition: expectedConditionsBlock
! !

!methodRemoval: CustomerBookTest #assertThat:throws:withPostcondition: stamp: 'eb 9/19/2020 19:38:37'!
assertThat: blockThatFails throws: expectedError withPostcondition: expectedConditionsBlock
!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 19:39:58'!
assertThat: blockThatFails throws: expectedError withPostcondition: expectedConditionsBlock
! !

!methodRemoval: CustomerBookTest #xxx:yyy:zzz: stamp: 'eb 9/19/2020 19:40:03'!
xxx: blockThatFails yyy: expectedError zzz: expectedConditionsBlock
!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:52:13' prior: 50869301!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	[ customerBook addCustomerNamed: ''.
	self fail ]
		on: Error 
		do: [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:53:50'!
xxx: customerBook

	^ [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:53:50' prior: 50869692!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	[ customerBook addCustomerNamed: ''.
	self fail ]
		on: Error 
		do: self xxx: customerBook! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:55:19' prior: 50869704!
xxx: customerBook

	 [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:55:43' prior: 50869712!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	[ customerBook addCustomerNamed: ''. self fail ] on: Error do: self xxx: customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:56:00' prior: 50869729!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	[ customerBook addCustomerNamed: ''. self fail ] on: Error do: [self xxx: customerBook.]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:57:19' prior: 50869738!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.

	[ customerBook addCustomerNamed: ''. self fail ] on: Error do: [ :anError | self xxx: anError.]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:58:08' prior: 50869747!
test03CanNotAddACustomerWithEmptyName 

	| emptyCustomerBook |
			
	emptyCustomerBook := CustomerBook new.

	[ emptyCustomerBook addCustomerNamed: ''. self fail ] on: Error do: [ :anError | self xxx: anError.]! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 19:59:10'!
assertErrorIsForEmptyName: anError andCustomerBookStillsEmpty: customerBook
	self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
	self assert: customerBook isEmpty ! !

!methodRemoval: CustomerBookTest #xxx: stamp: 'eb 9/19/2020 19:59:17'!
xxx: customerBook

	 [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:00:19' prior: 50869756!
test03CanNotAddACustomerWithEmptyName 

	| emptyCustomerBook |
			
	emptyCustomerBook := CustomerBook new.

	[ emptyCustomerBook addCustomerNamed: ''. self fail ] 
		on: Error 
		do: [ :anError | self assertErrorIsForEmptyName: anError andCustomerBookStillsEmpty: emptyCustomerBook ]! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:01:00'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:01:00'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:03:23' prior: 50869313!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon) ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:04:52'!
assertCustomerBookHasOneCustomer: johnLennon whoseNameIs: customerBook

	self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:04:52' prior: 50869824!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ :anError | 
			self assertCustomerBookHasOneCustomer: johnLennon whoseNameIs: customerBook ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:05:20' prior: 50869848!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: johnLennon whoseNameIs: customerBook ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:05:34' prior: 50869863!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:06:05' prior: 50869839!
assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:06:46' prior: 50869681!
assertThat: blockThatFails throws: expectedError withPostcondition: expectedConditionsBlock
! !

!methodRemoval: CustomerBookTest #assertThat:throws:withPostcondition: stamp: 'eb 9/19/2020 20:07:27'!
assertThat: blockThatFails throws: expectedError withPostcondition: expectedConditionsBlock
!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:07:45' prior: 50869539!
closureExecution: aBlock takesLessThan: miliseconds

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:08:03'!
assertClosureExecution: aBlock takesLessThan: miliseconds

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 20:08:03' prior: 50869616!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  takesLessThan: 100.
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 20:08:03' prior: 50869576!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: 50.
	
! !

!methodRemoval: CustomerBookTest #closureExecution:takesLessThan: stamp: 'eb 9/19/2020 20:08:03'!
closureExecution: aBlock takesLessThan: miliseconds

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:11'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:15'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:17'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:19'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:20'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:26'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:27'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:08:41'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:08:41'!
PASSED!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:10:12' prior: 50869926!
assertClosureExecution: aBlock takesLessThan: miliseconds 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:10:59'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:11:20'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:11:22'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:11:38'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:12:23' prior: 50869877!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ :anError | self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:12:30'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:12:30'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:12:57' prior: 50870394!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:13:04'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:13:08'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:13:14'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:21'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:13:28'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:13:32'!
PASSED!

----QUIT----(19 September 2020 20:13:43) CuisUniversity-4365.image priorSource: 17202267!

----STARTUP---- (19 September 2020 20:13:47) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:13:52'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:13:52'!
PASSED!
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 20:31:11'!
createCustomerBookWithPaulMcCartneyAsSuspendedCustomer
	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:31:48' prior: 50869328!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := self createCustomerBookWithPaulMcCartneyAsSuspendedCustomer.
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:32:57'!
createCustomerBookWithOneSuspendedCustomerCalled: customer 
	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 20:33:18' prior: 50870590!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	
	customerBook addCustomerNamed: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:33:36' prior: 50870574!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney .
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:33:56' prior: 50870613!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Carney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:34:06' prior: 50870630!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:34:29' prior: 50869347!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:45:12' prior: 50870648!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
FAILURE!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
FAILURE!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
FAILURE!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:45:12'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:45:12'!
FAILURE!
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 20:45:49'!
assertCustomerBook: customerBook
ActiveCustomersCountIs: activeCoustomersCount
SuspendedCustomersCountIs: suspendedCustomersCount
AndTotalCustomersCountIs: totalCustomersCount
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:46:04' prior: 50870684!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBook: customerBook 
	ActiveCustomersCountIs: 0
	SuspendedCustomersCountIs: 1
	AndTotalCustomersCountIs: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:46:21' prior: 50870793!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBook: customerBook  ActiveCustomersCountIs: 0 
	SuspendedCustomersCountIs: 1 AndTotalCustomersCountIs: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 20:48:50'!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBook methodsFor: 'testing' stamp: 'eb 9/19/2020 20:50:57'!
hasOnlyOneSuspendedCustomer
	CustomerBookTest assert: 0 equals: self numberOfActiveCustomers.
	CustomerBookTest assert: 1 equals: self numberOfSuspendedCustomers.
	CustomerBookTest assert: 1 equals: self numberOfCustomers.
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:51:19' prior: 50870809!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self hasOnlyOneSuspendedCustomer.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:52:03' prior: 50870845!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !

!methodRemoval: CustomerBookTest #assertCustomerBook:ActiveCustomersCountIs:SuspendedCustomersCountIs:AndTotalCustomersCountIs: stamp: 'eb 9/19/2020 20:52:42'!
assertCustomerBook: customerBook
ActiveCustomersCountIs: activeCoustomersCount
SuspendedCustomersCountIs: suspendedCustomersCount
AndTotalCustomersCountIs: totalCustomersCount
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:53:32'!
assertCustomerBookIsEmpty: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:53:32' prior: 50870666!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:54:14' prior: 50870899!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney .
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:54:17' prior: 50870913!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:54:24' prior: 50870929!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:54:33'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:54:38'!
PASSED!

----QUIT----(19 September 2020 20:54:43) CuisUniversity-4365.image priorSource: 17244011!

----STARTUP---- (19 September 2020 20:54:47) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 20:55:25'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 20:55:25'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:32' prior: 50869368!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:33' prior: 50871055!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:43' prior: 50869384!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:11' prior: 50871070!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:49' prior: 50871085!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 21:02:17'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 21:02:17'!
PASSED!
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 21:05:07'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:05:27' prior: 50870602!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:06' prior: 50871101!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:39' prior: 50869941!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  takesLessThan: 100.
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:07:48' prior: 50870438!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 21:08:06'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 21:08:06'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 21:08:06'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 21:08:06'!
PASSED!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:08:36' prior: 50871169!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 21:08:49'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 21:08:49'!
PASSED!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:12:30' prior: 50869955!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: (50 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:13:39'!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * quantity)! !

!methodRemoval: CustomerBookTest #assertClosureExecution:takesLessThan: stamp: 'eb 9/19/2020 21:13:43'!
assertClosureExecution: aBlock takesLessThan: miliseconds 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:13' prior: 50871276!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: 50 inUnit: millisecond .
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:30' prior: 50871194!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 21:14:49'!
ERROR!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 21:14:49'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 21:14:49'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 21:14:49'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:14:49'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:14:49'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 21:14:49'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 21:14:49'!
PASSED!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:14:58' prior: 50871286!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 21:15:01'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 21:15:01'!
PASSED!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:15:11' prior: 50871371!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:16:11'!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50871180!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50871116!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50871207!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #assertCustomerBookHasOneCustomer:whoseNameIs: stamp: 'eb 9/19/2020 21:16:11'!
assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:17:03' prior: 50870889!
assertCustomerBookIsEmpty: customerBook
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !

!methodRemoval: CustomerBookTest #createCustomerBookWithPaulMcCartneyAsSuspendedCustomer stamp: 'eb 9/19/2020 21:18:26'!
createCustomerBookWithPaulMcCartneyAsSuspendedCustomer
	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	^customerBook.!
!CustomerBook class methodsFor: 'error messages' stamp: 'eb 9/19/2020 21:20:47'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:21:34'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneCustomerCalled: stamp: 'eb 9/19/2020 21:21:56'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:22:05' prior: 50871523!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:26' prior: 50871327!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:30' prior: 50871468!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:33' prior: 50871438!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneSuspendedCustomerCalled: stamp: 'eb 9/19/2020 21:22:45'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:51' prior: 50870859!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:57' prior: 50870944!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:23:03' prior: 50871453!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:41' prior: 50871515!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:47' prior: 50871542!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 21:23:50'!
PASSED!

!methodRemoval: CustomerBook #hasOnlyOneSuspendedCustomer stamp: 'eb 9/19/2020 21:24:22'!
hasOnlyOneSuspendedCustomer
	CustomerBookTest assert: 0 equals: self numberOfActiveCustomers.
	CustomerBookTest assert: 1 equals: self numberOfSuspendedCustomers.
	CustomerBookTest assert: 1 equals: self numberOfCustomers.
!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:34' prior: 50871429!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:44' prior: 50870825!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:49' prior: 50871492!
assertCustomerBookIsEmpty: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:54' prior: 50869765!
assertErrorIsForEmptyName: anError andCustomerBookStillsEmpty: customerBook

	self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
	self assert: customerBook isEmpty ! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:20' prior: 50871652!
createCustomerBookWithOneCustomerCalled: customerName

	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:24' prior: 50871661!
createCustomerBookWithOneSuspendedCustomerCalled: customerName

	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:56:15'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:58:26'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].! !

!methodRemoval: CustomerBook #removeCustomerNamedAux: stamp: 'eb 9/19/2020 21:58:32'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:04' prior: 50869454!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.

	[suspended removeFromCollection: aName] value.
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:22' prior: 50871798!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.
	[suspended removeFromCollection: aName] value.
	^ NotFound signal.
! !

OrderedCollection!

SequenceableCollection!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:06:24'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:06:24'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:06:24'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:06:24'!
ERROR!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:06:24'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:06:24'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:06:24'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:06:24'!
PASSED!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:15:49'!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !

!methodRemoval: CustomerBook #removeFromCollection: stamp: 'eb 9/19/2020 22:15:55'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:16:20' prior: 50871806!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^ NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:16:28'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:16:28'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:16:28'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:16:28'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:16:28'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:16:28'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:16:28'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:16:28'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:16:36'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:16:36'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:16:36'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:16:36'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:16:36'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:16:36'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:16:36'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:16:36'!
PASSED!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:08' prior: 50871864!
removeCustomerNamed: aName 
 
	self removeFrom: active elementNamed: aName.
	self removeFrom: suspended elementNamed: aName.
	^NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:17:12'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:17:12'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:17:12'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:17:12'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:17:12'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:17:12'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:17:12'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:17:12'!
PASSED!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:25' prior: 50871845!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:17:28'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:17:28'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:17:28'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:17:28'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:17:28'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:17:28'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:17:28'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:17:28'!
PASSED!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:08' prior: 50871970!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:22' prior: 50871932!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName].
	[self removeFrom: suspended elementNamed: aName].
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:43' prior: 50872020!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	^NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:19:47'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:19:47'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:19:47'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:19:47'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:19:47'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:19:47'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:19:47'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:19:47'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:20:01'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:20:01'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:20:01'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:20:01'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:20:01'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:20:01'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:20:01'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:20:01'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:21:29'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:21:29'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:21:29'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:21:29'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:21:29'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:21:29'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:21:29'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:21:29'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:21:40'!
ERROR!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:21:51'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:25' prior: 50872010!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:40' prior: 50872134!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:23:42'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:23:42'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:23:42'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:23:42'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:23:43'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:23:43'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:23:43'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:23:43'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:23:44'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:24:31' prior: 50872028!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	^NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:24:33'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:24:33'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:24:33'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:24:33'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:24:33'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:24:33'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:24:33'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:24:33'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:24:34'!
ERROR!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:24:57'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:29' prior: 50872188!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	[^NotFound signal].
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:25:31'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:25:31'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:25:31'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:25:31'!
FAILURE!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:25:31'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:25:31'!
FAILURE!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:25:31'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:25:31'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:25:34'!
FAILURE!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:54' prior: 50872234!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal] value.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:25:58'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:25:58'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:25:58'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:25:58'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:25:58'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:25:58'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:25:58'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:25:58'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:26:00'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:27:42' prior: 50872276!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal].
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:27:46'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:27:46'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:27:46'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:27:46'!
FAILURE!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:27:46'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:27:46'!
FAILURE!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:27:46'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:27:46'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:27:47'!
FAILURE!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:27:50'!
FAILURE!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:30:16' prior: 50872144!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:30:31'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:30:31'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:30:31'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:30:31'!
FAILURE!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:30:31'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:30:31'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:30:31'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:30:31'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:30:36'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:29' prior: 50872365!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:37' prior: 50872409!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:39' prior: 50872419!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:31:44'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:31:44'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:31:44'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:31:44'!
ERROR!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:31:44'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:31:44'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:31:44'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:31:44'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:31:48'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:32:11' prior: 50872429!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:32:14'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:32:14'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:32:14'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:32:14'!
FAILURE!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:32:14'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:32:14'!
FAILURE!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:32:14'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:32:14'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:32:17'!
FAILURE!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:33:04' prior: 50872473!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:34:38' prior: 50872517!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:34:46'!
FAILURE!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:34:46'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:34:46'!
FAILURE!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:35:20' prior: 50872319!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:35:23'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:35:23'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:35:23'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:35:23'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:35:23'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:35:23'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:35:23'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:35:23'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:35:27'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:36:55' prior: 50872527!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:37:02' prior: 50872612!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:37:05'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:37:05'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:37:05'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:37:05'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:37:05'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:37:05'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:37:05'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:37:05'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:37:07'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:10' prior: 50872622!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self error: 'xd'.! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:38:14'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:38:14'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:38:14'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:38:14'!
ERROR!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:38:14'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:38:14'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:38:14'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:38:14'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:38:17'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:33' prior: 50872666!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:38:38'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:38:38'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:38:38'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:38:38'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:38:38'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:38:38'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:38:38'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:38:38'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:38:42'!
ERROR!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:39:01'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:14' prior: 50872709!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:21' prior: 50872757!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:40:30'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:40:30'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:40:30'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:40:30'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:40:30'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:40:30'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:40:31'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:40:31'!
PASSED!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:40:33'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:40:33'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:40:33'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:40:34'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:40:34'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:40:34'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:40:34'!
ERROR!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:40:34'!
ERROR!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:40:37'!
ERROR!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:40:58'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:35' prior: 50872767!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:37' prior: 50872845!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:43:51'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/19/2020 22:43:51'!
ERROR!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:43:51'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/19/2020 22:43:51'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:43:51'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:43:51'!
ERROR!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:43:51'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:43:51'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:43:58'!
ERROR!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:45:47' prior: 50872570!
removeCustomerNamed: aName 
 	self halt.
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:45:49'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:45:49'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:45:49'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:45:49'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:45:49'!
PASSED!

customerBook := CustomerBook new!

customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: 'enzo'!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:48:46' prior: 50872855!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:50:34' prior: 50872930!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | 
			self halt.
			elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/19/2020 22:50:43'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/19/2020 22:50:43'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/19/2020 22:50:43'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/19/2020 22:50:43'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/19/2020 22:50:43'!
PASSED!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:06:42' prior: 50872899!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:07:00' prior: 50872969!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].

	self halt.! !

cb := CustomerBook createCustomerBookWithOneCustomerCalled: 'jose'.!

----STARTUP---- (19 September 2020 23:09:09) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!

!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:32' prior: 50869368!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:33' prior: 50872998!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:43' prior: 50869384!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:11' prior: 50873013!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:49' prior: 50873028!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 21:05:07'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:05:27' prior: 50870602!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:06' prior: 50873044!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:39' prior: 50869941!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  takesLessThan: 100.
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:07:48' prior: 50870438!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:08:36' prior: 50873082!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:12:30' prior: 50869955!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: (50 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:13:39'!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * quantity)! !

!methodRemoval: CustomerBookTest #assertClosureExecution:takesLessThan: stamp: 'eb 9/19/2020 23:09:11'!
assertClosureExecution: aBlock takesLessThan: miliseconds 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:13' prior: 50873144!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: 50 inUnit: millisecond .
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:30' prior: 50873107!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:14:58' prior: 50873154!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:15:11' prior: 50873209!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:16:11'!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50873093!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50873059!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50873120!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #assertCustomerBookHasOneCustomer:whoseNameIs: stamp: 'eb 9/19/2020 23:09:11'!
assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:17:03' prior: 50870889!
assertCustomerBookIsEmpty: customerBook
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !

!methodRemoval: CustomerBookTest #createCustomerBookWithPaulMcCartneyAsSuspendedCustomer stamp: 'eb 9/19/2020 23:09:11'!
createCustomerBookWithPaulMcCartneyAsSuspendedCustomer
	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	^customerBook.!
!CustomerBook class methodsFor: 'error messages' stamp: 'eb 9/19/2020 21:20:47'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:21:34'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneCustomerCalled: stamp: 'eb 9/19/2020 23:09:11'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:22:05' prior: 50873332!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:26' prior: 50873195!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:30' prior: 50873277!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:33' prior: 50873247!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneSuspendedCustomerCalled: stamp: 'eb 9/19/2020 23:09:11'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:51' prior: 50870859!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:57' prior: 50870944!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:23:03' prior: 50873262!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:41' prior: 50873324!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:47' prior: 50873351!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!methodRemoval: CustomerBook #hasOnlyOneSuspendedCustomer stamp: 'eb 9/19/2020 23:09:11'!
hasOnlyOneSuspendedCustomer
	CustomerBookTest assert: 0 equals: self numberOfActiveCustomers.
	CustomerBookTest assert: 1 equals: self numberOfSuspendedCustomers.
	CustomerBookTest assert: 1 equals: self numberOfCustomers.
!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:34' prior: 50873238!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:44' prior: 50870825!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:49' prior: 50873301!
assertCustomerBookIsEmpty: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:54' prior: 50869765!
assertErrorIsForEmptyName: anError andCustomerBookStillsEmpty: customerBook

	self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
	self assert: customerBook isEmpty ! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:20' prior: 50873461!
createCustomerBookWithOneCustomerCalled: customerName

	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:24' prior: 50873470!
createCustomerBookWithOneSuspendedCustomerCalled: customerName

	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:56:15'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:58:26'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].! !

!methodRemoval: CustomerBook #removeCustomerNamedAux: stamp: 'eb 9/19/2020 23:09:11'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:04' prior: 50869454!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.

	[suspended removeFromCollection: aName] value.
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:22' prior: 50873577!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.
	[suspended removeFromCollection: aName] value.
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:15:49'!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !

!methodRemoval: CustomerBook #removeFromCollection: stamp: 'eb 9/19/2020 23:09:12'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:16:20' prior: 50873585!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:08' prior: 50873612!
removeCustomerNamed: aName 
 
	self removeFrom: active elementNamed: aName.
	self removeFrom: suspended elementNamed: aName.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:25' prior: 50873593!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:08' prior: 50873629!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:22' prior: 50873621!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName].
	[self removeFrom: suspended elementNamed: aName].
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:43' prior: 50873649!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:25' prior: 50873639!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:40' prior: 50873666!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:24:31' prior: 50873657!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:29' prior: 50873686!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	[^NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:54' prior: 50873694!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal] value.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:27:42' prior: 50873702!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:30:16' prior: 50873676!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:29' prior: 50873720!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:37' prior: 50873730!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:39' prior: 50873740!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:32:11' prior: 50873750!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:33:04' prior: 50873760!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:34:38' prior: 50873770!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:35:20' prior: 50873711!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:36:55' prior: 50873780!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:37:02' prior: 50873799!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:10' prior: 50873809!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self error: 'xd'.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:33' prior: 50873819!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:14' prior: 50873829!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:21' prior: 50873839!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:35' prior: 50873849!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:37' prior: 50873859!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:45:47' prior: 50873790!
removeCustomerNamed: aName 
 	self halt.
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:48:46' prior: 50873869!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:50:34' prior: 50873888!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | 
			self halt.
			elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:06:42' prior: 50873879!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:07:00' prior: 50873909!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].

	self halt.! !

----STARTUP---- (19 September 2020 23:09:40) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!

!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:32' prior: 50869368!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:33' prior: 50873936!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:43' prior: 50869384!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:11' prior: 50873951!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:49' prior: 50873966!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 21:05:07'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:05:27' prior: 50870602!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:06' prior: 50873982!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:39' prior: 50869941!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  takesLessThan: 100.
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:07:48' prior: 50870438!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:08:36' prior: 50874020!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:12:30' prior: 50869955!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: (50 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:13:39'!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * quantity)! !

!methodRemoval: CustomerBookTest #assertClosureExecution:takesLessThan: stamp: 'eb 9/19/2020 23:09:42'!
assertClosureExecution: aBlock takesLessThan: miliseconds 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (miliseconds * millisecond)!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:13' prior: 50874082!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: 50 inUnit: millisecond .
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:30' prior: 50874045!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:14:58' prior: 50874092!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:15:11' prior: 50874147!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:16:11'!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50874031!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50873997!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50874058!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #assertCustomerBookHasOneCustomer:whoseNameIs: stamp: 'eb 9/19/2020 23:09:42'!
assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:17:03' prior: 50870889!
assertCustomerBookIsEmpty: customerBook
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !

!methodRemoval: CustomerBookTest #createCustomerBookWithPaulMcCartneyAsSuspendedCustomer stamp: 'eb 9/19/2020 23:09:42'!
createCustomerBookWithPaulMcCartneyAsSuspendedCustomer
	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	^customerBook.!
!CustomerBook class methodsFor: 'error messages' stamp: 'eb 9/19/2020 21:20:47'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:21:34'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneCustomerCalled: stamp: 'eb 9/19/2020 23:09:42'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:22:05' prior: 50874270!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:26' prior: 50874133!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:30' prior: 50874215!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:33' prior: 50874185!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneSuspendedCustomerCalled: stamp: 'eb 9/19/2020 23:09:42'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:51' prior: 50870859!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:57' prior: 50870944!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:23:03' prior: 50874200!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:41' prior: 50874262!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:47' prior: 50874289!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!methodRemoval: CustomerBook #hasOnlyOneSuspendedCustomer stamp: 'eb 9/19/2020 23:09:42'!
hasOnlyOneSuspendedCustomer
	CustomerBookTest assert: 0 equals: self numberOfActiveCustomers.
	CustomerBookTest assert: 1 equals: self numberOfSuspendedCustomers.
	CustomerBookTest assert: 1 equals: self numberOfCustomers.
!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:34' prior: 50874176!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:44' prior: 50870825!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:49' prior: 50874239!
assertCustomerBookIsEmpty: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:54' prior: 50869765!
assertErrorIsForEmptyName: anError andCustomerBookStillsEmpty: customerBook

	self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
	self assert: customerBook isEmpty ! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:20' prior: 50874399!
createCustomerBookWithOneCustomerCalled: customerName

	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:24' prior: 50874408!
createCustomerBookWithOneSuspendedCustomerCalled: customerName

	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:56:15'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:58:26'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].! !

!methodRemoval: CustomerBook #removeCustomerNamedAux: stamp: 'eb 9/19/2020 23:09:43'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:04' prior: 50869454!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.

	[suspended removeFromCollection: aName] value.
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:22' prior: 50874515!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.
	[suspended removeFromCollection: aName] value.
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:15:49'!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !

!methodRemoval: CustomerBook #removeFromCollection: stamp: 'eb 9/19/2020 23:09:43'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:16:20' prior: 50874523!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:08' prior: 50874550!
removeCustomerNamed: aName 
 
	self removeFrom: active elementNamed: aName.
	self removeFrom: suspended elementNamed: aName.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:25' prior: 50874531!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:08' prior: 50874567!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:22' prior: 50874559!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName].
	[self removeFrom: suspended elementNamed: aName].
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:43' prior: 50874587!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:25' prior: 50874577!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:40' prior: 50874604!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:24:31' prior: 50874595!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:29' prior: 50874624!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	[^NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:54' prior: 50874632!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal] value.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:27:42' prior: 50874640!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:30:16' prior: 50874614!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:29' prior: 50874658!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:37' prior: 50874668!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:39' prior: 50874678!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:32:11' prior: 50874688!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:33:04' prior: 50874698!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:34:38' prior: 50874708!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:35:20' prior: 50874649!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:36:55' prior: 50874718!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:37:02' prior: 50874737!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:10' prior: 50874747!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self error: 'xd'.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:33' prior: 50874757!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:14' prior: 50874767!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:21' prior: 50874777!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:35' prior: 50874787!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:37' prior: 50874797!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:45:47' prior: 50874728!
removeCustomerNamed: aName 
 	self halt.
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:48:46' prior: 50874807!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:50:34' prior: 50874826!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | 
			self halt.
			elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:06:42' prior: 50874817!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:07:00' prior: 50874847!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].

	self halt.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:32' prior: 50874328!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:33' prior: 50874871!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 20:59:43' prior: 50874384!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:11' prior: 50874886!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:01:49' prior: 50874901!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'nil' stamp: 'eb 9/19/2020 21:05:07'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:05:27'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:06' prior: 50874917!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:06:39' prior: 50874300!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  takesLessThan: 100.
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:07:48' prior: 50874314!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBookHasOneCustomer: customerBook whoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:08:36' prior: 50874954!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:12:30' prior: 50874122!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: (50 * millisecond)
	
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:13:39' prior: 50874162!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * quantity)! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:13' prior: 50875016!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertClosureExecution: [customerBook addCustomerNamed: 'John Lennon'] takesLessThan: 50 inUnit: millisecond .
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:14:30' prior: 50874979!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := self createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:14:58' prior: 50875026!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:15:11' prior: 50875066!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| millisecondsBeforeRunning millisecondsAfterRunning |
		
	millisecondsBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	millisecondsAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (millisecondsAfterRunning-millisecondsBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:16:11' prior: 50874428!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon
	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: johnLennon)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50874965!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50874932!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := self createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/19/2020 21:16:11' prior: 50874992!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := self createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:17:03' prior: 50874448!
assertCustomerBookIsEmpty: customerBook
	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !
!CustomerBook class methodsFor: 'error messages' stamp: 'eb 9/19/2020 21:20:47' prior: 50874468!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:21:34' prior: 50874477!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneCustomerCalled: stamp: 'eb 9/19/2020 23:09:43'!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:22:05' prior: 50875169!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:26' prior: 50875052!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: paulMcCartney.
	  
	self assertClosureExecution: [customerBook removeCustomerNamed: paulMcCartney]  
		takesLessThan: 100 inUnit: millisecond .
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:30' prior: 50875135!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:33' prior: 50875105!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #createCustomerBookWithOneSuspendedCustomerCalled: stamp: 'eb 9/19/2020 23:09:43'!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.!
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:51' prior: 50874353!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:22:57' prior: 50874368!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney |
	
	paulMcCartney := 'Paul McCartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCustomerBookIsEmpty: customerBook.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/19/2020 21:23:03' prior: 50875120!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:41' prior: 50875160!
createCustomerBookWithOneCustomerCalled: customerName
	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:23:47' prior: 50875188!
createCustomerBookWithOneSuspendedCustomerCalled: customerName
	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:34' prior: 50875096!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:44' prior: 50874437!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:49' prior: 50875149!
assertCustomerBookIsEmpty: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 0 equals: customerBook numberOfSuspendedCustomers.
	self assert: 0 equals: customerBook numberOfCustomers! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/19/2020 21:26:54' prior: 50874458!
assertErrorIsForEmptyName: anError andCustomerBookStillsEmpty: customerBook

	self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
	self assert: customerBook isEmpty ! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:20' prior: 50875298!
createCustomerBookWithOneCustomerCalled: customerName

	| customerBook |
	
	customerBook := self new.
	customerBook addCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook class methodsFor: 'creation' stamp: 'eb 9/19/2020 21:27:24' prior: 50875307!
createCustomerBookWithOneSuspendedCustomerCalled: customerName

	| customerBook |
	
	customerBook := self createCustomerBookWithOneCustomerCalled: customerName.
	customerBook suspendCustomerNamed: customerName.
	
	^customerBook.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:56:15'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 21:58:26'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].! !

!methodRemoval: CustomerBook #removeCustomerNamedAux: stamp: 'eb 9/19/2020 23:09:44'!
removeCustomerNamedAux: customerName
	^[:collection | 1 to: collection size do: 
		[ :index | customerName = (collection at: index) ifTrue: 
			[active removeAt: index. ^ customerName ] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:04' prior: 50874859!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.

	[suspended removeFromCollection: aName] value.
	
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:00:22' prior: 50875404!
removeCustomerNamed: aName 
 
	[active removeFromCollection: aName] value.
	[suspended removeFromCollection: aName] value.
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:15:49' prior: 50874836!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !

!methodRemoval: CustomerBook #removeFromCollection: stamp: 'eb 9/19/2020 23:09:44'!
removeFromCollection: elementName
	^[ :collection | 1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	].!
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:16:20' prior: 50875412!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^ NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:08' prior: 50875439!
removeCustomerNamed: aName 
 
	self removeFrom: active elementNamed: aName.
	self removeFrom: suspended elementNamed: aName.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:17:25' prior: 50875420!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:08' prior: 50875456!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:22' prior: 50875448!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName].
	[self removeFrom: suspended elementNamed: aName].
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:19:43' prior: 50875476!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:25' prior: 50875466!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			] 
		]
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:23:40' prior: 50875493!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:24:31' prior: 50875484!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:29' prior: 50875513!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName).
	(self removeFrom: suspended elementNamed: aName).
	[^NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:25:54' prior: 50875521!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal] value.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:27:42' prior: 50875529!
removeCustomerNamed: aName 
 
	(self removeFrom: active elementNamed: aName) value.
	(self removeFrom: suspended elementNamed: aName) value.
	[^NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:30:16' prior: 50875503!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:29' prior: 50875547!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName 
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:37' prior: 50875557!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			]
		]
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:31:39' prior: 50875567!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:32:11' prior: 50875577!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
		^nil
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:33:04' prior: 50875587!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:34:38' prior: 50875597!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:35:20' prior: 50875538!
removeCustomerNamed: aName 
 
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:36:55' prior: 50875607!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:37:02' prior: 50875626!
removeFrom: collection elementNamed: elementName
	^1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:10' prior: 50875636!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self error: 'xd'.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:38:33' prior: 50875646!
removeFrom: collection elementNamed: elementName
	1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:14' prior: 50875656!
removeFrom: collection elementNamed: elementName
	[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:40:21' prior: 50875666!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	^self.]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:35' prior: 50875676!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	]! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:43:37' prior: 50875686!
removeFrom: collection elementNamed: elementName
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:45:47' prior: 50875617!
removeCustomerNamed: aName 
 	self halt.
	[self removeFrom: active elementNamed: aName] value.
	[self removeFrom: suspended elementNamed: aName] value.
	^NotFound signal.
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:48:46' prior: 50875696!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 22:50:34' prior: 50875715!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | 
			self halt.
			elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:06:42' prior: 50875706!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].
! !
!CustomerBook methodsFor: 'customer management' stamp: 'eb 9/19/2020 23:07:00' prior: 50875736!
removeCustomerNamed: aName 
 	
	| removeFromActive removeFromSuspended notFound |
	
	removeFromActive := [self removeFrom: active elementNamed: aName].
	removeFromSuspended := [self removeFrom: suspended elementNamed: aName].
	notFound := [NotFound signal].

	self halt.! !

----QUIT----(19 September 2020 23:09:47) CuisUniversity-4365.image priorSource: 17259772!

----STARTUP---- (19 September 2020 23:09:52) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----QUIT----(19 September 2020 23:17:55) CuisUniversity-4365.image priorSource: 17411473!

----STARTUP---- (22 September 2020 20:07:55) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\13-CodigoRepetido\CodigoRepetido-Ejercicio.st----!

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/22/2020 20:09:24'!
PASSED!

!methodRemoval: CustomerBook #removeFrom:elementNamed: stamp: 'eb 9/22/2020 20:14:03'!
removeFrom: collection elementNamed: elementName
	self halt.
	^[1 to: collection size do: 
		[ :index | 
			self halt.
			elementName = (collection at: index) ifTrue: 
			[ collection removeAt: index. 
			  ^ elementName.
			].
		].
	].!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/22/2020 20:16:07' prior: 50875922!
assertClosureExecution: aBlock takesLessThan: quantity inUnit: unit 

	| timeBeforeRunning timeAfterRunning |
		
	timeBeforeRunning := Time millisecondClockValue * unit.
	aBlock value.
	timeAfterRunning := Time millisecondClockValue * unit.
	
	self assert: (timeAfterRunning-timeBeforeRunning) < (quantity * unit)! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/22/2020 20:17:19'!
assertCustomerBook: customerBook hasOnlyOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/22/2020 20:17:19' prior: 50875892!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOnlyOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/22/2020 20:17:19' prior: 50875846!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOnlyOneCustomerWhoseNameIs: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/22/2020 20:17:19' prior: 50875907!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOnlyOneCustomerWhoseNameIs: johnLennon ]
! !

!methodRemoval: CustomerBookTest #assertCustomerBook:hasOneCustomerWhoseNameIs: stamp: 'eb 9/22/2020 20:17:19'!
assertCustomerBook: customerBook hasOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/22/2020 20:21:38' prior: 50875946!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/22/2020 20:22:24'!
assertCustomerBook: customerBook hasOnlyOneCustomerCalled: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/22/2020 20:22:24' prior: 50876206!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: johnLennon .
	
	[ customerBook suspendCustomerNamed: johnLennon.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOnlyOneCustomerCalled: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/22/2020 20:22:24' prior: 50876191!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
	
	johnLennon := 'John Lennon'.		
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook removeCustomerNamed: 'Paul McCartney'. self fail ]
		on: NotFound 
		do: [ self assertCustomerBook: customerBook hasOnlyOneCustomerCalled: johnLennon ]
! !
!CustomerBookTest methodsFor: 'as yet unclassified' stamp: 'eb 9/22/2020 20:22:24' prior: 50876175!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	johnLennon := 'John Lennon'.
	customerBook := CustomerBook createCustomerBookWithOneCustomerCalled: johnLennon.
	
	[ customerBook suspendCustomerNamed: 'George Harrison'.
	self fail ]
		on: CantSuspend 
		do: [ self assertCustomerBook: customerBook hasOnlyOneCustomerCalled: johnLennon ]
! !

!methodRemoval: CustomerBookTest #assertCustomerBook:hasOnlyOneCustomerWhoseNameIs: stamp: 'eb 9/22/2020 20:22:24'!
assertCustomerBook: customerBook hasOnlyOneCustomerWhoseNameIs: customerName

	self assert: customerBook numberOfCustomers = 1.
	self assert: (customerBook includesCustomerNamed: customerName)!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/22/2020 20:23:07'!
assertCustomerBook: customerBook hasOnlyOneSuspendedCustomerCalled: customerName

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.! !

!methodRemoval: CustomerBookTest #assertCustomerBookHasOnlyOneSuspendedCustomer: stamp: 'eb 9/22/2020 20:23:12'!
assertCustomerBookHasOnlyOneSuspendedCustomer: customerBook

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.!
!CustomerBookTest methodsFor: 'private' stamp: 'eb 9/22/2020 20:24:08' prior: 50876307!
assertCustomerBook: customerBook hasOnlyOneSuspendedCustomerCalled: customerName

	self assert: 0 equals: customerBook numberOfActiveCustomers.
	self assert: 1 equals: customerBook numberOfSuspendedCustomers.
	self assert: 1 equals: customerBook numberOfCustomers.
	
	self assert: (customerBook includesCustomerNamed: customerName).
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'eb 9/22/2020 20:25:02' prior: 50875861!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	paulMcCartney := 'Paul Mc Cartney'.
	customerBook := CustomerBook createCustomerBookWithOneSuspendedCustomerCalled: paulMcCartney.
	
	self assertCustomerBook: customerBook hasOnlyOneSuspendedCustomerCalled: paulMcCartney.
	

	
! !

!testRun: #CustomerBookTest #test01AddingCustomerShouldNotTakeMoreThan50Milliseconds stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test03CanNotAddACustomerWithEmptyName stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test04CanNotRemoveAnInvalidCustomer stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test05SuspendingACustomerShouldNotRemoveItFromCustomerBook stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test07CanNotSuspendAnInvalidCustomer stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

!testRun: #CustomerBookTest #test08CanNotSuspendAnAlreadySuspendedCustomer stamp: 'eb 9/22/2020 20:25:59'!
PASSED!

----SNAPSHOT----(22 September 2020 20:26:13) CuisUniversity-4365.image priorSource: 17411673!

----QUIT----(22 September 2020 20:30:08) CuisUniversity-4365.image priorSource: 17431560!

----STARTUP---- (30 September 2020 18:17:31) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\14-Numeros\Numero-Exercise.st----!
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:28:24' prior: 50876738!
addEntero: anEntero
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:28:58' prior: 50876742!
addFraction: aFraction
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:29:03' prior: 50876746!
divideByEntero: anEntero
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:29:09' prior: 50876750!
divideByFraccion: aFraccion
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:29:35'!
addFraccion: aFraction
	^self subclassResponsibility ! !

!methodRemoval: Numero #addFraction: stamp: 'eb 9/30/2020 18:29:35'!
addFraction: aFraction
	^self subclassResponsibility !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:29:40' prior: 50877259!
addFraccion: aFraccion
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:29:53' prior: 50876754!
subtractEntero: anEntero
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:29:58' prior: 50876758!
subtractFraccion: aFraction
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:30:28' prior: 50876774!
multiplyByEntero: anEntero
	^self subclassResponsibility ! !
!Numero methodsFor: 'zzz' stamp: 'eb 9/30/2020 18:30:32' prior: 50876778!
multiplyByFraccion: aFraccion
	^self subclassResponsibility ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 18:37:06' prior: 50876812 overrides: 50876710!
* aMultiplier 
	^ aMultiplier multiplyByEntero: self.
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 18:37:10' prior: 50877294 overrides: 50876710!
* aMultiplier 
	^ aMultiplier multiplyByEntero: self.
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 18:37:42' prior: 50876830 overrides: 50876715!
+ anAdder 
	^ anAdder addEntero: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 18:38:02' prior: 50876835 overrides: 50876719!
- aSubtrahend 
	^aSubtrahend subtractEntero: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 18:40:47' prior: 50876851 overrides: 50876724!
/ aDivisor 
	^ aDivisor divideByEntero: self! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 18:41:07' prior: 50876863!
// aDivisor 
	^self class with: value // aDivisor integerValue! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:29:06' prior: 50876929 overrides: 50877268!
addFraccion: aFraccion 
	| numerator denominator |
	
	numerator := aFraccion numerator + (self * aFraccion  denominator ).
	denominator := aFraccion denominator .
	^ numerator / denominator ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:29:07' prior: 50877328 overrides: 50877268!
addFraccion: aFraccion 

	| numerator denominator |
	
	numerator := aFraccion numerator + (self * aFraccion  denominator ).
	denominator := aFraccion denominator .
	^ numerator / denominator ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:29:20' prior: 50876924 overrides: 50877240!
addEntero: anEntero 

	^self class with: (value + anEntero integerValue)! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:29:31' prior: 50876939 overrides: 50877250!
divideByEntero: anEntero

	^Fraccion with: self over: anEntero ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:30:51' prior: 50876944 overrides: 50877255!
divideByFraccion: aFraccion
	|num den |
	num := aFraccion numerator .
	den := aFraccion denominator .
	^Fraccion with:  (self class with: (value * den integerValue )) over: num.! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:31:14' prior: 50877360 overrides: 50877255!
divideByFraccion: aFraccion
	| numerator denominator |
	numerator := aFraccion numerator .
	denominator := aFraccion denominator .
	^Fraccion with:  (self class with: (value * denominator integerValue )) over: numerator.! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:32:29' prior: 50877370 overrides: 50877255!
divideByFraccion: aFraccion
	| numerator denominator |
	numerator := self * aFraccion denominator .
	denominator := aFraccion numerator .
	^ numerator / denominator .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:32:38' prior: 50877348 overrides: 50877240!
addEntero: anEntero 

	^self class with: (value + anEntero integerValue) .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:32:45' prior: 50877338 overrides: 50877268!
addFraccion: aFraccion 

	| numerator denominator |
	
	numerator := aFraccion numerator + (self * aFraccion  denominator ) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:32:49' prior: 50877354 overrides: 50877250!
divideByEntero: anEntero

	^Fraccion with: self over: anEntero .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:32:54' prior: 50876953 overrides: 50877283!
multiplyByEntero: anEntero 
	^self class with: (value * anEntero integerValue) .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:34:24' prior: 50876959 overrides: 50877288!
multiplyByFraccion: aFraccion	
	| numerator denominator |
	numerator := self * aFraccion numerator .
	denominator := aFraccion denominator .
	^numerator / denominator .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:34:25' prior: 50877419 overrides: 50877288!
multiplyByFraccion: aFraccion	
	| numerator denominator |
	numerator := self * aFraccion numerator .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:34:58' overrides: 50877278!
subtractFraccion: aFraccion 
	| newNumerator newDenominator |
	newNumerator := aFraccion numerator - (self * aFraccion  denominator ).
	newDenominator := aFraccion denominator .
	^ newNumerator / newDenominator  ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:35:11' prior: 50876971!
subtracFraccion: aFraccion 
	| newNumerator newDenominator |
	newNumerator := aFraccion numerator - (self * aFraccion  denominator ).
	newDenominator := aFraccion denominator .
	^ newNumerator / newDenominator  ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:36:35' prior: 50877447!
subtracFraccion: aFraccion

	| numerator denominator |
	numerator := self ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:37:11' prior: 50877457!
subtracFraccion: aFraccion

	| numerator denominator |
	numerator := self .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !

!methodRemoval: Entero #subtractFraccion: stamp: 'eb 9/30/2020 19:37:40'!
subtractFraccion: aFraccion 
	| newNumerator newDenominator |
	newNumerator := aFraccion numerator - (self * aFraccion  denominator ).
	newDenominator := aFraccion denominator .
	^ newNumerator / newDenominator  !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:38:05' overrides: 50877278!
subtractFraccion: aFraccion

	| numerator denominator |
	numerator := self .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:38:05' overrides: 50877278!
subtractFraccion: aFraccion 
	| newNumerator newDenominator |	
	newDenominator := denominator * (aFraccion denominator).
	newNumerator := (numerator * (aFraccion denominator) ) - (denominator * (aFraccion numerator)).
	
	^  newNumerator / newDenominator .! !

!methodRemoval: Entero #subtracFraccion: stamp: 'eb 9/30/2020 19:38:05'!
subtracFraccion: aFraccion

	| numerator denominator |
	numerator := self .
	denominator := aFraccion denominator .
	^ numerator / denominator .!

!methodRemoval: Fraccion #subtracFraccion: stamp: 'eb 9/30/2020 19:38:05'!
subtracFraccion: aFraccion 
	| newNumerator newDenominator |	
	newDenominator := denominator * (aFraccion denominator).
	newNumerator := (numerator * (aFraccion denominator) ) - (denominator * (aFraccion numerator)).
	
	^  newNumerator / newDenominator .!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:38:36'!
subtracFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator + (self * aFraccion denominator) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:38:58' prior: 50877516!
subtracFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator + (self * aFraccion denominator) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:39:06' prior: 50877480 overrides: 50877278!
subtractFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator + (self * aFraccion denominator) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !

!methodRemoval: Entero #subtracFraccion: stamp: 'eb 9/30/2020 19:39:16'!
subtracFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator + (self * aFraccion denominator) .
	denominator := aFraccion denominator .
	^ numerator / denominator .!
!Numero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:39:38' prior: 50877278!
subtractFraccion: aFraccion
	^self subclassResponsibility ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:40:10' prior: 50876981 overrides: 50877273!
subtractEntero: anEntero 
	^ self class with: (value - anEntero  integerValue).! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:41:50' prior: 50877129 overrides: 50877240!
addEntero: anEntero

	^ anEntero addFraccion: self .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:48:58' prior: 50877138 overrides: 50877268!
addFraccion: aFraccion 

	| newNumerator newDenominator selfNumeratorOverNewDenominator aFraccionNumeratorOverNewDenominator |
	newNumerator := (self denominator) * (aFraccion denominator) .
	selfNumeratorOverNewDenominator := (self numerator) * (aFraccion denominator) .
	aFraccionNumeratorOverNewDenominator := (aFraccion numerator) * (self denominator) .
	newDenominator := selfNumeratorOverNewDenominator + aFraccionNumeratorOverNewDenominator .
	^ newNumerator / newDenominator .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:49:43' prior: 50877149 overrides: 50877250!
divideByEntero: anEntero	^ anEntero divideByFraccion: self .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:49:46' prior: 50877591 overrides: 50877250!
divideByEntero: anEntero

	^ anEntero divideByFraccion: self .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:50:32' prior: 50877163 overrides: 50877283!
multiplyByEntero: anEntero
	^ anEntero multiplyByFraccion: self .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:50:55' prior: 50877192 overrides: 50877273!
subtractEntero: anEntero
	^ anEntero subtractFraccion: self.! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:51:39' prior: 50877488 overrides: 50877553!
subtractFraccion: aFraccion 
	| newNumerator newDenominator |	
	newDenominator := denominator * (aFraccion denominator).
	newNumerator := (numerator * (aFraccion denominator) ) - (denominator * (aFraccion numerator)).
	
	^  newNumerator / newDenominator .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:52:00' prior: 50877615 overrides: 50877553!
subtractFraccion: aFraccion 

	| newNumerator newDenominator selfNumeratorOverNewDenominator aFraccionNumeratorOverNewDenominator |
	newNumerator := (self denominator) * (aFraccion denominator) .
	selfNumeratorOverNewDenominator := (self numerator) * (aFraccion denominator) .
	aFraccionNumeratorOverNewDenominator := (aFraccion numerator) * (self denominator) .
	newDenominator := selfNumeratorOverNewDenominator - aFraccionNumeratorOverNewDenominator .
	^ newNumerator / newDenominator .! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:15'!
FAILURE!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 9/30/2020 19:52:15'!
PASSED!

----QUIT----(30 September 2020 19:52:22) CuisUniversity-4365.image priorSource: 17431655!

----STARTUP---- (30 September 2020 19:52:25) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:52:28'!
FAILURE!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 9/30/2020 19:52:28'!
PASSED!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 19:54:02' prior: 50877024 overrides: 50876710!
* aMultiplier 
	^aMultiplier multiplyByFraccion: self.! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 19:54:27' prior: 50877047 overrides: 50876719!
- aSubtrahend 
	^ aSubtrahend subtractFraccion: self.
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 19:54:35' prior: 50877067 overrides: 50876724!
/ aDivisor 

	^ aDivisor divideByFraccion: self! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 19:54:44' prior: 50877877 overrides: 50876724!
/ aDivisor 

	^ aDivisor divideByFraccion: self! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 19:55:26' prior: 50877157 overrides: 50877255!
divideByFraccion: aFraccion
	^Fraccion initializeWith: (numerator * aFraccion denominator) over: (denominator * aFraccion numerator) .! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:55:29'!
FAILURE!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 9/30/2020 19:55:29'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 9/30/2020 19:57:08'!
FAILURE!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 9/30/2020 19:57:08'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 9/30/2020 19:57:47'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 9/30/2020 19:57:53'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 9/30/2020 19:57:56'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 9/30/2020 19:57:58'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 9/30/2020 19:57:59'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 9/30/2020 19:58:00'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:58:02'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 9/30/2020 19:58:03'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 19:58:05'!
FAILURE!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 19:58:05'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 19:58:23'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 19:58:23'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:58:30'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 9/30/2020 19:58:30'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 19:58:44'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 19:58:44'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 9/30/2020 19:58:52'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 9/30/2020 19:58:52'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 9/30/2020 19:58:56'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 9/30/2020 19:58:56'!
FAILURE!
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:00:22' prior: 50877572 overrides: 50877268!
addFraccion: aFraccion 

	| newNumerator newDenominator selfNumeratorOverNewDenominator aFraccionNumeratorOverNewDenominator |
	newDenominator := (self denominator) * (aFraccion denominator) .
	selfNumeratorOverNewDenominator := (self numerator) * (aFraccion denominator) .
	aFraccionNumeratorOverNewDenominator := (aFraccion numerator) * (self denominator) .
	newNumerator := selfNumeratorOverNewDenominator + aFraccionNumeratorOverNewDenominator .
	^ newNumerator / newDenominator .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:00:33' prior: 50877627 overrides: 50877553!
subtractFraccion: aFraccion 

	| newNumerator newDenominator selfNumeratorOverNewDenominator aFraccionNumeratorOverNewDenominator |
	newDenominator := (self denominator) * (aFraccion denominator) .
	selfNumeratorOverNewDenominator := (self numerator) * (aFraccion denominator) .
	aFraccionNumeratorOverNewDenominator := (aFraccion numerator) * (self denominator) .
	newNumerator := selfNumeratorOverNewDenominator - aFraccionNumeratorOverNewDenominator .
	^ newNumerator / newDenominator .! !

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 20:00:39'!
FAILURE!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 20:00:39'!
FAILURE!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 20:01:00'!
FAILURE!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 9/30/2020 20:01:00'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 20:01:12'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 9/30/2020 20:01:12'!
FAILURE!

oneFifth + oneHalf!

| zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo|
	zero := Entero with: 0.
	one := Entero with: 1.
	two := Entero with: 2.
	three:= Entero with: 3.
	four := Entero with: 4.
	five := Entero with: 5.
	eight := Entero with: 8.
	negativeOne := Entero with: -1.
	negativeTwo := Entero with: -2.
	
	oneHalf := one / two.
	oneFifth := one / five.
	twoFifth := two / five.
	twoTwentyfifth := two / (Entero with: 25).
	fiveHalfs := five / two.!

oneFifth + oneHalf!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:06:07' prior: 50877396 overrides: 50877268!
addFraccion: aFraccion 

	| numerator denominator |
	
	numerator := aFraccion numerator + (self * (aFraccion  denominator )) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:06:20'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:06:20'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:07:17'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:07:17'!
FAILURE!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:08:24' prior: 50878249 overrides: 50877268!
addFraccion: aFraccion 

	| numerator denominator |
	
	numerator := (aFraccion numerator) + (self * (aFraccion  denominator )) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:08:43'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:08:43'!
FAILURE!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:09:44' prior: 50878272 overrides: 50877268!
addFraccion: aFraccion 

	| numerator denominator |
	self halt .
	numerator := (aFraccion numerator) + (self * (aFraccion  denominator )) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:09:49'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:09:49'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:09:59'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 9/30/2020 20:09:59'!
FAILURE!
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 20:10:43' prior: 50877306 overrides: 50876715!
+ anAdder 	self halt .
	^ anAdder addEntero: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 20:13:55' prior: 50877317 overrides: 50876724!
/ aDivisor 	self halt .
	^ aDivisor divideByEntero: self! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 20:16:44' prior: 50878317 overrides: 50876724!
/ aDivisor 
	^ aDivisor divideByEntero: self .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:18:27' prior: 50877406 overrides: 50877250!
divideByEntero: anEntero

	^ Fraccion initializeWith: self over: anEntero .! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:19:44' prior: 50878329 overrides: 50877250!
divideByEntero: anEntero

	^ Fraccion initializeWith: self over: anEntero.! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 20:21:06' prior: 50878335 overrides: 50877250!
divideByEntero: anEntero

	^ Fraccion new initializeWith: self over: anEntero.! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 9/30/2020 22:17:11' prior: 50878288 overrides: 50877268!
addFraccion: aFraccion 

	| numerator denominator |
	numerator := (aFraccion numerator) + (self * (aFraccion  denominator )) .
	denominator := aFraccion denominator .
	^ numerator / denominator .! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 22:17:46' prior: 50878311 overrides: 50876715!
+ anAdder 	
	^ anAdder addEntero: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 9/30/2020 22:19:21' prior: 50878323 overrides: 50876724!
/ aDivisor 

	^ aDivisor divideByEntero: self .! !

----QUIT----(1 October 2020 09:02:40) CuisUniversity-4365.image priorSource: 17475219!

----STARTUP---- (1 October 2020 09:04:24) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\14-Numeros\Numero-Exercise.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:05:07'!
FAILURE!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 09:05:07'!
PASSED!

!classRemoval: #Fraccion stamp: 'eb 10/1/2020 09:09:46'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'eb 10/1/2020 09:09:46'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'eb 10/1/2020 09:09:47'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'eb 10/1/2020 09:09:47'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\14-Numeros\Numero-Exercise.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
ERROR!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 09:10:05'!
FAILURE!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 09:10:05'!
ERROR!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:10:05'!
ERROR!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 09:10:05'!
PASSED!

!classRemoval: #Fraccion stamp: 'eb 10/1/2020 09:22:15'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Entero stamp: 'eb 10/1/2020 09:22:15'!
Numero subclass: #Entero
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #Numero stamp: 'eb 10/1/2020 09:22:16'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

!classRemoval: #NumeroTest stamp: 'eb 10/1/2020 09:22:16'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\14-Numeros\Numero-Exercise.st----!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 09:22:33'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:10:24'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:10:25'!
PASSED!

!methodRemoval: Numero #addFraccion: stamp: 'eb 10/1/2020 14:10:52'!
addFraccion: aFraccion
	^self subclassResponsibility !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:11:16' prior: 50880725!
addEntero: aNumber

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:11:22' prior: 50880729!
addFraction:aNumber

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:11:28' prior: 50881510!
addEntero: anEntero

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:11:38'!
addFraccion:aNumber

	^self subclassResponsibility ! !

!methodRemoval: Numero #addFraction: stamp: 'eb 10/1/2020 14:11:38'!
addFraction:aNumber

	^self subclassResponsibility !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:11:45' prior: 50881525!
addFraccion: aFraccion

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:12:05' prior: 50880733!
divideByEntero: anEntero

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:12:15' prior: 50880737!
divideByFraccion: aFraccion

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:12:25' prior: 50880741!
subtractEntero: anEntero

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:12:31' prior: 50880745!
subtractFraccion: aFraccion

	^self subclassResponsibility ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:13:52' prior: 50880914 overrides: 50881520!
addEntero: anEntero 

	^self class with: (value + anEntero integerValue)! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:14:01' prior: 50880920 overrides: 50881534!
addFraccion: aFraccion 

	| numerator denominator |
	numerator := aFraccion numerator + (self * aFraccion  denominator ).
	denominator := aFraccion denominator .
	^ numerator / denominator ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:14:17' prior: 50881566 overrides: 50881534!
addFraccion: aFraccion 

	| numerator denominator |
	numerator := aFraccion numerator + (self * aFraccion  denominator).
	denominator := aFraccion denominator .
	^ numerator / denominator ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:14:34' prior: 50880929 overrides: 50881539!
divideByEntero: anEntero

	^Fraccion with: anEntero over: self ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:16:14' prior: 50880935 overrides: 50881544!
divideByFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator .
	denominator := (self class with: (value * (aFraccion denominator integerValue) )) .
	^Fraccion with: numerator over: denominator.! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:17:17' prior: 50881592 overrides: 50881544!
divideByFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator .
	denominator := (self class with: (value * (aFraccion denominator integerValue))) .
	^Fraccion with: numerator over: denominator.! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:17:22'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:17:22'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:17:23'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:17:24'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:17:24'!
PASSED!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:17:36' prior: 50880945 overrides: 50880761!
multiplyByEntero: anEntero 

	^self class with: (value * anEntero integerValue)! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:19:00' prior: 50880951 overrides: 50880765!
multiplyByFraccion: aFraccion

	| numerator |
	numerator := self class with: (value * (aFraccion numerator integerValue)).
	^ numerator / aFraccion denominator.! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:19:04'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:19:04'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:19:04'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:19:04'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:19:04'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:19:05'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:19:06'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:19:06'!
PASSED!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:23:19' prior: 50880964 overrides: 50881549!
subtractEntero: anEntero 

	^ self class with: (anEntero integerValue - value).! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:23:44' prior: 50880970 overrides: 50881554!
subtractFraccion: aFraccion	

	| numerator |
	numerator := aFraccion numerator - (self * aFraccion denominator) .
	^ numerator / aFraccion denominator .! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:33:52' prior: 50881119 overrides: 50881520!
addEntero: anEntero

	| selfNumerator adderDenominator |
	selfNumerator := self numerator .
	adderDenominator := self denominator .
	^ (anEntero * adderDenominator + selfNumerator ) / adderDenominator . ! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:34:01' prior: 50881918 overrides: 50881520!
addEntero: anEntero

	| selfNumerator selfDenominator |
	selfNumerator := self numerator .
	selfDenominator := self denominator .
	^ (anEntero * selfDenominator + selfNumerator ) / selfDenominator . ! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:34:57' prior: 50881129 overrides: 50881534!
addFraccion: aFraccion 

	| newNumerator newDenominator |	
	newDenominator := denominator * aFraccion denominator.
	newNumerator := (numerator * aFraccion denominator) + (denominator * aFraccion numerator).
	^ newNumerator / newDenominator .! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:35:04'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:35:05'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:36:10'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:36:11'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:36:12'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:36:12'!
PASSED!
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:37:36' prior: 50881140 overrides: 50881539!
divideByEntero: anEntero

	^ (self denominator * anEntero) / (self numerator).! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:37:53'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:37:54'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:37:54'!
PASSED!
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:38:10' prior: 50881149 overrides: 50881544!
divideByFraccion: aFraccion

	^(aFraccion numerator * denominator) / (numerator * aFraccion denominator) ! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:38:57' prior: 50881156 overrides: 50880761!
multiplyByEntero: anEntero

	|aMultiplierNumerator aMultiplierDenominator otherNumerator|
	aMultiplierNumerator := self numerator .
	aMultiplierDenominator := self denominator .
	otherNumerator := anEntero  * aMultiplierNumerator .
	^ otherNumerator / aMultiplierDenominator .! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:38:58'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:38:59'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:39:00'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:39:00'!
PASSED!
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:39:32' prior: 50882372 overrides: 50880761!
multiplyByEntero: anEntero

	^ (self numerator * anEntero) / (self denominator) .! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:39:39'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:39:40'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:39:41'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:39:41'!
PASSED!
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:40:01' prior: 50881168 overrides: 50880765!
multiplyByFraccion: aFraccion 

	^(numerator * aFraccion numerator) / (denominator * aFraccion denominator)! !
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:42:27' prior: 50881175 overrides: 50881549!
subtractEntero: anEntero
	
	^ (anEntero * self denominator) -  (self numerator)  / (self denominator).! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:42:32'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:42:33'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:42:33'!
PASSED!
!Fraccion methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:43:33' prior: 50881185 overrides: 50881554!
subtractFraccion: aFraccion 

	| newNumerator newDenominator |	
	newDenominator := denominator * aFraccion denominator.
	newNumerator := (denominator * aFraccion numerator) - (numerator * aFraccion denominator) .
	^  newNumerator / newDenominator .
! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:43:52'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:43:52'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:43:52'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:43:52'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:43:52'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:43:52'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:43:53'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:43:54'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:43:54'!
PASSED!
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:46:05' prior: 50880761!
multiplyByEntero: anEntero

	^self subclassResponsibility ! !
!Numero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:46:12' prior: 50880765!
multiplyByFraccion: aFraccion

	^self subclassResponsibility ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:46:41' prior: 50880804 overrides: 50880697!
* aMultiplier 

	^ aMultiplier multiplyByEntero: self.
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:46:57' prior: 50880821 overrides: 50880702!
+ anAdder 

	^ anAdder addEntero: self.
	

! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:47:05' prior: 50880826 overrides: 50880706!
- aSubtrahend 

	^aSubtrahend subtractEntero: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:47:13' prior: 50880842 overrides: 50880711!
/ aDivisor 

	^ aDivisor divideByEntero: self! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:47:18' prior: 50883119 overrides: 50880706!
- aSubtrahend 

	^ aSubtrahend subtractEntero: self.! !
!Entero methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:48:04' prior: 50880859!
fibonacci

	| one two |
	
	one := self class with: 1.
	two := self class with: 2.
	
	self isNegative ifTrue: [self error: self class negativeFibonacciErrorDescription ].	
	(self isZero or: [self isOne]) ifTrue: [^one].
	
	^ (self - one) fibonacci + (self - two) fibonacci
		! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:48:22'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:48:23'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:48:23'!
PASSED!
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:49:25' prior: 50881016 overrides: 50880697!
* aMultiplier 

	^aMultiplier multiplyByFraccion: self.! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:49:32' prior: 50881034 overrides: 50880702!
+ anAdder 

	^ anAdder addFraccion: self.
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:49:41' prior: 50881039 overrides: 50880706!
- aSubtrahend 
	
	^ aSubtrahend subtractFraccion: self.
	! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'eb 10/1/2020 14:49:47' prior: 50881058 overrides: 50880711!
/ aDivisor 

	^ aDivisor divideByFraccion: self! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:50:54'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:50:55'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:50:55'!
PASSED!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:52:59' prior: 50881586 overrides: 50881539!
divideByEntero: anEntero

	^anEntero/ self ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:53:09' prior: 50883445 overrides: 50881539!
divideByEntero: anEntero

	^Fraccion with: anEntero over: self ! !
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:53:11' prior: 50883450 overrides: 50881539!
divideByEntero: anEntero

	^Fraccion with: anEntero over: self .! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:53:15'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:53:16'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:53:16'!
PASSED!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:53:34' prior: 50881603 overrides: 50881544!
divideByFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator .
	denominator := (self class with: (value * (aFraccion denominator integerValue))) .
	^numerator/ denominator.! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:53:39'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:53:40'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:53:40'!
PASSED!
!Entero methodsFor: 'dependency inversion' stamp: 'eb 10/1/2020 14:53:45' prior: 50883598 overrides: 50881544!
divideByFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator .
	denominator := (self class with: (value * (aFraccion denominator integerValue))) .
	^ numerator/ denominator.! !

!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'eb 10/1/2020 14:53:58'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'eb 10/1/2020 14:53:59'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'eb 10/1/2020 14:54:00'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'eb 10/1/2020 14:54:00'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'eb 10/1/2020 14:54:00'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'eb 10/1/2020 14:54:00'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'eb 10/1/2020 14:54:00'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'eb 10/1/2020 14:54:00'!
PASSED!

----QUIT----(2 October 2020 01:01:58) CuisUniversity-4365.image priorSource: 17494930!

----STARTUP---- (4 October 2020 16:58:15) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\15-Stack\Stack-Exercise-With-If.st----!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 17:02:41'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 17:02:41'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 17:02:42'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 17:02:42'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\catedra\2020-2c\15-Stack\Stack-Exercise.st----!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 17:03:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 17:03:59'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 17:03:59'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 17:03:59'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\15-Stack\Stack-Exercise-With-If.st----!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 17:05:19'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50884456 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50884440!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50884451!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50884459!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50884444!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50884436!
initializeStack
	elements := OrderedCollection new! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:09:29'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:09:29'!
PASSED!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50884475 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 17:16:08'!
initializeStack
	elements := OrderedCollection new!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:16:11'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:16:11'!
PASSED!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50884575 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50884626!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50884632!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50884376!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:37:59'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:02'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:07'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:39'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:38:56'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:38:56'!
PASSED!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50884387!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

----End fileIn of C:\Program Files\CuisUniversity\Stack-Exercise.st----!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50884922!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50884935!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50885059!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:44:36'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:44:36'!
PASSED!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50884850!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50884947!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 17:47:27'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50884871!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50885144!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50884895!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:48:52'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:48:52'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:48:52'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:48:52'!
PASSED!
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50885131!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:49:11'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:49:11'!
PASSED!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50884856!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50884863!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50884880!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50885262!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 17:51:25'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 17:51:25'!
PASSED!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50884904!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 17:54:30'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 17:54:44'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50884983 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' overrides: 50885359!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 17:59:40'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' overrides: 50885031!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' overrides: 50885031!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50885384 overrides: 50885031!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50885389!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50885396 overrides: 50885031!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50885031 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50885359!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' overrides: 50884988!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' overrides: 50884992!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50885433 overrides: 50884992!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:09:52'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:10:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' overrides: 50885005!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50885461 overrides: 50885005!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 18:11:56'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50884988!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' overrides: 50884992!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50885477 overrides: 50884992!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50884992!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' overrides: 50885472!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' overrides: 50885005!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50885494 overrides: 50885005!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' overrides: 50885009!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50885503 overrides: 50885009!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' overrides: 50885000!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' overrides: 50885000!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' overrides: 50885009!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21'!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50885526!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50885414 overrides: 50885420!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 18:20:59'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50885482 overrides: 50885486!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50885552 overrides: 50885486!
pop
	
	^elements removeLast .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 18:32:55'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:32:55'!
ERROR!
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50885420 overrides: 16783533!
new
	^ EmptyStack new .! !

----STARTUP---- (4 October 2020 18:34:49) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:52'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:52'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:53'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:53'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:53'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:53'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 18:34:53'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 18:34:53'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 18:34:54'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 18:34:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:55'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 18:34:55'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 18:34:56'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 18:34:56'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 18:34:56'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:56'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:56'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:56'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50886188 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50886172!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50886183!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50886191!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50886176!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50886168!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50886208 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 18:34:57'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50886274 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50886293!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50886299!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50886102!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50886113!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50886041!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50886047!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50886054!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50886061!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50886069!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50886083!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50886092!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50886321!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50886329!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50886126!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50886310!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50886289 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50886244!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50886261!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50886248!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50886240 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50886253!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50886212!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50886280 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50886429!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50886442!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50886574!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50886357!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50886454!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 18:34:58'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50886378!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50886626!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50886402!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50886613!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50886363!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50886370!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50886387!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50886678!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50886411!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:34:58'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50886496 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' overrides: 50886747!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 18:34:58'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' overrides: 50886545!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' overrides: 50886545!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50886772 overrides: 50886545!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 18:34:58'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50886777!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50886784 overrides: 50886545!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50886545 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50886747!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' overrides: 50886501!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' overrides: 50886505!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50886821 overrides: 50886505!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:34:59'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:34:59'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' overrides: 50886518!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50886849 overrides: 50886518!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 18:34:59'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50886501!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' overrides: 50886505!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50886865 overrides: 50886505!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50886505!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' overrides: 50886860!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' overrides: 50886518!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50886882 overrides: 50886518!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' overrides: 50886522!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50886891 overrides: 50886522!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' overrides: 50886513!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' overrides: 50886513!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' overrides: 50886522!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21'!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50886914!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50886802 overrides: 50886808!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 18:34:59'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50886870 overrides: 50886874!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50886940 overrides: 50886874!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50886808 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50886767 overrides: 50886950!
new
	
	^ super super new initialize .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 18:36:06'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:36:06'!
ERROR!
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50886955 overrides: 50886950!
new
	
	^ ProtoObject new initialize .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:36:40'!
ERROR!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:36:56'!
ERROR!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 18:37:00'!
ERROR!

----STARTUP---- (4 October 2020 18:37:23) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:25'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 18:37:26'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 18:37:26'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 18:37:26'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 18:37:27'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:27'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 18:37:28'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 18:37:28'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 18:37:28'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 18:37:29'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:29'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50887655 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50887639!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50887650!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50887658!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50887643!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50887635!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50887675 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 18:37:30'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50887741 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50887760!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50887766!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50887569!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50887580!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50887508!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50887514!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50887521!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50887528!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50887536!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50887550!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50887559!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50887788!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50887796!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50887593!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50887777!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50887756 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50887711!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50887728!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50887715!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50887707 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50887720!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50887679!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50887747 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50887896!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50887909!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50888041!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50887824!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50887921!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 18:37:30'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50887845!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50888093!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50887869!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50888080!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50887830!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50887837!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50887854!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50888145!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50887878!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:30'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50887963 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' overrides: 50888214!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 18:37:30'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' overrides: 50888012!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' overrides: 50888012!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50888239 overrides: 50888012!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 18:37:31'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50888244!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50888251 overrides: 50888012!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50888012 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50888214!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' overrides: 50887968!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' overrides: 50887972!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50888288 overrides: 50887972!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:37:31'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:37:31'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' overrides: 50887985!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50888316 overrides: 50887985!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 18:37:31'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50887968!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' overrides: 50887972!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50888332 overrides: 50887972!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50887972!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' overrides: 50888327!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' overrides: 50887985!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50888349 overrides: 50887985!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' overrides: 50887989!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50888358 overrides: 50887989!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' overrides: 50887980!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' overrides: 50887980!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' overrides: 50887989!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21'!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50888381!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50888269 overrides: 50888275!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 18:37:31'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50888337 overrides: 50888341!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50888407 overrides: 50888341!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50888275 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:31'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:31'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50888057!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50888130!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50888137!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50888103!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50888159!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50888113!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50888175!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50887888!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50888031!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50888049!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:31'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:31'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:31'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:31'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50888327!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50888341!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50887980!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50887985 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50887989!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:32'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:32'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50888417 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:32'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:32'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 18:37:32'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 18:37:32'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 18:37:33'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 18:37:33'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:33'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 18:37:34'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 18:37:34'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 18:37:34'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 18:37:35'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:35'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50889017 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50889001!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50889012!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50889020!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50889005!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50888997!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50889037 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 18:37:36'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50889103 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50889122!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50889128!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50888931!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50888942!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50888870!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50888876!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50888883!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50888890!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50888898!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50888912!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50888921!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50889150!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50889158!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50888955!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50889139!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50889118 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50889073!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50889090!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50889077!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50889069 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50889082!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50889041!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50889109 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50889258!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50889271!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50889403!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50889186!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50889283!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 18:37:36'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50889207!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50889455!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50889231!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50889442!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50889192!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50889199!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50889216!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50889507!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50889240!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:36'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:37'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 18:37:37'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50889325 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50888279 overrides: 50889576!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 18:37:37'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50888234 overrides: 50889374!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50888396 overrides: 50889374!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50889602 overrides: 50889374!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 18:37:37'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50889607!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50889614 overrides: 50889374!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50889374 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50889576!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50888284 overrides: 50889330!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50888293 overrides: 50889334!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50889651 overrides: 50889334!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:37:37'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 18:37:37'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50888311!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50888320 overrides: 50889347!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50889679 overrides: 50889347!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 18:37:37'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50889330!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50888412 overrides: 50889334!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50889695 overrides: 50889334!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50889334!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50888345 overrides: 50889690!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50888354 overrides: 50889347!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50889713 overrides: 50889347!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50888363 overrides: 50889351!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50889723 overrides: 50889351!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50888367 overrides: 50889342!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50888372 overrides: 50889342!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50888377 overrides: 50889351!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50888388!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50889750!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50889632 overrides: 50889638!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 18:37:37'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50889700 overrides: 50889704!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50889776 overrides: 50889704!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50889638 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50889597 overrides: 50889786!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50889791 overrides: 50889786!
new
	
	^ ProtoObject new initialize .! !

!methodRemoval: OOStack class #new stamp: 'eb 10/4/2020 18:39:16'!
new
	^ EmptyStack new .!
!OOStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:40:56' overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:13' prior: 50889797 overrides: 50889804!
new
	
	^ ProtoObject new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:25' prior: 50889809 overrides: 50889804!
new
	
	^ nil .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 18:41:28'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 18:41:28'!
ERROR!
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:49:47' prior: 50889733 overrides: 50889342!
push: anElement
	
	^ NotEmptyStack new initializeWith: anElement .! !

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\15-Stack\Stack-Exercise-With-If.st----!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 19:31:19'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmptyStack stamp: 'eb 10/4/2020 19:31:19'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #EmptyStack stamp: 'eb 10/4/2020 19:31:19'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 19:31:20'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 19:31:20'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 19:31:20'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\15-Stack\Stack-Exercise-With-If.st----!

Object subclass: #StackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:33:15'!
Object subclass: #StackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

StackTop subclass: #Empty
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

StackTop subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #Empty category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:33:37'!
StackTop subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

StackTop subclass: #NotEmpty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmpty category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:33:46'!
StackTop subclass: #NotEmpty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:33:58'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50890253 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50890237!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50890248!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50890256!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50890241!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50890233!
initializeStack
	elements := OrderedCollection new! !

Object subclass: #OOStack
	instanceVariableNames: 'elements top'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:34:05'!
Object subclass: #OOStack
	instanceVariableNames: 'elements top'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 19:34:23' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:34:23' prior: 50890272 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 19:34:23'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 19:34:59' prior: 50890388 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	top := StackTop new .! !

StackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:35:27'!
StackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

StackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:35:31'!
StackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmpty stamp: 'eb 10/4/2020 19:35:37'!
StackTop subclass: #NotEmpty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #Empty stamp: 'eb 10/4/2020 19:35:41'!
StackTop subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 19:35:51' prior: 50890403 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	top := EmptyStackTop new .! !
!StackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:36:27'!
pop
	
	self subclassResponsibility .! !
!EmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:37:03' overrides: 50890449!
pop
	
	^ 'Soy vacio, amigo' .! !
!NotEmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:37:15' overrides: 50890449!
pop
	
	^ value .! !
!StackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:37:42'!
popFrom: aStack
	
	self subclassResponsibility .! !

!methodRemoval: StackTop #pop stamp: 'eb 10/4/2020 19:37:47'!
pop
	
	self subclassResponsibility .!
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:37:58' overrides: 50890460!
popFrom: aStack
	
	^ 'Soy vacio, amigo' .! !

!methodRemoval: EmptyStackTop #pop stamp: 'eb 10/4/2020 19:38:01'!
pop
	
	^ 'Soy vacio, amigo' .!
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:38:09' overrides: 50890460!
popFrom: aStack
	
	^ value .! !

!methodRemoval: NotEmptyStackTop #pop stamp: 'eb 10/4/2020 19:38:13'!
pop
	
	^ value .!
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:38:37' prior: 50890476 overrides: 50890460!
popFrom: aStack

	aStack elements removeLast.
	
	^ value .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:40:05' prior: 50890363!
pop	
	self top popFrom: self .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:40:17' prior: 50890355!
top
	^ self top value .! !

!classRenamed: #StackTop as: #OOStackTop stamp: 'eb 10/4/2020 19:45:51'!
Smalltalk renameClassNamed: #StackTop as: #OOStackTop!
!OOStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:48:41'!
topValue
	
	self subclassResponsibility .! !
!EmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:49:11' overrides: 50890500!
topValue
	
	^ 'error, no tengo valor'.! !
!NotEmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:49:35' overrides: 50890500!
topValue
	
	^ value .! !

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 19:50:04'!
Object subclass: #OOStack
	instanceVariableNames: 'elements topElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:50:04' prior: 50890444 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	topElement := EmptyStackTop new .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:51:15' prior: 50890350!
push: anElement 
	elements add: anElement.
	topElement  := NotEmptyStackTop new initializeWith: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:51:46' prior: 50890493!
top
	^ topElement topValue .! !
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:52:23'!
initializeWith: aValue
	
	value := aValue .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:52:51' prior: 50890489!
pop	
	topElement popFrom: self .! !
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:54:56' prior: 50890468 overrides: 50890460!
popFrom: aStack
	
	^ aStack stackEmptyErrorDescription .! !
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:55:22' prior: 50890505 overrides: 50890500!
topValue
	
	^ OOStack stackEmptyErrorDescription .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 19:55:31'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 19:55:31'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 19:55:31'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:55:31'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 19:55:31'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:55:31'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 19:55:31'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:55:31'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 19:55:31'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:55:31'!
FAILURE!
!OOStack methodsFor: 'nil' stamp: 'eb 10/4/2020 19:56:15'!
rompeEncapsulamientoYDameElements
	
	^ elements .! !
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:56:24' prior: 50890484 overrides: 50890460!
popFrom: aStack

	aStack rompeEncapsulamientoYDameElements removeLast.
	
	^ value .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 19:56:28'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 19:56:28'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 19:56:28'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:56:28'!
FAILURE!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 19:56:28'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:56:28'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 19:56:28'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:56:28'!
ERROR!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 19:56:28'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:56:28'!
FAILURE!
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:57:10' prior: 50890549 overrides: 50890460!
popFrom: aStack
	
	^ aStack class stackEmptyErrorDescription .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 19:57:13'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 19:57:13'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 19:57:13'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:57:13'!
FAILURE!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 19:57:13'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:57:13'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 19:57:13'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:57:13'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 19:57:13'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:57:13'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 19:58:19'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 19:58:19'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 19:58:19'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:58:19'!
FAILURE!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 19:58:19'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:58:19'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 19:58:19'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:58:19'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 19:58:19'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 19:58:19'!
FAILURE!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:58:20'!
FAILURE!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:58:44'!
FAILURE!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:58:57'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 19:59:01'!
FAILURE!

----STARTUP---- (4 October 2020 20:00:45) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:47'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:47'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:48'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:00:48'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:00:49'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:00:49'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:00:49'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:49'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:49'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:50'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:00:50'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:00:50'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:00:51'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:00:51'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:51'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:51'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:51'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:51'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:51'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:51'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50891311 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50891295!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50891306!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50891314!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50891299!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50891291!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50891331 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:00:52'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50891397 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50891416!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50891422!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50891225!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50891236!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50891164!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50891170!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50891177!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50891184!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50891192!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50891206!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50891215!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50891444!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50891452!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50891249!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50891433!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50891412 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50891367!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50891384!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50891371!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50891363 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50891376!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50891335!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50891403 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50891552!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50891565!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50891697!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50891480!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50891577!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:00:53'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50891501!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50891749!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50891525!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50891736!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50891486!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50891493!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50891510!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50891801!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50891534!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:53'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:53'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:53'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:53'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50891619 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' overrides: 50891870!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:00:53'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' overrides: 50891668!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' overrides: 50891668!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50891895 overrides: 50891668!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:00:53'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50891900!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50891907 overrides: 50891668!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50891668 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50891870!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' overrides: 50891624!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' overrides: 50891628!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50891944 overrides: 50891628!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:00:53'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:00:53'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' overrides: 50891641!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50891972 overrides: 50891641!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:00:53'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50891624!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' overrides: 50891628!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50891988 overrides: 50891628!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50891628!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' overrides: 50891983!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' overrides: 50891641!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50892005 overrides: 50891641!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' overrides: 50891645!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50892014 overrides: 50891645!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' overrides: 50891636!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' overrides: 50891636!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' overrides: 50891645!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21'!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50892037!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50891925 overrides: 50891931!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:00:54'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50891993 overrides: 50891997!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50892063 overrides: 50891997!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50891931 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50891713!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50891786!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50891793!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50891759!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50891815!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50891769!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50891831!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50891544!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50891687!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50891705!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50891983!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50891997!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50891636!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50891641 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50891645!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50892073 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:54'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:00:54'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:00:55'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:00:55'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:00:55'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:55'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:55'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:00:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:00:56'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:00:57'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:00:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:57'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:57'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:57'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:57'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50892673 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50892657!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50892668!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50892676!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50892661!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50892653!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50892693 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:00:58'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50892759 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50892778!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50892784!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50892587!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50892598!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50892526!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50892532!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50892539!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50892546!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50892554!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50892568!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50892577!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50892806!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50892814!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50892611!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50892795!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50892774 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50892729!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50892746!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50892733!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50892725 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50892738!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50892697!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50892765 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50892914!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50892927!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50893059!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50892842!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50892939!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:00:59'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50892863!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50893111!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50892887!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50893098!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50892848!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50892855!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50892872!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50893163!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50892896!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:59'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:59'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:59'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:00:59'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50892981 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50891935 overrides: 50893232!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:00:59'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50891890 overrides: 50893030!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50892052 overrides: 50893030!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50893258 overrides: 50893030!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:00:59'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50893263!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50893270 overrides: 50893030!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50893030 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50893232!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50891940 overrides: 50892986!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50891949 overrides: 50892990!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50893307 overrides: 50892990!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:00:59'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:00:59'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50891967!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50891976 overrides: 50893003!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50893335 overrides: 50893003!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:00:59'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50892986!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50892068 overrides: 50892990!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50893351 overrides: 50892990!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50892990!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50892001 overrides: 50893346!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50892010 overrides: 50893003!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50893369 overrides: 50893003!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50892019 overrides: 50893007!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50893379 overrides: 50893007!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50892023 overrides: 50892998!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50892028 overrides: 50892998!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50892033 overrides: 50893007!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50892044!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50893406!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50893288 overrides: 50893294!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:00:59'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50893356 overrides: 50893360!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50893432 overrides: 50893360!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50893294 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50893253 overrides: 50893442!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50893447 overrides: 50893442!
new
	
	^ ProtoObject new initialize .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50893075!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50893148!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50893155!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50893121!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50893177!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50893131!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50893193!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50892906!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50893049!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50893067!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50893346!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50893360!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50892998!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50893003 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50893007!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50893442 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:00'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:01:00'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:01:01'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:01:01'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:01:01'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:01'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:01'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:02'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:01:02'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:01:03'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:01:03'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:01:03'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:03'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:03'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:04'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50894054 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50894038!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50894049!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50894057!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50894042!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50894034!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50894074 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:01:05'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50894140 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50894159!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50894165!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50893968!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50893979!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50893907!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50893913!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50893920!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50893927!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50893935!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50893949!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50893958!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50894187!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50894195!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50893992!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50894176!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50894155 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50894110!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50894127!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50894114!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50894106 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50894119!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50894078!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50894146 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50894295!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50894308!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50894440!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50894223!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50894320!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:01:05'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50894244!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50894492!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50894268!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50894479!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50894229!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50894236!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50894253!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50894544!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50894277!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:05'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50894362 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50893298 overrides: 50894613!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:01:06'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50893453 overrides: 50894411!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50893421 overrides: 50894411!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50894639 overrides: 50894411!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:01:06'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50894644!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50894651 overrides: 50894411!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50894411 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50894613!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50893303 overrides: 50894367!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50893312 overrides: 50894371!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50894688 overrides: 50894371!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:01:06'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:01:06'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50893330!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50893339 overrides: 50894384!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50894716 overrides: 50894384!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:01:06'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50894367!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50893437 overrides: 50894371!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50894732 overrides: 50894371!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50894371!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50893365 overrides: 50894727!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50893374 overrides: 50894384!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50894750 overrides: 50894384!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50893384 overrides: 50894388!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50894760 overrides: 50894388!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50893389 overrides: 50894379!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50893395 overrides: 50894379!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50893401 overrides: 50894388!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50893413!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50894787!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50894669 overrides: 50894675!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:01:06'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50894737 overrides: 50894741!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50894813 overrides: 50894741!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50894675 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50894456!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50894529!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50894536!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50894502!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50894558!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50894512!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50894574!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50894287!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50894430!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50894448!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:06'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:07'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:07'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50894727!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50894741!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50894379!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50894384 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50894388!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:07'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:07'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50894823 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:07'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:07'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:01:07'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:01:07'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:01:08'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:01:08'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:08'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:01:09'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:01:09'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:01:09'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:01:10'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:10'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50895423 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50895407!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50895418!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50895426!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50895411!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50895403!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50895443 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:01:11'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50895509 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50895528!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50895534!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50895337!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50895348!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50895276!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50895282!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50895289!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50895296!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50895304!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50895318!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50895327!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50895556!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50895564!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50895361!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50895545!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50895524 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50895479!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50895496!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50895483!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50895475 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50895488!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50895447!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50895515 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:11'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50895664!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50895677!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50895809!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50895592!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50895689!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:01:11'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50895613!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50895861!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50895637!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50895848!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50895598!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50895605!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50895622!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50895913!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50895646!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:12'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:12'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:12'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:12'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50895731 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50894679 overrides: 50895982!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:01:12'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50894634 overrides: 50895780!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50894802 overrides: 50895780!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50896008 overrides: 50895780!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:01:12'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50896013!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50896020 overrides: 50895780!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50895780 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50895982!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50894684 overrides: 50895736!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50894693 overrides: 50895740!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50896057 overrides: 50895740!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:01:12'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:01:12'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50894711!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50894720 overrides: 50895753!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50896085 overrides: 50895753!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:01:12'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50895736!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50894818 overrides: 50895740!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50896101 overrides: 50895740!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50895740!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50894746 overrides: 50896096!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50894755 overrides: 50895753!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50896119 overrides: 50895753!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50894765 overrides: 50895757!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50896129 overrides: 50895757!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50894770 overrides: 50895748!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50894776 overrides: 50895748!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50894782 overrides: 50895757!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50894794!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50896156!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50896038 overrides: 50896044!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:01:12'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50896106 overrides: 50896110!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50896182 overrides: 50896110!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50896044 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50896003 overrides: 50896192!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50896197 overrides: 50896192!
new
	
	^ ProtoObject new initialize .! !

!methodRemoval: OOStack class #new stamp: 'eb 10/4/2020 20:01:12'!
new
	^ EmptyStack new .!
!OOStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:40:56' overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:13' prior: 50896203 overrides: 50896210!
new
	
	^ ProtoObject new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:25' prior: 50896215 overrides: 50896210!
new
	
	^ nil .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:49:47' prior: 50896139 overrides: 50895748!
push: anElement
	
	^ NotEmptyStack new initializeWith: anElement .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:12'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:12'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50895825!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50895898!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50895905!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50895871!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50895927!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50895881!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50895943!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50895656!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50895799!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50895817!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50896096!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50896110!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50895748!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50895753 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50895757!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50896210 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:01:13'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----STARTUP---- (4 October 2020 20:02:13) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:14'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:14'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:15'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:15'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:16'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:16'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:16'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:16'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:16'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:17'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:17'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:17'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:18'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:18'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:18'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:18'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:18'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:18'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:18'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:18'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50897035 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50897019!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50897030!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50897038!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50897023!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50897015!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50897055 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:19'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50897121 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50897140!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50897146!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50896949!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50896960!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50896888!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50896894!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50896901!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50896908!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50896916!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50896930!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50896939!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50897168!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50897176!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50896973!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50897157!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50897136 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50897091!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50897108!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50897095!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50897087 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50897100!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50897059!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50897127 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:19'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50897276!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50897289!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50897421!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50897204!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50897301!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:19'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50897225!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50897473!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50897249!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50897460!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50897210!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50897217!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50897234!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50897525!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50897258!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:20'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:20'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:20'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:20'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50897343 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' overrides: 50897594!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:20'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' overrides: 50897392!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' overrides: 50897392!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50897619 overrides: 50897392!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:20'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50897624!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50897631 overrides: 50897392!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50897392 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50897594!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' overrides: 50897348!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' overrides: 50897352!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50897668 overrides: 50897352!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:20'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:20'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' overrides: 50897365!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50897696 overrides: 50897365!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:20'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50897348!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' overrides: 50897352!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50897712 overrides: 50897352!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50897352!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' overrides: 50897707!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' overrides: 50897365!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50897729 overrides: 50897365!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' overrides: 50897369!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50897738 overrides: 50897369!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' overrides: 50897360!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' overrides: 50897360!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' overrides: 50897369!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21'!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50897761!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50897649 overrides: 50897655!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:20'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50897717 overrides: 50897721!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50897787 overrides: 50897721!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50897655 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:20'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:20'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50897437!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50897510!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50897517!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50897483!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50897539!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50897493!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50897555!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50897268!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50897411!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50897429!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50897707!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50897721!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50897360!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50897365 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50897369!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50897797 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:21'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:21'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:21'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:22'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:22'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:22'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:23'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:23'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:23'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:23'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50898397 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50898381!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50898392!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50898400!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50898385!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50898377!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50898417 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:24'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50898483 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50898502!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50898508!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50898311!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50898322!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:24'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50898250!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50898256!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50898263!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50898270!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50898278!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50898292!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50898301!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50898530!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50898538!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50898335!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50898519!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50898498 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50898453!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50898470!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50898457!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50898449 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50898462!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50898421!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50898489 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50898638!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50898651!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50898783!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50898566!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50898663!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:25'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50898587!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50898835!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50898611!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50898822!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50898572!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50898579!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50898596!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50898887!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50898620!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:25'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50898705 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50897659 overrides: 50898956!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:25'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50897614 overrides: 50898754!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50897776 overrides: 50898754!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50898982 overrides: 50898754!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:25'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50898987!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50898994 overrides: 50898754!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50898754 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50898956!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50897664 overrides: 50898710!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50897673 overrides: 50898714!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50899031 overrides: 50898714!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:25'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:25'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50897691!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50897700 overrides: 50898727!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50899059 overrides: 50898727!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:26'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50898710!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50897792 overrides: 50898714!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50899075 overrides: 50898714!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50898714!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50897725 overrides: 50899070!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50897734 overrides: 50898727!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50899093 overrides: 50898727!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50897743 overrides: 50898731!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50899103 overrides: 50898731!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50897747 overrides: 50898722!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50897752 overrides: 50898722!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50897757 overrides: 50898731!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50897768!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50899130!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50899012 overrides: 50899018!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:26'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50899080 overrides: 50899084!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50899156 overrides: 50899084!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50899018 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50898977 overrides: 50899166!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50899171 overrides: 50899166!
new
	
	^ ProtoObject new initialize .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50898799!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50898872!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50898879!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50898845!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50898901!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50898855!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50898917!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50898630!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50898773!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50898791!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50899070!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50899084!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50898722!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50898727 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50898731!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50899166 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:26'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:27'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:27'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:27'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:27'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:27'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:27'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:28'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:28'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:28'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:28'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:29'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:29'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50899778 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50899762!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50899773!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50899781!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50899766!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50899758!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50899798 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:30'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50899864 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50899883!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50899889!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50899692!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50899703!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50899631!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50899637!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50899644!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50899651!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50899659!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50899673!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50899682!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50899911!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50899919!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50899716!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50899900!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50899879 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50899834!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50899851!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50899838!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50899830 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50899843!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50899802!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50899870 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50900019!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50900032!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50900164!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50899947!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50900044!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:30'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50899968!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50900216!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50899992!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50900203!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50899953!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50899960!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50899977!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50900268!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50900001!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:30'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50900086 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50899022 overrides: 50900337!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:31'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50899177 overrides: 50900135!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50899145 overrides: 50900135!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50900363 overrides: 50900135!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:31'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50900368!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50900375 overrides: 50900135!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50900135 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50900337!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50899027 overrides: 50900091!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50899036 overrides: 50900095!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50900412 overrides: 50900095!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:31'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:31'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50899054!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50899063 overrides: 50900108!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50900440 overrides: 50900108!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:31'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50900091!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50899161 overrides: 50900095!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50900456 overrides: 50900095!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50900095!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50899089 overrides: 50900451!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50899098 overrides: 50900108!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50900474 overrides: 50900108!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50899108 overrides: 50900112!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50900484 overrides: 50900112!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50899113 overrides: 50900103!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50899119 overrides: 50900103!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50899125 overrides: 50900112!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50899137!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50900511!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50900393 overrides: 50900399!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:31'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50900461 overrides: 50900465!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50900537 overrides: 50900465!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50900399 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50900180!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50900253!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50900260!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50900226!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50900282!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50900236!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50900298!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50900011!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50900154!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50900172!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50900451!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50900465!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50900103!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50900108 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50900112!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:31'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50900547 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:32'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:32'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:32'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:32'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:32'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:33'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:33'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:33'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:33'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:34'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:34'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:34'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:34'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:34'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:34'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:34'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:34'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50901147 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50901131!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50901142!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50901150!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50901135!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50901127!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50901167 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:35'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50901233 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50901252!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50901258!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50901061!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50901072!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50901000!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50901006!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50901013!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50901020!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50901028!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50901042!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50901051!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50901280!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50901288!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50901085!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50901269!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50901248 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50901203!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50901220!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50901207!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50901199 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50901212!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50901171!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50901239 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:35'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50901388!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50901401!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50901533!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50901316!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50901413!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:35'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50901337!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50901585!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50901361!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50901572!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50901322!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50901329!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50901346!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50901637!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50901370!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:36'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:36'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:36'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:36'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50901455 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50900403 overrides: 50901706!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:36'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50900358 overrides: 50901504!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50900526 overrides: 50901504!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50901732 overrides: 50901504!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:36'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50901737!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50901744 overrides: 50901504!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50901504 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50901706!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50900408 overrides: 50901460!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50900417 overrides: 50901464!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50901781 overrides: 50901464!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:36'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:36'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50900435!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50900444 overrides: 50901477!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50901809 overrides: 50901477!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:36'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50901460!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50900542 overrides: 50901464!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50901825 overrides: 50901464!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50901464!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50900470 overrides: 50901820!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50900479 overrides: 50901477!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50901843 overrides: 50901477!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50900489 overrides: 50901481!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50901853 overrides: 50901481!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50900494 overrides: 50901472!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50900500 overrides: 50901472!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50900506 overrides: 50901481!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50900518!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50901880!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50901762 overrides: 50901768!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:36'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50901830 overrides: 50901834!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50901906 overrides: 50901834!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50901768 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50901727 overrides: 50901916!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50901921 overrides: 50901916!
new
	
	^ ProtoObject new initialize .! !

!methodRemoval: OOStack class #new stamp: 'eb 10/4/2020 20:02:36'!
new
	^ EmptyStack new .!
!OOStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:40:56' overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:13' prior: 50901927 overrides: 50901934!
new
	
	^ ProtoObject new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:25' prior: 50901939 overrides: 50901934!
new
	
	^ nil .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:49:47' prior: 50901863 overrides: 50901472!
push: anElement
	
	^ NotEmptyStack new initializeWith: anElement .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:36'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:36'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50901549!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50901622!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50901629!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50901595!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50901651!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50901605!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50901667!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50901380!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50901523!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50901541!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50901820!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50901834!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50901472!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50901477 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50901481!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50901934 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:37'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:37'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmptyStack stamp: 'eb 10/4/2020 20:02:37'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #EmptyStack stamp: 'eb 10/4/2020 20:02:38'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:38'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:38'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:38'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:38'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:38'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #StackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #StackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #StackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #Empty category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
StackTop subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #Empty category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
StackTop subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmpty category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
StackTop subclass: #NotEmpty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmpty category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
StackTop subclass: #NotEmpty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50902368 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50902352!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50902363!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50902371!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50902356!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:33:58' prior: 50902348!
initializeStack
	elements := OrderedCollection new! !

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #OOStack
	instanceVariableNames: 'elements top'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:39'!
Object subclass: #OOStack
	instanceVariableNames: 'elements top'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 19:34:23' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:34:23' prior: 50902388 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:40'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 19:34:59' prior: 50902509 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	top := StackTop new .! !

!classDefinition: #EmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:40'!
StackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:40'!
StackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:40'!
StackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:40'!
StackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmpty stamp: 'eb 10/4/2020 20:02:40'!
StackTop subclass: #NotEmpty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #Empty stamp: 'eb 10/4/2020 20:02:40'!
StackTop subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 19:35:51' prior: 50902524 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	top := EmptyStackTop new .! !
!StackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:36:27'!
pop
	
	self subclassResponsibility .! !
!EmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:37:03' overrides: 50902576!
pop
	
	^ 'Soy vacio, amigo' .! !
!NotEmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:37:15' overrides: 50902576!
pop
	
	^ value .! !
!StackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:37:42'!
popFrom: aStack
	
	self subclassResponsibility .! !

!methodRemoval: StackTop #pop stamp: 'eb 10/4/2020 20:02:40'!
pop
	
	self subclassResponsibility .!
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:37:58' overrides: 50902587!
popFrom: aStack
	
	^ 'Soy vacio, amigo' .! !

!methodRemoval: EmptyStackTop #pop stamp: 'eb 10/4/2020 20:02:40'!
pop
	
	^ 'Soy vacio, amigo' .!
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:38:09' overrides: 50902587!
popFrom: aStack
	
	^ value .! !

!methodRemoval: NotEmptyStackTop #pop stamp: 'eb 10/4/2020 20:02:40'!
pop
	
	^ value .!
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:38:37' prior: 50902603 overrides: 50902587!
popFrom: aStack

	aStack elements removeLast.
	
	^ value .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:40:05' prior: 50902482!
pop	
	self top popFrom: self .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:40:17' prior: 50902474!
top
	^ self top value .! !
!EmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:49:11'!
topValue
	
	^ 'error, no tengo valor'.! !
!NotEmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 19:49:35'!
topValue
	
	^ value .! !

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:40'!
Object subclass: #OOStack
	instanceVariableNames: 'elements topElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:50:04' prior: 50902571 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	topElement := EmptyStackTop new .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:51:15' prior: 50902469!
push: anElement 
	elements add: anElement.
	topElement  := NotEmptyStackTop new initializeWith: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:51:46' prior: 50902620!
top
	^ topElement topValue .! !
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:52:23'!
initializeWith: aValue
	
	value := aValue .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 19:52:51' prior: 50902616!
pop	
	topElement popFrom: self .! !
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:54:56' prior: 50902595 overrides: 50902587!
popFrom: aStack
	
	^ aStack stackEmptyErrorDescription .! !
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:55:22' prior: 50902623!
topValue
	
	^ OOStack stackEmptyErrorDescription .! !
!OOStack methodsFor: 'nil' stamp: 'eb 10/4/2020 19:56:15'!
rompeEncapsulamientoYDameElements
	
	^ elements .! !
!NotEmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:56:24' prior: 50902611 overrides: 50902587!
popFrom: aStack

	aStack rompeEncapsulamientoYDameElements removeLast.
	
	^ value .! !
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 19:57:10' prior: 50902666 overrides: 50902587!
popFrom: aStack
	
	^ aStack class stackEmptyErrorDescription .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50902221!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50902227!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50902234!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50902241!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50902249!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50902263!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50902272!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50902282!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50902293!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50902306!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50902465!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50902661!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50902645!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50902461 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50902652!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50902515 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50902392!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:41'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:41'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:41'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:42'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:42'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:42'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:42'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:43'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:43'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:43'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:43'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:44'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:44'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50903290 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50903274!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50903285!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50903293!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50903278!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50903270!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50903310 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:45'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50903376 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50903395!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50903401!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50903204!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50903215!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50903143!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50903149!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50903156!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50903163!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50903171!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50903185!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50903194!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50903423!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50903431!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50903228!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50903412!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50903391 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50903346!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50903363!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50903350!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50903342 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50903355!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50903314!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50903382 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50903531!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50903544!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50903676!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50903459!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50903556!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:45'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50903480!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50903728!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50903504!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50903715!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50903465!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50903472!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50903489!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50903780!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50903513!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:45'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50903598 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' overrides: 50903849!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:45'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' overrides: 50903647!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' overrides: 50903647!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50903874 overrides: 50903647!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:46'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50903879!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50903886 overrides: 50903647!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50903647 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50903849!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' overrides: 50903603!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' overrides: 50903607!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50903923 overrides: 50903607!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:46'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:46'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' overrides: 50903620!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50903951 overrides: 50903620!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:46'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50903603!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' overrides: 50903607!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50903967 overrides: 50903607!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50903607!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' overrides: 50903962!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' overrides: 50903620!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50903984 overrides: 50903620!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' overrides: 50903624!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50903993 overrides: 50903624!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' overrides: 50903615!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' overrides: 50903615!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' overrides: 50903624!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21'!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50904016!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50903904 overrides: 50903910!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:46'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50903972 overrides: 50903976!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50904042 overrides: 50903976!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50903910 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:46'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:46'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50903692!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50903765!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50903772!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50903738!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50903794!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50903748!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50903810!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50903523!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50903666!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50903684!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:46'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:46'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:46'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:46'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50903962!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50903976!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50903615!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50903620 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50903624!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:47'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:47'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50904052 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:47'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:47'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:47'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:47'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:47'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:48'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:48'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:48'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:49'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:49'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:49'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:49'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:49'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50904652 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50904636!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50904647!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50904655!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50904640!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50904632!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50904672 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:50'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50904738 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50904757!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50904763!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50904566!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50904577!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50904505!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50904511!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50904518!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50904525!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50904533!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50904547!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50904556!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50904785!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50904793!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50904590!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50904774!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50904753 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50904708!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50904725!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50904712!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50904704 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50904717!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50904676!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50904744 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:50'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:51'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50904893!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50904906!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50905038!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50904821!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50904918!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:51'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50904842!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50905090!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50904866!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50905077!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50904827!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50904834!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50904851!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50905142!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50904875!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:51'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:51'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:51'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:51'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50904960 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50903914 overrides: 50905211!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:51'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50903869 overrides: 50905009!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50904031 overrides: 50905009!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50905237 overrides: 50905009!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:51'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50905242!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50905249 overrides: 50905009!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50905009 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50905211!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50903919 overrides: 50904965!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50903928 overrides: 50904969!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50905286 overrides: 50904969!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:51'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:51'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50903946!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50903955 overrides: 50904982!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50905314 overrides: 50904982!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:51'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50904965!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50904047 overrides: 50904969!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50905330 overrides: 50904969!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50904969!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50903980 overrides: 50905325!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50903989 overrides: 50904982!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50905348 overrides: 50904982!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50903998 overrides: 50904986!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50905358 overrides: 50904986!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50904002 overrides: 50904977!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50904007 overrides: 50904977!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50904012 overrides: 50904986!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50904023!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50905385!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50905267 overrides: 50905273!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:51'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50905335 overrides: 50905339!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50905411 overrides: 50905339!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50905273 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50905232 overrides: 50905421!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50905426 overrides: 50905421!
new
	
	^ ProtoObject new initialize .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50905054!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50905127!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50905134!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50905100!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50905156!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50905110!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50905172!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50904885!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50905028!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50905046!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50905325!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50905339!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50904977!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50904982 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50904986!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50905421 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:52'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:52'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:53'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:53'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:53'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:54'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:54'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:54'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:54'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:55'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:55'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:55'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:55'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50906033 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50906017!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50906028!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50906036!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50906021!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50906013!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50906053 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:02:56'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50906119 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50906138!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50906144!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50905947!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50905958!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50905886!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50905892!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50905899!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50905906!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50905914!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50905928!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50905937!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50906166!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50906174!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50905971!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50906155!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50906134 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50906089!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50906106!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50906093!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50906085 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50906098!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50906057!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50906125 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:56'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50906274!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50906287!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50906419!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50906202!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50906299!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:02:56'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50906223!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50906471!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50906247!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50906458!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50906208!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50906215!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50906232!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50906523!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50906256!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50906341 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50905277 overrides: 50906592!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:02:57'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50905432 overrides: 50906390!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50905400 overrides: 50906390!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50906618 overrides: 50906390!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:02:57'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50906623!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50906630 overrides: 50906390!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50906390 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50906592!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50905282 overrides: 50906346!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50905291 overrides: 50906350!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50906667 overrides: 50906350!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:57'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:02:57'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50905309!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50905318 overrides: 50906363!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50906695 overrides: 50906363!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:02:57'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50906346!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50905416 overrides: 50906350!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50906711 overrides: 50906350!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50906350!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50905344 overrides: 50906706!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50905353 overrides: 50906363!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50906729 overrides: 50906363!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50905363 overrides: 50906367!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50906739 overrides: 50906367!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50905368 overrides: 50906358!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50905374 overrides: 50906358!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50905380 overrides: 50906367!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50905392!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50906766!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50906648 overrides: 50906654!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:02:57'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50906716 overrides: 50906720!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50906792 overrides: 50906720!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50906654 overrides: 16783533!
new
	^ EmptyStack new .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50906435!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50906508!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50906515!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50906481!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50906537!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50906491!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50906553!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50906266!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50906409!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50906427!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:57'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50906706!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50906720!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50906358!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50906363 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50906367!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50906802 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:58'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:02:58'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:02:58'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:02:59'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:02:59'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:02:59'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:03:00'!
Object subclass: #OOStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:03:00'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:03:00'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38'!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05'!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14'!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37'!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:01'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50907402 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50907386!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50907397!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50907405!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50907390!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:05:19' prior: 50907382!
initializeStack
	elements := OrderedCollection new! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:08' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 17:16:08' prior: 50907422 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:03:02'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50907488 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:31:19'!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:34:31' prior: 50907507!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	stack should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50907513!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50907316!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50907327!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50907255!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50907261!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50907268!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50907275!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50907283!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50907297!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50907306!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:37:31' prior: 50907535!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
		
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:41:31' prior: 50907543!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50907340!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:36:33' prior: 50907524!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack
	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:16:57' prior: 50907503 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50907458!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50907475!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50907462!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50907454 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 17:05:19' prior: 50907467!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13' prior: 50907426!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 17:16:08' prior: 50907494 overrides: 16783533!
new
	^super new initialize! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:35' prior: 50907643!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assertGettingStackIsEmptyErrorAfterSending: #pop to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:43:45' prior: 50907656!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.

		
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:14' prior: 50907788!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	
	self assertGettingStackIsEmptyErrorAfterSending: #top to: stack.
! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:44:49' prior: 50907571!
test01StackShouldBeEmptyWhenCreated
	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:45:43'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:46:24' prior: 50907668!
assertGettingStackIsEmptyErrorAfterSending: aMessage to: stack

	self should: [ aMessage sendTo: stack]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:47:20'!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (#aMessage sendTo: stack) = lastPushedObject! !

!methodRemoval: OOStackTest #assertGettingLastPushedObjectIn:afterSending: stamp: 'eb 10/4/2020 20:03:02'!
assertGettingLastPushedObjectIn: stack afterSending: aMessage
	^nil!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:02' prior: 50907592!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:15' prior: 50907840!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #pop . ! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:48:47' prior: 50907616!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assertGetting: pushedObject in: stack afterSending: #top . 
	! !
!OOStackTest methodsFor: 'test - private' stamp: 'eb 10/4/2020 17:49:09' prior: 50907827!
assertGetting: lastPushedObject in: stack afterSending: aMessage

	self assert: (aMessage sendTo: stack) = lastPushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:49:34' prior: 50907577!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:05' prior: 50907584!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	
	stack push: 'something'.
	
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:50:39' prior: 50907601!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	
	self assert: stack pop = firstPushedObject.
	
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:51:21' prior: 50907892!
test05StackBehavesLIFO
	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	
	stack push: secondPushedObject.
	
	self assertGetting: secondPushedObject in: stack  afterSending: #pop .
	
	self assertGetting: firstPushedObject in: stack  afterSending: #pop .
		
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 17:52:04' prior: 50907625!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	
	stack top.
	
	self assert: stack size = 1.
	! !

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:02'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:55:42' prior: 50907710 overrides: 16896425!
initialize
	elements := OrderedCollection new
	
	! !
!EmptyStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 17:56:18' prior: 50906658 overrides: 50907961!
initialize

	elements := OrderedCollection new! !
!NotEmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 17:58:32'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .! !

!methodRemoval: EmptyStack #initialize stamp: 'eb 10/4/2020 20:03:03'!
initialize

	elements := OrderedCollection new!
!EmptyStack class methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:01:02' prior: 50906613 overrides: 50907759!
new
	
	^ super new initialize .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:21' prior: 50906781 overrides: 50907759!
new
	
	self onlyEmptyStackCanBeInitialized .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:40'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be initialized' .! !
!NotEmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:02:40' prior: 50907987 overrides: 50907759!
new
	
	self onlyEmptyStackCanBeInstantiated .! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInitialized stamp: 'eb 10/4/2020 20:03:03'!
onlyEmptyStackCanBeInitialized
	
	^ 'Only empty stack can be initialized' .!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:02:44' prior: 50907992!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .! !
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:03:00' prior: 50907999 overrides: 50907759!
new
	
	^ self onlyEmptyStackCanBeInstantiated .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:04:29' prior: 50907759 overrides: 16783533!
new
	^ self subclassResponsibility .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:39' overrides: 50907961!
initialize
	
	elements = OrderedCollection new .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:07:53' prior: 50906663 overrides: 50907715!
isEmpty
	
	^ True .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:08:51' prior: 50906672 overrides: 50907719!
pop
	
	^ nil! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:09:27' prior: 50908036 overrides: 50907719!
pop
	
	^ self class stackEmptyErrorDescription .! !

!methodRemoval: OOStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:03:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!NotEmptyStack class methodsFor: 'error descriptions' stamp: 'eb 10/4/2020 18:10:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!methodRemoval: NotEmptyStack class #stackEmptyErrorDescription stamp: 'eb 10/4/2020 20:03:03'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'!
!EmptyStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:10:29' prior: 50906690!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:11:22' prior: 50906699 overrides: 50907732!
size
	^ 0! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:11:27' prior: 50908064 overrides: 50907732!
size
	^ 0 .! !

!methodRemoval: OOStack #initialize stamp: 'eb 10/4/2020 20:03:03'!
initialize
	elements := OrderedCollection new
	
	!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:12:07' prior: 50907715!
isEmpty
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'no messages' stamp: 'eb 10/4/2020 18:12:36' prior: 50906797 overrides: 50907719!
pop
	^nil! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:13:00' prior: 50908080 overrides: 50907719!
pop
	
	^elements removeLast! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 18:13:20' prior: 50907719!
pop
	^ self subclassResponsibility .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:13:42' prior: 50906725 overrides: 50908075!
isEmpty

	^ False.! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:12' prior: 50906734 overrides: 50907732!
size
	^ elements size .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:14' prior: 50908098 overrides: 50907732!
size

	^ elements size .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:14:33' prior: 50906744 overrides: 50907736!
top
	
	^elements at: elements size! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:14:35' prior: 50908108 overrides: 50907736!
top
	
	^elements at: elements size .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:16:03' prior: 50906749 overrides: 50907727!
push: anElement
	
	NotEmptyStack new initializeWith: anElement .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:18:18' prior: 50906755 overrides: 50907727!
push: anElement
	
	^ elements add: anElement .! !
!EmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:18:39' prior: 50906761 overrides: 50907736!
top
	
	^ self class stackEmptyErrorDescription .! !
!NotEmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:20:21' prior: 50906773!
initializeWith: anElement

	| stack |	
	stack := self class new.
	elements add: anElement .
	^ stack .! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:20:32' prior: 50908135!
initializeWith: anElement

	| stack |	
	
	stack := self class new.
	
	elements add: anElement .
	
	^ stack .! !
!NotEmptyStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:20:54' prior: 50908017 overrides: 50908023!
new
	
	^ super new initialize.! !

!methodRemoval: NotEmptyStack class #onlyEmptyStackCanBeInstantiated stamp: 'eb 10/4/2020 20:03:03'!
onlyEmptyStackCanBeInstantiated
	
	^ 'Only empty stack can be instantiated' .!
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:48' prior: 50908085 overrides: 50908089!
pop
	
	^elements removeLast! !
!NotEmptyStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:32:49' prior: 50908161 overrides: 50908089!
pop
	
	^elements removeLast .! !
!OOStack class methodsFor: 'class instantiation' stamp: 'eb 10/4/2020 18:33:26' prior: 50908023 overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:00' prior: 50907982 overrides: 50908171!
new
	
	^ super super new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:36:38' prior: 50908176 overrides: 50908171!
new
	
	^ ProtoObject new initialize .! !

!methodRemoval: OOStack class #new stamp: 'eb 10/4/2020 20:03:03'!
new
	^ EmptyStack new .!
!OOStack class methodsFor: 'nil' stamp: 'eb 10/4/2020 18:40:56' overrides: 16783533!
new
	^ EmptyStack new .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:13' prior: 50908182 overrides: 50908189!
new
	
	^ ProtoObject new initialize .! !
!EmptyStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 18:41:25' prior: 50908194 overrides: 50908189!
new
	
	^ nil .! !
!EmptyStack methodsFor: 'nil' stamp: 'eb 10/4/2020 18:49:47' prior: 50908118 overrides: 50907727!
push: anElement
	
	^ NotEmptyStack new initializeWith: anElement .! !

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30' prior: 50907804!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55' prior: 50907877!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01' prior: 50907884!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09' prior: 50907850!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:48' prior: 50907906!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20' prior: 50907860!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24' prior: 50907922!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26' prior: 50907635!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31' prior: 50907778!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44' prior: 50907796!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:03'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'ja 10/4/2020 12:52:47'!
initializeStack
	stackElement := OrderedCollection new! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:53:38' prior: 50908075!
isEmpty
	^(stackElement size = 0)! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:29:05' prior: 50908089!
pop
	(stackElement size > 0) ifTrue: [^stackElement removeLast].
	(stackElement size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 12:57:14' prior: 50907727!
push: anElement 
	stackElement  add: anElement.
	! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:09:39' prior: 50907732 overrides: 16880927!
size
	^stackElement size! !
!OOStack methodsFor: 'operations' stamp: 'ja 10/4/2020 13:28:37' prior: 50907736!
top
	(stackElement size > 0) ifTrue: [^stackElement at: stackElement size].
	(stackElement size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:04'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:04'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'ja 10/4/2020 12:38:09' prior: 50908189 overrides: 16783533!
new
	^super new initializeStack! !
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 10/1/2020 18:08:13'!
stackEmptyErrorDescription
	
	^ 'Stack is empty!!'! !

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:04'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:03:04'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

c := OrderedCollection new.
c removeLast .!

!classRemoval: #NotEmptyStackTop stamp: 'eb 10/4/2020 20:22:45'!
StackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #EmptyStackTop stamp: 'eb 10/4/2020 20:22:45'!
StackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #StackTop stamp: 'eb 10/4/2020 20:22:45'!
Object subclass: #StackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/4/2020 20:22:45'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmptyStack stamp: 'eb 10/4/2020 20:22:46'!
OOStack subclass: #NotEmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #EmptyStack stamp: 'eb 10/4/2020 20:22:46'!
OOStack subclass: #EmptyStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/4/2020 20:22:46'!
Object subclass: #OOStack
	instanceVariableNames: 'stackElement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/4/2020 20:22:46'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/4/2020 20:22:47'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\15-Stack\Stack-Exercise-With-If.st----!

Object subclass: #OOStackIndex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackIndex category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:23:07'!
Object subclass: #OOStackIndex
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

Object subclass: #OOStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:23:18'!
Object subclass: #OOStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:23:37'!
OOStackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:23:42'!
OOStackTop subclass: #NotEmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

OOStackTop subclass: #NotEmptyStackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #NotEmptyStackTop category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:23:54'!
OOStackTop subclass: #NotEmptyStackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!NotEmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 20:24:23'!
initializeWith: aValue
	
	value := aValue .! !
!OOStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 20:25:15'!
topValue

	^ self subclassResponsibility .! !
!EmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 20:25:47' overrides: 50908741!
topValue
	
	^ OOStack stackEmptyErrorDescription .! !
!NotEmptyStackTop methodsFor: 'nil' stamp: 'eb 10/4/2020 20:26:03' overrides: 50908741!
topValue
	
	^ value .! !

Object subclass: #OOStackIndex
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackIndex category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:26:14'!
Object subclass: #OOStackIndex
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackIndex methodsFor: 'nil' stamp: 'eb 10/4/2020 20:26:29'!
next
	
	value := value + 1.! !
!OOStackIndex methodsFor: 'nil' stamp: 'eb 10/4/2020 20:26:45'!
prev
	
	value := value - 1! !
!OOStackIndex methodsFor: 'nil' stamp: 'eb 10/4/2020 20:27:01'!
initializeWith: aValue
	
	value := aValue .! !

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:27:18'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:18' prior: 50908635 overrides: 16880927!
size
	^elements size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:18' prior: 50908619!
isEmpty
	^(elements size = 0)! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:18' prior: 50908630!
push: anElement 
	elements  add: anElement.
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:18' prior: 50908638!
top
	(elements size > 0) ifTrue: [^elements at: elements size].
	(elements size = 0) ifTrue: [^self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:18' prior: 50908623!
pop
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:18' prior: 50908615!
initializeStack
	elements := OrderedCollection new! !

Object subclass: #OOStack
	instanceVariableNames: 'elements topElement topIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: #'Stack-Exercise' stamp: 'eb 10/4/2020 20:27:29'!
Object subclass: #OOStack
	instanceVariableNames: 'elements topElement topIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 20:27:55' overrides: 16896425!
initialize
	elements := OrderedCollection new! !
!OOStack class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:27:55' prior: 50908654 overrides: 16783533!
new
	^super new initialize! !

!methodRemoval: OOStack #initializeStack stamp: 'eb 10/4/2020 20:27:55'!
initializeStack
	elements := OrderedCollection new!
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 20:28:44' prior: 50908831 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	topElement := EmptyStackTop new .
	topIndex  := OOStackIndex new initializeWith: 0.! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:29:31' prior: 50908788!
isEmpty
	^ topIndex indexValue = 0 ! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:29:35' prior: 50908853!
isEmpty
	^ topIndex indexValue = 0 .! !
!OOStackIndex methodsFor: 'nil' stamp: 'eb 10/4/2020 20:29:59'!
indexValue
	
	^ value .! !
!OOStack methodsFor: 'nil' stamp: 'eb 10/4/2020 20:31:14'!
removeElementsAfterIndex
	
	elements select: [ :each | elements indexOf: each <= topIndex ]! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:31:22' prior: 50908864!
removeElementsAfterIndex
	
	elements := elements select: [ :each | elements indexOf: each <= topIndex ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:32:01' prior: 50908805!
pop
	| topValue |
	topValue := topElement topValue .
	
	(elements size > 0) ifTrue: [^elements removeLast].
	(elements size = 0) ifTrue:[^ self error: self class stackEmptyErrorDescription ]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:32:35' prior: 50908876!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex prev .
	
	self removeElementsAfterIndex .
	
	^ topValue .
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:33:08' prior: 50908792!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new with: anElement .
	topIndex  next .
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:33:28' prior: 50908784 overrides: 16880927!
size
	^ topIndex indexValue .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:33:40' prior: 50908797!
top
	^ topElement topValue .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:34:04'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:34:04'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:34:04'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:34:04'!
FAILURE!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:34:56' prior: 50908892!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new with: anElement .
	topIndex next .
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:35:23'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:35:23'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:35:23'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:35:23'!
FAILURE!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:35:24'!
ERROR!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:35:46' prior: 50908940!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex next .
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:35:49' prior: 50908982!
push: anElement 
	elements add: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex next .
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:35:53'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:35:53'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:35:53'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:35:53'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:35:53'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:35:53'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:35:53'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:35:53'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:35:53'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:35:53'!
FAILURE!
!ThirtyDaysGregorianMonth methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:29'!
inc
	
	^self next: self oneMonth! !
!RWBinaryOrTextStream methodsFor: 'reading' stamp: 'eb 10/4/2020 20:36:29'!
inc

	| byte |
	^ isBinary 
			ifTrue: [byte _ super next.
				 byte ifNil: [nil] ifNotNil: [byte numericValue]]
			ifFalse: [super next].
! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'eb 10/4/2020 20:36:29'!
inc
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	"If last call was #peek, not #next, then just answer cached value."
	peeked
		ifFalse: [ self privateRead ]
		ifTrue: [ peeked _ false ].

	"peeked is always false on exit"
	^buffer1 at: 1! !
!ReadStream methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:29'!
inc
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!ParkMiller88Random methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:29'!
inc
	"Answer a random Float in the interval [0, 1).
	NOTE: this is not a uniformly distributed random Float, since only uses 31 bits out of 53 bits mantissa.
	Additionally, #privateNextChunk can not produce all zeros or all ones.

	A higher quality Float RNG is LaggedFibonacciRandom"

	^ self privateNextChunk asFloat / self m
	
	"In any case, an alternative, slower but better answer could be:
	
	^(self nextBits: 53) asFloat  timesTwoPower: -53"! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'eb 10/4/2020 20:36:29'!
inc
	"Answer the next byte from this file, or nil if at the end of the file."

	^ self basicNext! !
!ImageReadWriter methodsFor: 'stream access' stamp: 'eb 10/4/2020 20:36:29'!
inc

	^stream next! !
!WriteStream methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:29'!
inc

	self shouldNotImplement! !
!ReferenceStream methodsFor: 'reading' stamp: 'eb 10/4/2020 20:36:29'!
inc
	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."
	| curPosn skipToPosn haveIt theObject wasSkipping |

	haveIt _ true.
	curPosn _ byteStream position - basePos.
	theObject _ objects at: curPosn ifAbsent: [haveIt _ false].
		"probe in objects is done twice when coming from objectAt:.  This is OK."
	skipToPosn _ fwdRefEnds at: curPosn ifAbsent: nil.
	haveIt ifFalse: [ ^ super next].

	skipToPosn ifNotNil: [
		"Skip over the object and return the already-read-in value."
		byteStream position: skipToPosn + basePos		"make absolute"
	] ifNil: [
		"File is not positioned correctly.  Read object and throw it away."
		wasSkipping _ skipping includes: curPosn.
		skipping add: curPosn.
		"fake _" super next.
		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: nil].
	].
	^ theObject
		! !
!SmartRefStream methodsFor: 'read write' stamp: 'eb 10/4/2020 20:36:29' overrides: 50909092!
inc
	"Really write three objects: (version, class structure, object). But only when called from the outside.  "

	| version ss object |
	^ topCall
		ifNil: [ 
			topCall _ #marked.
			version _ super next.
			version class == SmallInteger ifFalse: [^ version].	
				"version number, else just a regular object, not in our format, "
			ss _ super next.
			ss class == Array ifFalse: [^ ss].  "just a regular object"
			(ss at: 1) = 'class structure' ifFalse: [^ ss].
			structures _ ss at: 2.
			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 
				ifTrue: [ss at: 4]		"class name -> superclass name"
				ifFalse: [Dictionary new].
			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].
			object _ super next.	"all the action here"

			topCall _ nil.	"reset it"
			object]
		ifNotNil: [
			super next]
! !
!DataStream methodsFor: 'write and read' stamp: 'eb 10/4/2020 20:36:29'!
inc
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type _ byteStream next.
	type ifNil: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType _ self noteCurrentReference: type.
	selector _ #(readNil readTrue readFalse readInteger	"<-4"
			readStringOld readSymbol readByteArray		"<-7"
			readArray readInstance readReference readBitmap	"<-11"
			readClass readUser readFloat errorRead readShortInst 	"<-16"
			readString readWordArray readWordArrayForSegment 	"<-19"
			readWordLike readMethod 
			readCharacter "<-22") at: type.
	selector = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
			byteStream close. 
			self error: 'file is more recent than this system'. ^ nil].
	anObject _ self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject _ anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject! !
!CircularReadStream methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:29'!
inc

	^self next: (unit with: 1)! !
!I class methodsFor: 'operations' stamp: 'eb 10/4/2020 20:36:29'!
inc
	^self createChildNamed: self name, 'I'
! !
!PointInTime methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:29'!
inc
	
	^self next: self defaultIntervalIncrement! !
!FebruaryGregorianMonth methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:29' overrides: 50909221!
inc
	
	^self class march! !
!FileStream methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:29' overrides: 50909088!
inc

	(position >= readLimit and: [self atEnd])
		ifTrue: [^nil]
		ifFalse: [^collection at: (position _ position + 1)]! !
!NonSpecificThirtyOneDaysGregorianMonth methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:30' overrides: 50909221!
inc
	
	^self next: self oneMonth! !
!JanuaryGregorianMonth methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:30' overrides: 50909221!
inc
	
	^self class february! !
!Timespan methodsFor: 'smalltalk-80' stamp: 'eb 10/4/2020 20:36:30'!
inc

	^self class classDefinesDuration
		ifTrue: [ self class including: start + duration ]
		ifFalse: [ self class starting: start + duration duration: duration ]! !
!SharedQueue methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:30'!
inc
	"Answer the object that was sent through the receiver first and has not 
	yet been received by anyone. If no object has been sent, suspend the 
	requesting process until one is."

	readSynch wait.
	^accessProtect
		critical: [
			| value |
			readPosition = writePosition
					ifTrue: 
						[self error: 'Error in SharedQueue synchronization'.
						 value := nil]
					ifFalse: 
						[value := contentsArray at: readPosition.
						 contentsArray at: readPosition put: nil.
						 readPosition := readPosition + 1].
			value].! !
!Stream methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:30'!
inc
	"Answer the next object accessible by the receiver."

	self subclassResponsibility! !
!TimeLineFilterStream methodsFor: 'enumerating' stamp: 'eb 10/4/2020 20:36:30' overrides: 50909274!
inc
	
	current := self peek.	
	^current.
! !
!LaggedFibonacciRandom methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:30'!
inc
	"Answer a random Float in the interval [0, 1)"

	| answer tap1 tap2 |
	tap1 _ self ringAt: self last.
	tap2 _ self ringAt: self last - self minorLag + 1.
	answer _ tap2 - tap1.
	answer < 0.0 ifTrue: [answer _ 1.0 + answer].
	self ringAt: self last put: answer.
	self setLast: self last + 1.
	^answer! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30'!
inc
	
	value := value + 1.! !
!ReadWriteStream methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:30' overrides: 50909088!
inc
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!Random methodsFor: 'accessing' stamp: 'eb 10/4/2020 20:36:30'!
inc
	"Answer a random Float in the interval [0, 1)"

	self subclassResponsibility! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 16797934!
fatDefForClass: class

	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |
	newDef _ class definition.
	oldDef _ (self changeRecorderFor: class) priorDefinition.
	oldDef ifNil: [^ newDef].
	oldDef = newDef ifTrue: [^ newDef].

	oldStrm _ ReadStream on: oldDef.
	newStrm _ ReadStream on: newDef.
	outStrm _ WriteStream on: (String new: newDef size * 2).

	"Merge inst vars from old and new defs..."
	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.
	outStrm 
		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 
		nextPutAll: 'instanceVariableNames:'.
	newStrm peek = $: ifTrue: [newStrm inc].	"may or may not be there, but already written"
	outStrm
		nextPutAll: (newStrm upTo: $'); nextPut: $'.
	oldVars _ (oldStrm upTo: $') findTokens: Character separators.
	newVars _ (newStrm upTo: $') findTokens: Character separators.
	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
	outStrm nextPut: $'.

	class isMeta ifFalse:
		["Merge class vars from old and new defs..."
		oldStrm upToAll: 'classVariableNames:'; upTo: $'.
		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';
			nextPutAll: (newStrm upTo: $'); nextPut: $'.
		oldVars _ (oldStrm upTo: $') findTokens: Character separators.
		newVars _ (newStrm upTo: $') findTokens: Character separators.
		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
		outStrm nextPut: $'].

	outStrm nextPutAll: newStrm upToEnd.
	^ outStrm contents
! !
!ImageReadWriter methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 16854309!
next

	^stream inc! !
!Color class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 50354655!
random: aRandom
	"Return a random color that isn't too dark or under-saturated."

	^ self new
		setHue: (360.0 * aRandom inc)
		saturation: (0.3 + (aRandom inc * 0.7))
		brightness: (0.4 + (aRandom inc * 0.6))! !
!Date class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 50342356 overrides: 16882927!
readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream inc ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !
!II class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 50868938 overrides: 50868942!
+ aNumber
	^ self prev + aNumber inc.! !
!EventSensor methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 16839356!
flushAllButDandDEvents
	| newQueue oldQueue  |
	
	newQueue _ SharedQueue new.
	eventQueue ifNil: [
		eventQueue _ newQueue.
		^self].
	oldQueue _ eventQueue.
	[ oldQueue size > 0 ] whileTrue: [ | item type | 
		item _ oldQueue inc.
		type _ item at: 1.
		type = EventSensor eventTypeDragDropFiles ifTrue: [ newQueue nextPut: item]].
	eventQueue _ newQueue.
! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 50743255!
testToByDo

	| interval date hours |
	interval := januaryFirstOf2004 to: januarySecondOf2004On23Hours59Minutes59Seconds by: (TimeUnits hour with: 1).
	date := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01.
	hours := 0.
	interval do: [:aGregorianDateTime | 
		self assert: aGregorianDateTime date = date.
		self assert: aGregorianDateTime timeOfDay = (TimeOfDay hours: hours).
		hours := hours + 1.
		hours = 24 
			ifTrue: [
				date := date inc.
				hours := 0]].
	self assert: date = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 03).
	self assert: hours = 0! !
!I class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:30' prior: 50868942!
+ aNumber 
	^aNumber inc.! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50335824 overrides: 50335818!
unStream: aByteArray

	^(self on: ((RWBinaryOrTextStream with: aByteArray) reset; binary)) inc! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16899914 overrides: 16827317!
objectAt: anInteger
    "PRIVATE -- Read & return the object at a given stream position.
     If we already read it, just get it from the objects dictionary.
     (Reading it again wouldn't work with cycles or sharing.)
     If not, go read it and put it in the objects dictionary.
     NOTE: This resolves a cross-reference in the ReferenceStream:
       1. A backward reference to an object already read (the normal case).
       2. A forward reference which is a sated weak reference (we record where
          the object ends so when we get to it normally we can fetch it from
          'objects' and skip over it).
       3. A backward reference to a 'non-reference type' per the long NOTE in
          nextPut: (we compensate here--seek back to re-read it and add the object
          to 'objects' to avoid seeking back to read it any more times).
       4. While reading a foward weak reference (case 2), we may recursively hit an
          ordinary backward reference to an object that we haven't yet read because
          we temporarily skipped ahead. Such a reference is forward in time so we
          treat it much like case 2.
     11/16-24/92 jhm: Handle forward refs. Cf. class comment and above NOTE.
	08:57 tk   anInteger is a relative position"
    | savedPosn refPosn anObject |

    ^ objects at: anInteger "relative position.  case 1: It's in 'objects'"
        ifAbsent:   "do like super objectAt:, but remember the fwd-ref-end position"
            [savedPosn _ byteStream position.		"absolute"
            refPosn _ self getCurrentReference.	"relative position"

            byteStream position: anInteger + basePos.	"was relative"
            anObject _ self inc.

            (self isAReferenceType: (self typeIDFor: anObject))
                ifTrue:  [fwdRefEnds at: anInteger put: byteStream position - basePos] "cases 2, 4"
                ifFalse: [objects at: anInteger put: anObject]. "case 3"

            self setCurrentReference: refPosn.		"relative position"
            byteStream position: savedPosn.		"absolute"
            anObject]! !
!SpecificDayRuleTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50740545!
testIncludes

	| rule includedDate |

	includedDate := FixedGregorianDate yearNumber: 2006 monthNumber: 01 dayNumber: 01.
	rule := SpecificDayRule rule: (Array with: includedDate day).

	self
		assert: (rule includes: includedDate);
		deny: (rule includes: includedDate inc)! !
!ParkMiller88RandomTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50761088!
testParkMillerInitialValues

	| nSamples random samples |
	nSamples _ self nSamplesByDefault.
	random _ self rng.
	samples _ 1 to: nSamples :: collect: [:each | random inc].
	self assert: (samples average - 0.5) abs < 0.1.
	self assert: samples size * 10 > nSamples! !
!String class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16917898 overrides: 16882927!
readFrom: inStream
	"Answer an instance of me that is determined by reading the stream, 
	inStream. Embedded double quotes become the quote Character."

	| outStream char done |
	outStream _ WriteStream on: (String new: 16).
	"go to first quote"
	inStream skipTo: $'.
	done _ false.
	[done or: [inStream atEnd]]
		whileFalse: 
			[char _ inStream inc.
			char = $'
				ifTrue: 
					[char _ inStream inc.
					char = $'
						ifTrue: [outStream nextPut: char]
						ifFalse: [done _ true]]
				ifFalse: [outStream nextPut: char]].
	^outStream contents! !
!Color class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50354646!
random2: aRandom
	"Return a random color with a distribution that spans over all possible colors."

	^ self new
		setRed: aRandom inc
		green: aRandom inc
		blue: aRandom inc! !
!Heap class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16852887!
heapExample	"Heap heapExample"
	"Create a sorted collection of numbers, remove the elements
	sequentially and add new objects randomly.
	Note: This is the kind of benchmark a heap is designed for."
	| n rnd array time |
	n := 5000. "# of elements to sort"
	rnd := Random new.
	array := (1 to: n) collect:[:i| rnd inc].
	"First, the heap version"
	time := Time millisecondsToRun:[| sorted |
		sorted := Heap withAll: array.
		1 to: n do: [ :i | 
			sorted removeFirst.
			sorted add: rnd inc].
	].
	Transcript newLine; show:'Time for Heap: ', time printString,' msecs'.
	"The quicksort version"
	time := Time millisecondsToRun:[| sorted |
		sorted := SortedCollection withAll: array.
		1 to: n do:[:i| 
			sorted removeFirst.
			sorted add: rnd inc].
	].
	Transcript newLine; show:'Time for SortedCollection: ', time printString,' msecs'.
! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16914070!
upToEnd
	"answer the remaining elements in the string"
	| elements |
	elements _ OrderedCollection new.
	[ self atEnd ] whileFalse: [ 
		elements add: self inc ].
	^elements! !
!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16912048!
read: aByteStream withClasses: structureArray
	"Read an object off the stream, but first check structureArray against the current system."

	| me |
	me _ self on: aByteStream.
	me noHeader.
	me structures: (structureArray at: 2).
	me superclasses: (structureArray at: 4).
	(me verifyStructure = 'conversion method needed') ifTrue: [^ nil].
	^ super inc
! !
!DayOfMonthRuleTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50739298!
testIncludes

	| rule includedDate |

	includedDate := FixedGregorianDate yearNumber: 2006 monthNumber: 01 dayNumber: 01.
	rule := DayOfMonthRule rule: (Array with: includedDate dayOfMonth).

	self
		assert: (rule includes: includedDate);
		deny: (rule includes: includedDate inc)! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16891580!
backUpTo: subCollection
	"Back up the position to he subCollection.  Position must be somewhere within the stream initially.  Leave it just after it.  Return true if succeeded.  No wildcards, and case does matter."
"Example:
	| strm | strm _ ReadStream on: 'zabc abdc'.
	strm setToEnd; backUpTo: 'abc'; position 
"

	| pattern startMatch |
	pattern _ ReadStream on: subCollection reversed.
	startMatch _ nil.
	[pattern atEnd] whileFalse: 
		[self position = 0 ifTrue: [^ false].
		self skip: -1.
		(self inc) = (pattern inc) 
			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]
			ifFalse: [pattern position: 0.
					startMatch ifNotNil: [
						self position: startMatch-1.
						startMatch _ nil]].
		self skip: -1].
	self position: startMatch.
	^ true

! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16933843!
redoAndEvaluate: aTwoArgBlock
	| modelUpdated newCursorPos |
	modelUpdated _ false.
	undoRedoCommands atEnd ifFalse: [
		newCursorPos _ undoRedoCommands inc doOn: self.
		modelUpdated _ true ].
	aTwoArgBlock value: modelUpdated value: newCursorPos.
	lastEditTimeStamp _ nil! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16891687!
skipTo: anObject 
	"Set the access position of the receiver to be past the next occurrence of 
	anObject. Answer whether anObject is found."

	[self atEnd]
		whileFalse: [self inc = anObject ifTrue: [^true]].
	^false! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50743697!
testNext

	self assert: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31) inc = (GregorianDayOfMonth monthNumber: 1 dayNumber: 1).
	self assert: (GregorianDayOfMonth monthNumber: 2 dayNumber: 29) inc = (GregorianDayOfMonth monthNumber: 3 dayNumber: 1)! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50743798!
testToByDo

	| daysTo januaryFirst dayOfMonth |
	
	daysTo := 0.
	januaryFirst := GregorianDayOfMonth monthNumber: 1 dayNumber: 1.
	dayOfMonth := januaryFirst.
	(januaryFirst to: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31)) do: [ :aDayOfMonth |
		self assert: aDayOfMonth = dayOfMonth.
		self assert: (januaryFirst distanceTo: aDayOfMonth) amount = daysTo.
		dayOfMonth := dayOfMonth inc.
		daysTo := daysTo + 1 ].
		
	self assert: daysTo = 366! !
!FloatTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50753329!
testFloatTruncated
	"(10 raisedTo: 16) asFloat has an exact representation (no round off error).
	It should convert back to integer without loosing bits.
	This is a no regression test on http://bugs.impara.de/view.php?id=3504"
	
	| x y int r |
	int := 10 raisedTo: 16.
	x := int asFloat.
	y := (5 raisedTo: 16) asFloat timesTwoPower: 16.
	self assert: x = y.
	
	self assert: x asInteger = int.
	
	"this one should be true for any float"
	self assert: x asInteger = x asTrueFraction asInteger.

	"a random test"
	r := Random new.
	10000 timesRepeat: [
		x := r inc * 1.9999e16 + 1.0e12 .
		self assert: x truncated = x asTrueFraction truncated]! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16911484!
catalogValues: instVarList size: varsOnDisk
	"Create a dictionary of (name -> value) for the inst vars of this reshaped object.  Indexed vars as (1 -> val) etc.  "

	| dict sz |
	dict _ Dictionary new.
	2 to: instVarList size do: [:ind |
		dict at: (instVarList at: ind) put: self inc].
	sz _ varsOnDisk - (instVarList size - 1).
	1 to: sz do: [:ii | 
		dict at: ii put: self inc].
	"Total number read MUST be equal to varsOnDisk!!"
	sz > 0 ifTrue: [dict at: #SizeOfVariablePart put: sz].
	^ dict! !
!ProgressiveTestRunner methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50338160!
updateProgressBarSubLabel

	testsStream atEnd ifFalse: [
		progressBar subLabel: testsStream inc printString, ' (', testsStream position printString, '/', testsStream size printString, ')' ].! !
!ArrayedCollection class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16780619!
newFromStream: s
	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."
	| len |

	self isPointers | self isWords not ifTrue: [^ super newFromStream: s].
		"super may cause an error, but will not be called."

	s inc = 16r80 ifTrue:
		["A compressed format.  Could copy what BitMap does, or use a 
		special sound compression format.  Callers normally compress their own way."
		^ self error: 'not implemented'].
	s skip: -1.
	len _ s nextSignedInt32BigEndian: true.
	^ s nextWordsInto: (self basicNew: len)! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16827418!
readInstance
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize aSymbol refPosn anObject newClass |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	aSymbol _ self inc.
	newClass _ Smalltalk at: aSymbol asSymbol.
	anObject _ newClass isVariable 	"Create object here"
			ifFalse: [newClass basicNew]
			ifTrue: [newClass basicNew: instSize - (newClass instSize)].
	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	anObject _ anObject readDataFrom: self size: instSize.
	self setCurrentReference: refPosn.  "before returning to next"
	^ anObject! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50744218!
testSinceSunday

	| currentDay |
	
	currentDay := GregorianDay sunday.
	(GregorianDay zeroDays to: (TimeUnits day with:6)) do: [:aNumberOfDays |
		self assert: (GregorianDay sinceSunday: aNumberOfDays)=currentDay.
		currentDay := currentDay inc ]! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50331996!
nextString
	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."

	| aString length |

	"read the length in binary mode"
	self binary.
	length _ self inc.		"first byte."
	length >= 192 ifTrue: [length _ length - 192.
		1 to: 3 do: [:ii | length _ length * 256 + self inc]].
	aString _ String new: length.

	"read the characters in ASCII mode"
	self ascii.
	self nextInto: aString.
	^aString! !
!RelativeGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50740401!
testNext

	self assert: relativeDate inc= absoluteDate inc.
	self assert: (relativeDate next: GregorianDay twoDays) = (absoluteDate next: GregorianDay twoDays)
	! !
!Integer class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16860835!
readBaseOneFrom: aStream
	"Unary numeral system
	Supports positive and negative integers.
	See http://en.wikipedia.org/wiki/Unary_numeral_system
	Non-standard features of this system include:
		- The value of a digit does not depend on its position. Thus, one can easily argue that unary is not a positional system at all.
		- Introducing a radix point in this system will not enable representation of non-integer values.
		- The single numeral represents the value 1, not the value 0=b-1.
		- The value 0 cannot be represented (or is implicitly represented by an empty digit string).
	Examples (and equivalent decimal notation)
		1r1 = 10r1
		1r11 = 10r2
		1r111 = 10r3
		1r = 10r0
	"

	| digit value neg |
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	[ aStream atEnd ]
		whileFalse: [ 
			digit _ aStream inc digitValue.
			digit = 1
				ifTrue: [value _ value + digit]
				ifFalse: [
					aStream skip: -1.
					neg ifTrue: [^ value negated].
					^ value]].
	neg ifTrue: [ ^ value negated ].
	^ value! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16914032!
nextMatchAll: aColl
    "Answer true if next N objects are the ones in aColl,
     else false.  Advance stream of true, leave as was if false."
    | save |
    save _ self position.
    aColl do: [:each |
       (self inc) = each ifFalse: [
            self position: save.
            ^ false]
        ].
    ^ true! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16916267!
asCamelCase
	"Answer a new String, without any whitespace, and with words capitalized (Except for the first one)
	' how do you do? ' asCamelCase
	"
	^ String streamContents: [ :outStream | | inStream capitalize wroteSome |
		wroteSome _ false.
		capitalize _ false.
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [ | c |
			c _ inStream inc.
			c isSeparator
				ifTrue: [ capitalize _ true ]
				ifFalse: [
					capitalize & wroteSome ifTrue: [ c _ c asUppercase ].
					outStream nextPut: c.
					wroteSome _ true.
					capitalize _ false ]]]! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 50334588!
readMethod
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	className _ self inc.
	newClass _ Smalltalk at: className asSymbol.

	xxHeader _ self inc.
		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."
		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."
		"largeBit _ (xxHeader >> 17) bitAnd: 1."
	nLits _ (xxHeader >> 9) bitAnd: 16rFF.
		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."
	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * Smalltalk wordSize).

	newMethod _ newClass 
		newMethod: byteCodeSizePlusTrailer
		header: xxHeader.

	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	self beginReference: newMethod.
	lits _ newMethod numLiterals + 1.	"counting header"
	2 to: lits do:
		[:ii | newMethod objectAt: ii put: self inc].
	lits*Smalltalk wordSize+1 to: newMethod basicSize do:
		[:ii | newMethod basicAt: ii put: byteStream inc].
			"Get raw bytes directly from the file"
	self setCurrentReference: refPosn.  "before returning to next"
	^ newMethod! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:31' prior: 16837706!
fillDict: dict with: nodeClass mapping: keys to: codeArray
	| codeStream |
	codeStream := ReadStream on: codeArray.
	keys do: 
		[:key | dict 
				at: key
				put:  (nodeClass new name: key key: key code: codeStream inc)]! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16847788!
readAttributesFrom: aBinaryStream
	| offsetX offsetY |
	depth _ aBinaryStream inc.
	(self depth isPowerOfTwo and: [self depth between: 1 and: 32])
		ifFalse: [self error: 'invalid depth; bad Form file?'].
	width _ aBinaryStream nextUnsignedInt16BigEndian: true.
	height _ aBinaryStream nextUnsignedInt16BigEndian: true.
	offsetX  _ aBinaryStream nextSignedInt16BigEndian: true.
	offsetY _ aBinaryStream nextSignedInt16BigEndian: true.
	offset _ Point x: offsetX y: offsetY! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50742615!
testNext

	| day |
	
	day := FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 31.
	self assert: day inc=(FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 1).

	day := FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 28.
	self assert: day inc=(FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 29).
	self assert: day inc inc=(FixedGregorianDate yearNumber: 2004 monthNumber: 3 dayNumber: 1).

	day := FixedGregorianDate yearNumber: 2004 monthNumber: 12 dayNumber: 31.
	self assert: day inc=(FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1).
	
	

! !
!JanuaryGregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50746575!
testNext

	self assert: GregorianMonth january inc = GregorianMonth february.! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16891460!
untilAnySatisfying: aBlock
	| write c |
	write := collection class new writeStream.
	[
		self atEnd not and: [
			c := self peek.
			(aBlock value: c) not]]
		whileTrue: [write nextPut: self inc].
	^write contents! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50744152!
testNext

	self assert: GregorianDay monday inc=GregorianDay tuesday.
	self assert: GregorianDay sunday inc=GregorianDay monday.
	self assert: GregorianDay saturday inc=GregorianDay sunday.
	! !
!Date class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16828479!
tomorrow

	^ self today inc! !
!Integer class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50587932!
readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Raises an error if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	
	(aStream atEnd) ifTrue: [ self error: 'At least one digit expected here' ].
	
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream inc.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skip: -1.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !
!GregorianDayOfMonth methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50737009!
moveForward: aNumberOfDays

	^(aNumberOfDays > month lastDayNumber)
		ifTrue: [ month inc firstDayOfMonth moveForward: aNumberOfDays - month lastDayNumber ]
		ifFalse: [ self class month: month dayNumber: aNumberOfDays ]! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16916433!
asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in out char rest did inString |

	"Hack in some minimal workaround for Unicode stuff"
	inString _ self copyReplaceAll: '' with: $' asString.
	"Check if we can handle this in #safeValue: in some way..."
	inString = self ifFalse: [ self halt ].
	
	in _ ReadStream on: inString.
	out _ WriteStream on: (String new: self size).
	[ in atEnd ] whileFalse: [
		in peek = $<
			ifTrue: [in unCommand] 	"Absorb <...><...>"
			ifFalse: [(char _ in inc) = $&
						ifTrue: [rest _ in upTo: $;.
								did _ out position.
								rest = 'lt' ifTrue: [out nextPut: $<].
								rest = 'gt' ifTrue: [out nextPut: $>].
								rest = 'amp' ifTrue: [out nextPut: $&].
								rest = 'deg' ifTrue: [out nextPut: $].
								rest = 'quot' ifTrue: [out nextPut: $"].
								rest first = $# ifTrue: [ out nextPut: (Character numericValue: rest asInteger) ].
								did = out position ifTrue: [
									out nextPut: $&; nextPutAll: rest.
									"self error: 'unknown encoded HTML char'."
									"Please add it to this method"]]
						ifFalse: [out nextPut: char]].
		].
	^ out contents! !
!Heap class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16852916!
heapSortExample	"Heap heapSortExample"
	"Sort a random collection of Floats and compare the results with
	SortedCollection (using the quick-sort algorithm) and 
	ArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm)."
	| n rnd array time |
	n := 10000. "# of elements to sort"
	rnd := Random new.
	array := (1 to: n) collect:[:i| rnd inc].
	"First, the heap version"
	time := Time millisecondsToRun: [
		| sorted |
		sorted := Heap withAll: array.
		1 to: n do: [ :i | sorted removeFirst ]].
	Transcript newLine; show:'Time for heap-sort: ', time printString,' msecs'.
	"The quicksort version"
	time := Time millisecondsToRun:[| sorted |
		sorted := SortedCollection withAll: array.
	].
	Transcript newLine; show:'Time for quick-sort: ', time printString,' msecs'.
	"The merge-sort version"
	time := Time millisecondsToRun:[
		array mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].
	].
	Transcript newLine; show:'Time for merge-sort: ', time printString,' msecs'.
! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16899867 overrides: 16827195!
next
	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."
	| curPosn skipToPosn haveIt theObject wasSkipping |

	haveIt _ true.
	curPosn _ byteStream position - basePos.
	theObject _ objects at: curPosn ifAbsent: [haveIt _ false].
		"probe in objects is done twice when coming from objectAt:.  This is OK."
	skipToPosn _ fwdRefEnds at: curPosn ifAbsent: nil.
	haveIt ifFalse: [ ^ super inc].

	skipToPosn ifNotNil: [
		"Skip over the object and return the already-read-in value."
		byteStream position: skipToPosn + basePos		"make absolute"
	] ifNil: [
		"File is not positioned correctly.  Read object and throw it away."
		wasSkipping _ skipping includes: curPosn.
		skipping add: curPosn.
		"fake _" super inc.
		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: nil].
	].
	^ theObject
		! !
!RelativeGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50740229!
testAbsoluteDate

	| absolute |
	
	absolute := relativeDate absoluteDate.
	self assert: absolute = relativeDate absoluteDate.
	
	timeLineFilter addDateRule: (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 06).
	self deny: absolute = relativeDate absoluteDate.
	self assert: absolute inc = relativeDate absoluteDate! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16827522!
readShortInst
	"Read the contents of an arbitrary instance that has a short header.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize aSymbol refPosn anObject newClass |

	instSize _ (byteStream inc) - 1.	"one byte of size"
	refPosn _ self getCurrentReference.
	aSymbol _ self readShortRef.	"class symbol in two bytes of file pos"
	newClass _ Smalltalk at: aSymbol asSymbol.
	anObject _ newClass isVariable 	"Create object here"
			ifFalse: [newClass basicNew]
			ifTrue: [newClass basicNew: instSize - (newClass instSize)].
	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	anObject _ anObject readDataFrom: self size: instSize.
	self setCurrentReference: refPosn.  "before returning to next"
	^ anObject! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50741399!
testStream

	| timeLineFilter stream |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
		
	stream := timeLineFilter streamFrom: (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01).
	3 timesRepeat: [ self assert: stream inc day = GregorianDay saturday ]! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16917395!
indentationIfBlank: aBlock
	"Answer the number of leading tabs in the receiver.  If there are
	 no visible characters, pass the number of tabs to aBlock and return its value."
	| reader leadingTabs lastSeparator tab ch |
	tab _ Character tab.
	reader _ ReadStream on: self.
	leadingTabs _ 0.
	[ reader atEnd not and: [ (ch _ reader inc) == tab ]] whileTrue: [
		leadingTabs _ leadingTabs + 1 ].
	lastSeparator _ leadingTabs + 1.
	[ reader atEnd not and: [
		ch isSeparator and: [ ch isLineSeparator not ]]] whileTrue: [
			lastSeparator _ lastSeparator + 1.
			ch _ reader inc ].
	lastSeparator = self size | (ch notNil and: [ch isLineSeparator]) ifTrue: [
		^ aBlock value: leadingTabs ].
	^ leadingTabs! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16891470!
upTo: anObject 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of anObject in the receiver. If 
	anObject is not in the collection, answer the entire rest of the receiver."
	| newStream element |
	newStream := WriteStream on: (self collectionSpecies new: 100).
	[self atEnd or: [(element := self inc) = anObject]]
		whileFalse: [newStream nextPut: element].
	^newStream contents! !
!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 16829293 overrides: 16882927!
readFrom: aStream

	| offset date time ch |

	date _ Date readFrom: aStream.
	[aStream peek isDigit]
		whileFalse: [aStream inc].
	time _ Time readFrom: aStream.
	aStream atEnd
		ifTrue: [ offset _ self localOffset ]
		ifFalse: [
			ch _ aStream inc.
			ch = $+ ifTrue: [ch _ Character space].
			offset _ Duration fromString: ch asString, '0:', aStream upToEnd, ':0'].
		
	^ self
		year: date yearNumber
		month: date monthIndex
		day: date dayOfMonth
		hour: time hour
		minute: time minute
		second: time second
		nanoSecond: time nanoSecond
		offset: offset


	"
		DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.02+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.003+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0004+01:01' readStream
  		DateAndTime readFrom: ' 2002-05-16T17:20:45.00005' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000006+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000007+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.00000008-01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000000009+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000000001+01:01' readStream

 		DateAndTime readFrom: ' 2002-05-16T17:20' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45+01:57' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45-02:34' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45+00:00' readStream
		DateAndTime readFrom: ' 1997-04-26T01:02:03+01:02:3' readStream
 	"! !
!ChangeList methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:32' prior: 50653611!
notSeparatorChar

	| prevChar |
	
	[file atEnd not and: [file peek isSeparator]] whileTrue: [prevChar _ file inc].
	
	^prevChar! !
!TimeLineFilterStreamTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50740589!
testCurrent

	| timeLineFilter stream januaryThirdOf2004 januaryTenOf2004 |

	januaryThirdOf2004 := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 03.
	januaryTenOf2004 := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 10.
	timeLineFilter := TimeLineFilter new.
	timeLineFilter addRule: (timeLineFilter dayRule: GregorianDay saturday).

	stream :=
		TimeLineFilterStream from: januaryThirdOf2004 using: timeLineFilter.
	self assert: stream current = januaryThirdOf2004.
	self assert: stream inc = januaryTenOf2004.
	self assert: stream current = januaryTenOf2004! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50741609!
testToEveryBeginningDifferentDay
						
	| aMonday expectedDayNumbers interval |
	
	aMonday := FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 5.
	interval := aMonday 
		to: ((aMonday nextDay: GregorianDay monday) inc)
		every: (Array with: GregorianDay tuesday with: GregorianDay wednesday with: GregorianDay friday).
			
	self assert: interval first=aMonday inc.
	self assert: interval last=(aMonday nextDay: GregorianDay monday) inc.
	self assert: interval size=4.
	expectedDayNumbers := #(6 7 9 13).
	interval inject: 1 into: [ :index :aDate |
		self assert: aDate dayNumber=(expectedDayNumbers at: index).
		index + 1 ].
! !
!EventSensor methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16839374!
nextEvent
	"Return the next event from the receiver."
	eventQueue isEmpty ifTrue: [ self fetchMoreEvents ].
	^ eventQueue isEmpty
		ifFalse: [ eventQueue inc ]! !
!FileStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16843541 overrides: 16898111!
next: anInteger

	| newCollection howManyRead increment |
	newCollection := self collectionSpecies new: anInteger.
	howManyRead := 0.
	[howManyRead < anInteger] whileTrue:
		[self atEnd ifTrue:
			[(howManyRead + 1) to: anInteger do: [:i | newCollection at: i put: (self inc)].
			^newCollection].
		increment := (readLimit - position) min: (anInteger - howManyRead).
		newCollection replaceFrom: (howManyRead + 1)
			to: (howManyRead := howManyRead + increment)
			with: collection
			startingAt: (position + 1).
		position := position + increment].
	^newCollection! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16911278 overrides: 50909848!
readInstance
	"Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
Three cases for files from older versions of the system:
1) Class has not changed shape, read it straight.
2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.
3) There is a new class instead.  Find it, call a particular method to read.
	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"
	| instSize className refPosn |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	className _ self inc asSymbol.
	^ self readInstanceSize: instSize clsname: className refPosn: refPosn
! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50741656!
testToEveryDayBeginningDifferentDay
						
	| aMonday expectedDayNumbers interval |
	
	aMonday := FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 5.
	interval := aMonday 
		to: (aMonday nextDay: GregorianDay monday) inc
		everyDay: GregorianDay tuesday.
			
	self assert: interval first=aMonday inc.
	self assert: interval last=(aMonday nextDay: GregorianDay monday) inc.
	self assert: interval size=2.
	expectedDayNumbers := #(6 13).
	interval inject: 1 into: [ :index :aDate |
		self assert: aDate dayNumber=(expectedDayNumbers at: index).
		index + 1 ].
! !
!JPEGReadWriter2 methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16861614 overrides: 16854407!
understandsImageFormat
	"Answer true if the image stream format is understood by this decoder."
	self isPluginPresent ifFalse:[^false]. "cannot read it otherwise"
	self inc = 16rFF ifFalse: [^ false].
	self inc = 16rD8 ifFalse: [^ false].
	^ true
! !
!BMPReadWriter methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50562647!
readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ `Array with: Color white with: Color black`].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream inc.
		g := ccStream inc.
		r := ccStream inc.
		ccStream inc. "skip reserved"
		colors at: i put: (Color r: r g: g b: b range: 255)].
	^ colors
! !
!Duration class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50642995 overrides: 16882927!
readFrom: aStream
	"Formatted as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]"

	| sign days hours minutes seconds nanos nanosBuffer |
	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].
	days := (aStream upTo: $:) asInteger * sign.
	hours := (aStream upTo: $:) asInteger * sign.
	minutes := (aStream upTo: $:) asInteger * sign.
	seconds := (aStream upTo: $.) asInteger * sign.
	nanosBuffer := '000000000' copy.
	nanos := WriteStream on: nanosBuffer.
	[aStream atEnd not and: [aStream peek isDigit]]
		whileTrue: [nanos nextPut: aStream inc].
		
	^ self 
		days: days 
		hours: hours 
		minutes: minutes 
		seconds: seconds 
		nanoSeconds: (nanosBuffer asInteger * sign)

	"	'0:00:00:00' asDuration
		'0:00:00:00.000000001' asDuration
		'0:00:00:00.999999999' asDuration
		'0:00:00:00.100000000' asDuration
		'0:00:00:00.001 ' asDuration
		'0:00:00:00.1' asDuration
		'0:00:00:01 ' asDuration
		'0:12:45:45' asDuration
		'1:00:00:00' asDuration
		'365:00:00:00' asDuration
		'-7:09:12:06.10' asDuration
		'+0:01:02:3' asDuration
 	"! !
!Character class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50675907!
nextCodePointBytesFromUtf8: anUtf8Stream into: aBlock
	"anUtf8Stream can be over a ByteArray.
	See senders."

	| byte1 byte2 byte3 byte4 |
	byte1 _ anUtf8Stream inc.
	byte1 < 128 ifTrue: [	"single byte"
		^ aBlock value: byte1 value: nil value: nil value: nil ].
	
	"At least 2 bytes"
	byte2 _ anUtf8Stream inc.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		^ aBlock value: byte1 value: byte2 value: nil value: nil ].
	
	"At least 3 bytes"
	byte3 _ anUtf8Stream inc.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: nil ].

	"4 bytes"
	byte4 _ anUtf8Stream inc.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: byte4 ].

	^nil! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16916750!
squeezedTo: n
	"
Examples:
	Do nothing:
		'This one is a rather long phrase' squeezedTo: 32

	1-remove blanks (result can be shorter than asked):
		'This one is a rather long phrase' squeezedTo: 30

	2-remove necessary trailing vowels
		'This one is a rather long phrase' squeezedTo: 24

	3-truncate as needed (and add ellipsis)
		'This one is a rather long phrase' squeezedTo: 15

	4-avoid ellipsis
		'This one is a rather long phrase' squeezedTo: 5
	"
	| vowelCount read write i char allowedVowels str desiredSize postFix j |
	str := self.
	desiredSize := n.
	str size <= n ifTrue: [^str].
	str := str asCamelCase.
	str size <= n ifTrue: [^str].
	postFix := ''.
	desiredSize := n - postFix size.
	vowelCount := str
		inject: 0
		into: [:prev :each | each isVowel ifTrue: [prev + 1] ifFalse: [prev]].
	str size - vowelCount <= desiredSize
		ifTrue: [allowedVowels := vowelCount - (str size - desiredSize)]
		ifFalse: [
			allowedVowels := 0.
			postFix := '...'.
			n - postFix size < 5 ifTrue: [postFix := ''].
			desiredSize := n - postFix size].

	read := str readStream.
	write := String new writeStream.
	i := 0.
	j := 0.
	[read atEnd not and: [j < desiredSize]] whileTrue: [
		char := read inc.
		(char isVowel not or: [i < allowedVowels]) ifTrue: [
			char isVowel ifTrue: [i := i + 1].
			write nextPut: char.
			j := j + 1]].
	str := write contents , postFix.
	^ str! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50603224!
xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore]]] whileTrue:
			["open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
							ifTrue: [DoItCharacter "doit"]
							ifFalse: [source inc]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])
					ifTrue: 
						[buffer nextPut: self step.
						"Allow any number of embedded colons in literal symbols"
						[(self typeTableAt: hereChar) == #xColon] whileTrue:
							[buffer nextPut: self step].
						#keyword]
					ifFalse: 
						[#word].
	token := buffer contents! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16911153 overrides: 50910244!
next
	"Really write three objects: (version, class structure, object). But only when called from the outside.  "

	| version ss object |
	^ topCall
		ifNil: [ 
			topCall _ #marked.
			version _ super inc.
			version class == SmallInteger ifFalse: [^ version].	
				"version number, else just a regular object, not in our format, "
			ss _ super inc.
			ss class == Array ifFalse: [^ ss].  "just a regular object"
			(ss at: 1) = 'class structure' ifFalse: [^ ss].
			structures _ ss at: 2.
			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 
				ifTrue: [ss at: 4]		"class name -> superclass name"
				ifFalse: [Dictionary new].
			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].
			object _ super inc.	"all the action here"

			topCall _ nil.	"reset it"
			object]
		ifNotNil: [
			super inc]
! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50603165!
step

	| c |
	c := hereChar.
	hereChar := aheadChar.
	source atEnd
		ifTrue: [aheadChar := DoItCharacter "doit"]
		ifFalse: [aheadChar := source inc].
	^c! !
!RandomTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50760919!
testNext
	"Generate some float values, and see if they are in the [0,1) interval. Also check that the smallest and the largest values are small/large enough."

	| random min max |
	min := Float infinity.
	max := Float negativeInfinity.
	random := Random seed: 112629.
	100000 timesRepeat: [
		| next | 
		next := random inc.
		next < min ifTrue: [ min := next ].
		next > max ifTrue: [ max := next ].
		self assert: next >= 0.0 description: [ 'Generated value ', next asString, ' should be non-negative.' ].
		self assert: next < 1.0 description: [ 'Generated value ', next asString, ' should be less than 1.0.' ] ].
	self assert: max > 0.9999 description: 'The largest generated value should be greater than 0.9999.'.
	self assert: min < 0.0001 description: 'The smallest generated value should be less than 0.0001.'! !
!LayoutMorph class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50563585!
launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random inc print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row _ LayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16891233 overrides: 16914015!
next: anInteger 
	"Answer the next anInteger elements of my collection. Must override 
	because default uses self contents species, which might involve a large 
	collection."

	| newArray |
	newArray := self collectionSpecies new: anInteger.
	1 to: anInteger do: [:index | newArray at: index put: self inc].
	^newArray! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50908989!
push: anElement 
	elements add: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex inc .
	! !
!FixedGregorianDate class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50736113!
tomorrow
	
	^self today inc
! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16891391!
oldBack
	"Go back one element and return it.  Use indirect messages in case I am a StandardFileStream"
	"The method is a misconception about what a stream is. A stream contains a pointer *between* elements with past and future elements. This method considers that the pointer is *on* an element. Please consider unit tests which verifies #back and #oldBack behavior. (Damien Cassou - 1 August 2007)"
	self position = 0 ifTrue: [self error: 'CantGoBack'].
	self position = 1 ifTrue: [self position: 0.  ^ nil].
	self skip: -2.
	^ self inc
! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16925412!
processCommandLineArgument: rawArgStream storeStartUpScriptArgsOn: startUpScriptArgs
	"
	Smalltalk processCommandLineArguments
	
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
	Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -rRequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parametro al script ->>>--// 3''
	"
	| p data entry |
	p _ rawArgStream inc.

	(p first = $- and: [ p size > 1 ]) ifTrue: [
		"If the command is not included in p, it is next argument"
		p size = 2
			ifTrue: [
				"as in 		-r RequiredFeature1"
				data _ rawArgStream inc ]
			ifFalse: [
				"as in 		-rRequiredFeature2"
				data _ p copyFrom: 3 to: p size ].
		p second caseOf: {
			[ $r ] -> [		"as in 		-rRequiredFeature2"
				{ 'Feature require: '. data } print.
				[ Feature require: data ] on: UnhandledError do: [:ex | ex return] ].
			[ $d ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
				{ 'Compiler evaluate: '. data } print.
				[ Compiler evaluate: data ] on: UnhandledError do: [:ex | ex return] ].
			[ $s ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parametro al script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
				[ rawArgStream atEnd ] whileFalse: [
					startUpScriptArgs nextPut: rawArgStream inc ].
				"Can use 'Smalltalk startUpScriptArguments' inside the startUp script
				{ 'Compiler evaluate contents of file named: '. data. ' arguments: '. Smalltalk startUpScriptArguments } print."
				entry _ data asFileEntry.
				entry exists ifTrue: [
					entry readStreamDo: [ :stream |
						[ Compiler evaluate: stream contentsOfEntireFile ] on: UnhandledError do: [:ex | ex return]]].
				"Maybe we decide to clear them after startup script execution
				startUpScriptArguments _ nil" ]
		}
		otherwise: []
	]! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16827195 overrides: 16914011!
next
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type _ byteStream inc.
	type ifNil: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType _ self noteCurrentReference: type.
	selector _ #(readNil readTrue readFalse readInteger	"<-4"
			readStringOld readSymbol readByteArray		"<-7"
			readArray readInstance readReference readBitmap	"<-11"
			readClass readUser readFloat errorRead readShortInst 	"<-16"
			readString readWordArray readWordArrayForSegment 	"<-19"
			readWordLike readMethod 
			readCharacter "<-22") at: type.
	selector = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
			byteStream close. 
			self error: 'file is more recent than this system'. ^ nil].
	anObject _ self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject _ anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16891607!
match: subCollection
	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."

	| pattern startMatch |
	pattern _ ReadStream on: subCollection.
	startMatch _ nil.
	[pattern atEnd] whileFalse: 
		[self atEnd ifTrue: [^ false].
		(self inc) = (pattern inc) 
			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]
			ifFalse: [pattern position: 0.
					startMatch ifNotNil: [
						self position: startMatch.
						startMatch _ nil]]].
	^ true

! !
!StdIOReadStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 50332464!
peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self inc.
		^ true].
	^ false! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:33' prior: 16914015!
next: anInteger 
	"Answer the next anInteger number of objects accessible by the receiver."

	| aCollection |
	aCollection _ OrderedCollection new.
	anInteger timesRepeat: [aCollection addLast: self inc].
	^aCollection! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16827858 overrides: 50911071!
next: anInteger
    "Answer an Array of the next anInteger objects in the stream."
    | array |

    array _ Array new: anInteger.
    1 to: anInteger do: [:i |
        array at: i put: self inc].
    ^ array! !
!ParkMiller88RandomTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50761079!
testParkMillerCorrectness
	"The correctness test suggested by the authors"

	| random next |
	random _ self rng seed: 1.
	10000 timesRepeat: [next _ random inc].
	self assert: next * 16r7FFFFFFF = 1043618065.0! !
!Month class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50342418 overrides: 16882927!
readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream inc ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]
		ifFalse: ["MM-YY or YY-MM"
			month _ year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _ year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !
!NegatedTimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50740175!
testStream

	| timeLineFilter stream |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.

	stream := timeLineFilter negated streamFrom: (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 02).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 04).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 05).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 06).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 07).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 08).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 09).
	self assert: stream inc = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 11)! !
!TimeLineFilterStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50738812!
peek
	
	| nextDate |
	
	nextDate := current.
	[ nextDate := nextDate inc.
	(timeLineFilter includes: nextDate) ] whileFalse.

	^nextDate! !
!Form class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16849027!
fromBinaryStream: aBinaryStream
	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."

	| firstByte |
	firstByte _ aBinaryStream inc.
	firstByte = 2 ifTrue: [
		"Squeak form format"
		^ self new readFrom: aBinaryStream].

	"Try for JPG, GIF, or PCX..."
	"Note: The following call closes the stream."
	^ ImageReadWriter formFromStream: aBinaryStream
! !
!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16897696 overrides: 50332180!
next

	| byte |
	^ isBinary 
			ifTrue: [byte _ super inc.
				 byte ifNil: [nil] ifNotNil: [byte numericValue]]
			ifFalse: [super inc].
! !
!DateAndTime class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16829354!
tomorrow

	^ self today date inc start! !
!ByteArray methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16793853!
readHexFrom: aStream
	"Initialize the receiver from a hexadecimal string representation
		ByteArray readHexFrom: '1E1e'
		ByteArray readHexFrom: '1e1E'
		ByteArray readHexFrom: '1e1e'
	Note: lowercase hex digits are supported here, because we are reading strictly bytes.
	But are not really general, because lowercase e is used to denote scientific notation:
		16r1e0 = 1
		16r1E0 = 480
	"
	| map v ch value |
	map := '0123456789ABCDEF'.
	1 to: self size do: [ :i |
		ch := aStream inc asUppercase.
		v := (map indexOf: ch) - 1.
		 (v between: 0 and: 15) ifFalse: [ ^self error: 'Hex digit expected' ].
		value := v bitShift: 4.
		ch := aStream inc asUppercase.
		v := (map indexOf: ch) - 1.
		(v between: 0 and: 15) ifFalse: [ ^self error: 'Hex digit expected' ].
		value := value + v.
		self at: i put: value.
	]! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16891214!
crLfNextLine
	"Answer next line (may be empty), or nil if at end.
	Support any line ending convention"

	| answer lineSeparators c |
	self atEnd ifTrue: [^nil].
	lineSeparators _ {Character cr. Character lf}.
	answer _ self upToAny: lineSeparators.
	c _ self peek.
	c = Character cr ifTrue: [self inc. c _ self peek].
	c = Character lf ifTrue: [self inc].
	^answer! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16820892!
tempsSubSequenceFrom: tempNamesStream
	^Array streamContents:
		[:tsss|
		[tempNamesStream skipSeparators.
		 tempNamesStream atEnd
		 or: ['[]()' includes: tempNamesStream peek]] whileFalse:
			[tsss nextPut: (String streamContents:
							[:s|
							[s nextPut: tempNamesStream inc.
							 tempNamesStream peek
								ifNil: [true]
								ifNotNil: [:peek| ' []()' includes: peek]] whileFalse])]]

	"thisContext method tempsSubSequenceFrom: 'les temps perdu(sont n''est pas la)' readStream"
	"thisContext method tempsSubSequenceFrom: ('les temps perdu(sont n''est pas la)' readStream skipTo: $(; yourself)"! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16891292!
nextDelimited: terminator
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character.  For example: 'this '' was a quote'. Start postioned before the initial terminator."

	| out ch |
	out _ WriteStream on: (String new: 1000).
	self atEnd ifTrue: [^ ''].
	self inc == terminator ifFalse: [self skip: -1].	"absorb initial terminator"
	[(ch _ self inc) == nil] whileFalse: [
		(ch == terminator) ifTrue: [
			self peek == terminator ifTrue: [
				self inc.  "skip doubled terminator"
			] ifFalse: [
				^ out contents  "terminator is not doubled; we're done!!"
			].
		].
		out nextPut: ch.
	].
	^ out contents! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16884874!
nextWordFrom: aStream setCharacter: aBlock

	| outStream char |
	outStream _ WriteStream on: (String new: 16).
	[ (aStream peekFor: Character space) or: [ aStream peekFor: Character tab ]] whileTrue.
	[ aStream atEnd or: [
		char _ aStream inc.
		char isSeparator ]]
			whileFalse: [ outStream nextPut: char ].
	aBlock value: char.
	^ outStream contents! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16891826!
nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator out ch |
	terminator _ $!!.
	out _ WriteStream on: (String new: 1000).
	self skipSeparators.
	[(ch _ self inc) == nil] whileFalse: [
		(ch == terminator) ifTrue: [
			self peek == terminator ifTrue: [
				self inc.  "skip doubled terminator"
			] ifFalse: [
				^ out contents  "terminator is not doubled; we're done!!"
			].
		].
		out nextPut: ch.
	].
	^ out contents! !
!CircularReadStreamTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50721904!
testNext

	self assert: stream inc = 2.
	self assert: stream inc = 3.
	self assert: stream inc = 4.
	self assert: stream inc = 5.
	self assert: stream inc = 1! !
!NegatedTimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50739905!
testNextPositiveDuration

	| timeLineFilter date |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
		
	date := (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01).
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day with: 1))) = date inc.
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day with: 2))) = (date next: (TimeUnits day with: 3)).
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day with: 0))) = date! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50742940!
testTomorrow

	| today |
	today := FixedGregorianDate today.
	self assert: FixedGregorianDate tomorrow = today inc! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16913994!
basicNext

	^ self inc! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16891846!
skipSeparators
	[self atEnd]
		whileFalse:
		[self inc isSeparator ifFalse: [^ self position: self position-1]]! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16827956!
exampleWithPictures
	"
	DataStream exampleWithPictures
	"
	| f result |
	f _ Form fromUser.
	'Test-Picture' asFileEntry writeStreamDo: [ :file |
		file binary.
		(DataStream on: file) nextPut: f ].

	'Test-Picture' asFileEntry readStreamDo: [ :file |
		file binary.
		result _ (DataStream on: file) inc ].

	result display! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16891526 overrides: 50909656!
upToEnd
	"Answer a subcollection from the current access position through the last element of the receiver."

	| newStream |
	newStream := WriteStream on: (self collectionSpecies new: 100).
	[self atEnd] whileFalse: [ newStream nextPut: self inc ].
	^ newStream contents! !
!Number class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50629850!
readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar exp scale convertToFloat |

	convertToFloat := false.
	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedToInteger: aStream position - fracpos).
					value := value + fraction.
					convertToFloat := true ]
				ifFalse: [
					"oops - just <integer>."
					aStream skip: -1.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	('deqp' includes: peekChar)
		ifTrue: [			"<number>(e|d|q)<exponent>>" "<number>(p)<binaryExponent>>"
			aStream inc.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ '+-' includes: aStream peek ]])
				ifTrue:  [
					exp := Integer readFrom: aStream.
					scale := (peekChar = $p ifTrue: [2] ifFalse: [base]) raisedToInteger: exp.
					value := value * scale ]
				ifFalse: [
					"oops - just <number>."
					aStream skip: -1.]].
	^convertToFloat
		ifTrue: [
			(value = 0.0 and: [ sign = -1 ])
				ifTrue: [ Float negativeZero ]
				ifFalse: [ (value * sign) asFloat ]]
		ifFalse: [ value * sign ]! !
!Timespan methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 16938139!
do: aBlock with: aFirstElement when: aConditionBlock

	| element end |
	element _ aFirstElement.
	end _ self end.
	[ element start <= end ] whileTrue:
	
	[(aConditionBlock value: element)
			ifTrue: [ aBlock value: element ].
		element _ element inc. ]! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50746341!
testNext

	self assert: (GregorianYear number: 2004) inc=(GregorianYear number: 2005).
	self assert: (GregorianYear number: -1) inc=(GregorianYear number: 1).
	

	! !
!CharacterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:34' prior: 50762455!
testSomeLatinCharsToUtf8
	"
	CharacterTest new testSomeLatinCharsToUtf8
	"
	| characters bytes |
	characters _ '' readStream.
	bytes _ ByteArray streamContents: [ :strm |
		[ characters atEnd ] whileFalse: [
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOfUnicodeCodePoint: characters inc codePoint ]].
	self assert: bytes hex = 'C3A1C3A5C3A6C3B1C386C2A5C3BC'! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16917175!
getEnclosedExpressionFrom: aStream 
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"
	| result currentChar |
	result := String new writeStream.

	[aStream atEnd 
		or: [(currentChar := aStream inc) == $}]]
		whileFalse: [result nextPut: currentChar].

	^ result contents withBlanksTrimmed! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16820798!
mapFromBlockKeys: keys toSchematicTemps: schematicTempNamesString
	"Decode a schematicTempNamesString that encodes the layout of temp names
	 in a method and any closures/blocks within it, matching keys in keys to
	 vectors of temp names."
	| map tempNames |
	map := Dictionary new.
	tempNames := schematicTempNamesString readStream.
	keys do:
		[:key| | tempSequence tempIndex |
		tempSequence := OrderedCollection new.
		tempIndex := 0.
		[(tempNames skipSeparators; peek) ifNil: [true] ifNotNil: [:ch| '[]' includes: ch]] whileFalse:
			[tempNames peek = $(
				ifTrue: [tempSequence addAll: ((self tempsSubSequenceFrom: (tempNames inc; yourself)) withIndexCollect:
														[:temp :index|
														{ temp. { tempIndex + 1. index } }]).
						tempNames peek ~= $) ifTrue: [self error: 'parse error'].
						tempIndex := tempIndex + 1.
						tempNames inc]
				ifFalse: [tempSequence addAll: ((self tempsSubSequenceFrom: tempNames) withIndexCollect:
														[:temp :index|
														{ temp. tempIndex := tempIndex + 1 }])]].
		map at: key put: tempSequence asArray.
		[tempNames peek = $]] whileTrue: [tempNames inc].
		tempNames peek = $[ ifTrue:
			[tempNames inc]].
	^map! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 50588678!
nextNumber
	"Answer a number from the (text) stream."

	|element|
	[(element := self inc) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16891443!
peekFor: anObject 
	"Answer false and do not move over the next element if it is not equal to 
	the argument, anObject, or if the receiver is at the end. Answer true 
	and increment the position for accessing elements, if the next element is 
	equal to anObject."

	| nextObject |
	self atEnd ifTrue: [^false].
	nextObject _ self inc.
	"peek for matching element"
	anObject = nextObject ifTrue: [^true].
	"gobble it if found"
	position _ position - 1.
	^false! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16891506!
upToAny: aCollection 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
	| newStream element |
	newStream := WriteStream on: (self collectionSpecies new: 100).
	[self atEnd or: [aCollection includes: (element := self inc)]]
		whileFalse: [newStream nextPut: element].
	(aCollection includes: element)
		ifTrue: [self skip: -1].
	^newStream contents! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16827353!
readArray
	"PRIVATE -- Read the contents of an Array.
	 We must do beginReference: here after instantiating the Array
	 but before reading its contents, in case the contents reference
	 the Array. beginReference: will be sent again when we return to
	 next, but that's ok as long as we save and restore the current
	 reference position over recursive calls to next."
	| count array refPosn |

	count _ byteStream nextUnsignedInt32BigEndian: true.

	refPosn _ self beginReference: (array _ Array new: count).		"relative pos"
	1 to: count do: [:i |
		array at: i put: self inc].
	self setCurrentReference: refPosn.		"relative pos"
	^ array! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16827608!
readWordLike
	| refPosn aSymbol newClass anObject |
	"Can be used by any class that is bits and not bytes (WordArray, Bitmap, SoundBuffer, etc)."

	refPosn _ self getCurrentReference.
	aSymbol _ self inc.
	newClass _ Smalltalk at: aSymbol asSymbol.
	anObject _ newClass newFromStream: byteStream.
	"Size is number of long words."
	self setCurrentReference: refPosn.  "before returning to next"
	^ anObject
! !
!RandomTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 50761019!
testSeedAndRepeatability
	| random seed a b c |
	random := self rng.
	seed _ ((1 << 100) negated to: 1 << 100) atRandom.
	random seed: seed.
	a _ random inc.
	b _ random inc.
	c _ random nextBits: 100.
	random seed: seed.
	self assert: random inc = a.
	self assert: random inc = b.
	self assert: (random nextBits: 100) = c! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16916498!
asUtf8: convertEmbeddedNCRs
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^ByteArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream inc.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					Character
						evaluate: [ :byte | outStream nextPut: byte ]
						withUtf8BytesOfUnicodeCodePoint: codePoint ]]]! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16899552 overrides: 16827156!
beginInstance: aClass size: anInteger
	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."
	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.
	In ReferenceStream, class is just 5 bytes for shared symbol.
	SmartRefStream puts out the names and number of class's instances variables for checking.
6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "

	| short ref |
	short _ true.	"All tests for object header that can be written in 4 bytes"
	anInteger <= 254 ifFalse: [short _ false].	"one byte size"
	ref _ references at: aClass name ifAbsent: [short _ false. nil].
	ref isInteger ifFalse: [short _ false].
	short ifTrue: [short _ (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"
	short ifTrue: [
		byteStream skip: -1.
		short _ byteStream inc = 9.
		byteStream skip: 0].	"ugly workaround"
	short 
		ifTrue: ["passed all the tests!!"
			byteStream skip: -1; nextPut: 16; "type = short header"
				nextPut: anInteger + 1;	"size is short"
				nextUnsignedInt16Put: ref bigEndian: true ]
		ifFalse: [
			"default to normal longer object header"
			byteStream nextUnsignedInt32Put: anInteger + 1 bigEndian: true.
			self nextPut: aClass name].! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16831575!
case: dist
	"statements = keyStmts #CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add #CascadeFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	stack addLast: #CaseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).

	stack last == #CaseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns weirdly I guess)"
			stack removeLast. "get rid of #CaseFlag"
			stmtStream := ReadStream on: (self popTo: stack removeLast).
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream inc) == #CascadeFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream inc)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16868862!
emitCodeForCase: stack encoder: encoder value: forValue

	| braceNode sizeStream allReturn |
	forValue ifFalse:
		[^super emitCodeForEffect: stack encoder: encoder].
	braceNode := arguments first.
	sizeStream := ReadStream on: sizes.
	receiver emitCodeForValue: stack encoder: encoder.
	"There must be at least one branch around the otherwise/caseError
	  so the decompiler can identify the end of the otherwise/caseError."
	allReturn := true. "assume every case ends with a return"
	braceNode casesForwardDo:
		[:keyNode :valueNode :last | | thenSize elseSize |
		thenSize := sizeStream inc.
		elseSize := sizeStream inc.
		last ifFalse: [encoder genDup. stack push: 1].
		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.
		equalNode emitCode: stack args: 1 encoder: encoder.
		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.
		last ifFalse: [encoder genPop. stack pop: 1].
		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.
		last ifTrue: [stack pop: 1].
		valueNode returns ifFalse:
			[self emitCodeForJump: elseSize encoder: encoder.
			 allReturn := false].
		(last and: [allReturn]) ifTrue:
			[self emitCodeForJump: elseSize encoder: encoder]].
	arguments size = 2
		ifTrue:
			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"
		ifFalse:
			[NodeSelf emitCodeForValue: stack encoder: encoder.
			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 16828073!
testWith: anObject
	"As a test of DataStream/ReferenceStream, write out anObject and read it back.
	11/19/92 jhm: Set the file type. More informative file name.
	DataStream testWith: 'hi'
	ReferenceStream testWith: 'hi'
	"
	| result |

	(self name, ' test') asFileEntry writeStreamDo: [ :file |
		file binary.
		(self on: file) nextPut: anObject ].

	(self name, ' test') asFileEntry readStreamDo: [ :file |
		file binary.
		result _ (self on: file) inc ].

	^ result! !
!FebruaryGregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 50741488!
testNext

	self assert: GregorianMonth february inc = GregorianMonth march.! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:35' prior: 50743982!
testDayPositionedInWeek

	| day |
	
	day := GregorianDay sunday.
	1 to: 7 do: [ :aNumber | 
		self assert: (GregorianDay dayPositionedInWeek: aNumber)=day.
		day := day inc ].
	
	self 
		should: [ GregorianDay dayPositionedInWeek: 0 ]
		raise: InvalidGregorianDayNumberException
		withExceptionDo: [ :anException |
			self assert: anException dayNumber = 0.
			self assert: anException description notNil ].

	self 
		should: [ GregorianDay dayPositionedInWeek: 8 ]
		raise: InvalidGregorianDayNumberException 
		withExceptionDo: [ :anException |
			self assert: anException dayNumber = 8.
			self assert: anException description notNil ]! !
!Week class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50342223 overrides: 16882927!
readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream inc = $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber _ Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber _ yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !
!Time class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50587867 overrides: 16882927!
readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second ampm nanos nanosBuffer |
	hour := Integer readFrom: aStream.
	minute := 0.
	second := 0.
	nanosBuffer := '000000000' copy.
	nanos := WriteStream on: nanosBuffer.
	(aStream peekFor: $:) 
		ifTrue: [
			minute := Integer readFrom: aStream.
			(aStream peekFor: $:) 
				ifTrue: [
					second := Integer readFrom: aStream].
					(aStream peekFor: $.)
						ifTrue: [
							[aStream atEnd not and: [aStream peek isDigit]]
								whileTrue: [nanos nextPut: aStream inc]]].
	aStream skipSeparators.
	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: 
		[ampm := aStream inc asLowercase.
	
	(ampm = $p and: [hour < 12]) ifTrue: [hour := hour + 12].
		(ampm = $a and: [hour = 12]) ifTrue: [hour := 0].
	
	(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self 
		hour: hour 
		minute: minute 
		second: second 
		nanoSecond: nanosBuffer asNumber

	"Time readFrom: (ReadStream on: '2:23:09 pm')"! !
!StandardFileStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16913060 overrides: 50911587!
peekFor: item 
	"Answer false and do not advance if the next element is not equal to item, or if this stream is at the end.  If the next element is equal to item, then advance over it and return true"
	| next |
	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"
	(next _ self inc) ifNil: [^ false].
	item = next ifTrue: [^ true].
	self skip: -1.
	^ false! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16891255!
next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| obj |
	0 to: n-1 do: [ :i |
		(obj _ self inc) ifNil: [ ^aCollection copyFrom: 1 to: startIndex+i-1 ].
		aCollection at: startIndex+i put: obj].
	^aCollection! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16827317!
objectAt: anInteger
	"PRIVATE -- Read & return the object at a given stream position.  08:18 tk  anInteger is a relative file position. "
	| savedPosn anObject refPosn |

	savedPosn _ byteStream position.		"absolute"
	refPosn _ self getCurrentReference.	"relative position"

	byteStream position: anInteger + basePos.	"was relative"
	anObject _ self inc.

	self setCurrentReference: refPosn.		"relative position"
	byteStream position: savedPosn.		"absolute"
	^ anObject! !
!Object methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16881998!
readDataFrom: aDataStream size: varsOnDisk
	"Fill in the fields of self based on the contents of aDataStream.  Return self.
	 Read in the instance-variables written by Object>>storeDataOn:.
	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.
	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."
	| cntInstVars cntIndexedVars |

	cntInstVars _ self class instSize.
	self class isVariable
		ifTrue: [cntIndexedVars _ varsOnDisk - cntInstVars.
				cntIndexedVars < 0 ifTrue: [
					self error: 'Class has changed too much.  Define a convertxxx method']]
		ifFalse: [cntIndexedVars _ 0.
				cntInstVars _ varsOnDisk]. 	"OK if fewer than now"

	aDataStream beginReference: self.
	1 to: cntInstVars do:
		[:i | self instVarAt: i put: aDataStream inc].
	1 to: cntIndexedVars do:
		[:i | self basicAt: i put: aDataStream inc].
	"Total number read MUST be equal to varsOnDisk!!"
	^ self	"If we ever return something other than self, fix calls 
			on (super readDataFrom: aDataStream size: anInteger)"! !
!TimeLineFilterStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50738832!
skip: aNumberOfDays

	| daysToSkip |
	
	daysToSkip := (aNumberOfDays convertTo: TimeUnits day) amount.
	daysToSkip > 0 
		ifTrue: [ daysToSkip timesRepeat: [ self inc ] ]
		ifFalse: [ daysToSkip negated timesRepeat: [ self previous ] ]! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16911377 overrides: 50910290!
readShortInst
	"Instance has just one byte of size.  Class symbol is encoded in two bytes of file position.  See readInstance."
	| instSize className refPosn |

	instSize _ (byteStream inc) - 1.	"one byte of size"
	refPosn _ self getCurrentReference.
	className _ self readShortRef.	"class symbol in two bytes of file pos"
	^ self readInstanceSize: instSize clsname: className refPosn: refPosn
! !
!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16782346!
nextValue
	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"
	| raw num |
	FromCharTable ifNil: [ self class initializeTables ].
	[
		raw := mimeStream inc.
		raw ifNil: [^ nil].	"end of stream"
		raw == $= ifTrue: [^ nil].
		num := FromCharTable at: raw asciiValue + 1.
		num ifNotNil: [^ num].
		"else ignore space, return, tab, ..."
	] repeat! !
!FixedGregorianDate class methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50736124!
year: aGregorianYear numberOfDaysFromJanuaryFirst: aNumberOfDays 

	| month remaindingDays |
	
	month := aGregorianYear firstMonth.
	remaindingDays := aNumberOfDays.
	
	[month numberOfDays <= remaindingDays] whileTrue: 
			[remaindingDays := remaindingDays - month numberOfDays.
			month := month inc].
	
	^self monthOfYear: month dayNumber: (remaindingDays amount + 1)! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16917460!
format: aCollection 
	"format the receiver with aCollection  
	 
	simplest example:  
	'foo {1} bar' format: {Date today}.
	 
	complete example:  
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}.  
	"
	| result stream |
	result := String new writeStream.
	stream := self readStream.

	[stream atEnd]
		whileFalse: [| currentChar | 
			currentChar := stream inc.
			currentChar == ${
				ifTrue: [| expression | 
					expression := self getEnclosedExpressionFrom: stream.
					result
						nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
				ifFalse: [
					currentChar == $\
						ifTrue: [stream atEnd
								ifFalse: [result nextPut: stream inc]]
						ifFalse: [result nextPut: currentChar]]].

	^ result contents! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50745719!
testNext

	self assert: GregorianMonth december inc = GregorianMonth january.
	self assert: GregorianMonth january inc = GregorianMonth february.
	self assert: GregorianMonth february inc = GregorianMonth march! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50603185!
xDigit
	"Form a number."

	tokenType := #number.
	(aheadChar == DoItCharacter and: [source atEnd
			and:  [source skip: -1. source inc ~~ DoItCharacter]])
		ifTrue: [source skip: -1 "Read off the end last time"]
		ifFalse: [source skip: -2].
	token := [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].
	self step; step! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50331704!
peek
	"Answer what would be returned if the message next were sent to the 
	receiver. If the receiver is at the end, answer nil."

	| nextObject |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^nil].
	nextObject _ self inc.
	position _ position - 1.
	^nextObject! !
!Base64MimeConverter methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 16782306!
mimeEncode
	"Do conversion reading from dataStream writing to mimeStream"
	"Convert from data to 6 bit characters."

	| phase1 phase2 byte nib lineLength |
	ToCharTable ifNil: [ self class initializeTables ].
	phase1 := phase2 := false.
	lineLength := 0.
	[dataStream atEnd] whileFalse: [
		(multiLine and:[lineLength >= 70]) ifTrue: [ mimeStream newLine.  lineLength := 0. ].
		data := byte := dataStream inc.
		nib := (data bitAnd: 16rFC) bitShift: -2.
		mimeStream nextPut: (ToCharTable at: nib+1).
		(byte := dataStream inc) ifNil: [byte := 0. phase1 := true].
		data := ((data bitAnd: 3) bitShift: 8) + byte.
		nib := (data bitAnd: 16r3F0) bitShift: -4.
		mimeStream nextPut: (ToCharTable at: nib+1).
		(byte := dataStream inc) ifNil: [byte := 0. phase2 := true].
		data := ((data bitAnd: 16rF) bitShift: 8) + (byte).
		nib := (data bitAnd: 16rFC0) bitShift: -6.
		mimeStream nextPut: (ToCharTable at: nib+1).
		nib := (data bitAnd: 16r3F).
		mimeStream nextPut: (ToCharTable at: nib+1).

		lineLength := lineLength + 4.].
	phase1 ifTrue: [
		mimeStream skip: -2; nextPut: $=; nextPut: $=.
		^ mimeStream].
	phase2 ifTrue: [
		mimeStream skip: -1; nextPut: $=.
		^ mimeStream]! !
!GregorianYear methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:36' prior: 50738323!
nextLeapYear

	| newYear |
	
	newYear := self inc.
	[ newYear isLeap ] whileFalse: [ newYear := newYear inc ].
	
	^newYear
! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16923485!
recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #inc 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	"An array of the 255 Characters in ascii order.
	 Cog inlines table into machine code at: prim so do not regenerate it."
"	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character numericValue: ascii])."
" 	 This is nil in Spur, which has immediate Characters."
	newArray at: 25 put: (self specialObjectsArray at: 25).
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	"An array of up to 31 classes whose instances will have compact headers; an empty array in Spur"
	newArray at: 29 put: self compactClassesArray.
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Prototype instances that can be copied for fast initialization"
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
"	newArray at: 32 put: Float new.
	newArray at: 33 put: (LargePositiveInteger new: 4).
	newArray at: 34 put: Point new."
	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.

	"Note: This must be fixed once we start using context prototypes (yeah, right)"
	"(MethodContext new: CompiledMethod fullFrameSize)."
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"
	newArray at: 36 put: nil. "was the prototype MethodContext"

	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Weak reference finalization"
	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).
	"(jmv) Maybe needed to share cod with V3 (Non-Spur?)"
	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray
	! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50744902!
testNext

	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) inc) = (GregorianMonthOfYear februaryOf: (GregorianYear number: 2004)).
	self assert: ((GregorianMonthOfYear decemberOf: (GregorianYear number: 2004)) inc) = (GregorianMonthOfYear januaryOf: (GregorianYear number: 2005))
	! !
!PositionableStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16891852!
unCommand
	"If this read stream is at a <, then skip up to just after the next >.  For removing html commands."
	| char |
	[self peek = $<] whileTrue: ["begin a block"
		[self atEnd == false and: [self inc ~= $>]] whileTrue.
		"absorb characters"
		].
 ! !
!FloatTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50753296!
testFloatRounded
	"5000000000000001 asFloat has an exact representation (no round off error).
	It should round to nearest integer without loosing bits.
	This is a no regression test on http://bugs.squeak.org/view.php?id=7134"
	
	| x y int r |
	
	"This is a preamble asserting exactness of representation
	and quality of various conversions"
	int := 5000000000000001.
	x := int asFloat.
	y := (5 asFloat squared squared squared squared timesTwoPower: 15) + 1.
	self assert: x = y.
	self assert: x asTrueFraction = int.
	
	"this one should be true for any float
	in order to conform to ISO/IEC 10967-2"
	self assert: x rounded = x asTrueFraction rounded.
	self assert: x negated rounded = x negated asTrueFraction rounded.

	"a random test"
	r := Random new.
	10000 timesRepeat: [
		x := r inc * 1.9999e16 + 1.0e12 .
		self assert: x rounded = x asTrueFraction rounded.
		self assert: x negated rounded = x negated asTrueFraction rounded]! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16932733!
indent: delta fromStream: inStream toStream: outStream
	"Append the contents of inStream to outStream, adding or deleting delta or -delta
	 tabs at the beginning, and after every NewLine except a final NewLine.  Do not add tabs
	 to totally empty lines, and be sure nothing but tabs are removed from lines."

	| ch skip tab prev atEnd |
	tab _ Character tab.
	delta > 0
		ifTrue: [
			"shift right"
			prev _ Character newLineCharacter.
			[
			ch _ (atEnd _ inStream atEnd)
				ifTrue: [ Character newLineCharacter ]
				ifFalse: [ inStream inc ].
			(prev isLineSeparator and: [ ch isLineSeparator not ]) ifTrue: [ delta timesRepeat: [ outStream nextPut: tab ]].
			atEnd ] whileFalse: [
				outStream nextPut: ch.
				prev _ ch ]]
		ifFalse: [
			"shift left"
			skip _ delta.
			"a negative number"
			[ inStream atEnd ] whileFalse: [
				((ch _ inStream inc) == tab and: [ skip < 0 ]) ifFalse: [ outStream nextPut: ch ].
				skip _ ch isLineSeparator
					ifTrue: [ delta ]
					ifFalse: [ skip + 1 ]]]! !
!Timespan methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16938020!
end

	^ self duration totalNanoSeconds = 0
		ifTrue: [ self start ]
		ifFalse: [ self inc start - DateAndTime clockPrecision ]! !
!RandomTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50761042!
testSimpleBuckets
	"This is a poor test, see Knuth's TAOCP"

	| nbuckets buckets nSamples random slot |
	nbuckets _ 1000.
	buckets _ Array new: nbuckets.
	buckets atAllPut: 0.
	nSamples _ 1000.
	random _ self rng.
	nSamples * nbuckets timesRepeat:
		[
			slot := (random inc * nbuckets) floor + 1.
			buckets at: slot put: (buckets at: slot) + 1
		].
	buckets do:
		[:each |
			"max ~17% deviation"
			self assert: (each - nSamples * 6) abs < nSamples
		]! !
!StandardFileStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16913502 overrides: 50911421!
upToEnd
	"Answer a subcollection from the current access position through the last element of the receiver."

	^self collectionSpecies streamContents: [ :newStream |
		| next |
		[ (next := self inc) == nil ] whileFalse: [
			newStream nextPut: next ] ]! !
!LaggedFibonacciRandom methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16862071 overrides: 16897847!
nextChunkBits
	"This method generates random instances of Integer in the interval
	0 to 16r1FFFFFFFFFFFFF (53 bits)."
	
	^self inc timesTwoPower: self nextChunkSize :: truncated! !
!Stream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 16914117!
do: aBlock 
	"Evaluate aBlock for each of the objects accessible by receiver."

	[self atEnd]
		whileFalse: [aBlock value: self inc]! !
!TimeLineFilterStreamTest methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50740634!
testReset

	| timeLineFilter stream januaryFirstOf2004 januaryThirdOf2004 januaryTenOf2004 |
	
	januaryFirstOf2004 := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01.
	januaryThirdOf2004 := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 03.
	januaryTenOf2004 := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 10.
	timeLineFilter := TimeLineFilter new.
	timeLineFilter addRule: (timeLineFilter dayRule: GregorianDay saturday).

	stream := TimeLineFilterStream from: januaryFirstOf2004 using: timeLineFilter.
	self assert: stream inc = januaryThirdOf2004.
	self assert: stream inc = januaryTenOf2004.
	
	stream reset.
	self assert: stream inc = januaryThirdOf2004.
	self assert: stream inc = januaryTenOf2004! !
!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50909033 overrides: 50909301!
inc

	| byte |
	^ isBinary 
			ifTrue: [byte _ super inc.
				 byte ifNil: [nil] ifNotNil: [byte numericValue]]
			ifFalse: [super inc].
! !
!ImageReadWriter methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50909085!
inc

	^stream inc! !
!ReferenceStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50909092 overrides: 50909152!
inc
	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."
	| curPosn skipToPosn haveIt theObject wasSkipping |

	haveIt _ true.
	curPosn _ byteStream position - basePos.
	theObject _ objects at: curPosn ifAbsent: [haveIt _ false].
		"probe in objects is done twice when coming from objectAt:.  This is OK."
	skipToPosn _ fwdRefEnds at: curPosn ifAbsent: nil.
	haveIt ifFalse: [ ^ super inc].

	skipToPosn ifNotNil: [
		"Skip over the object and return the already-read-in value."
		byteStream position: skipToPosn + basePos		"make absolute"
	] ifNil: [
		"File is not positioned correctly.  Read object and throw it away."
		wasSkipping _ skipping includes: curPosn.
		skipping add: curPosn.
		"fake _" super inc.
		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: nil].
	].
	^ theObject
		! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50909123 overrides: 50912692!
inc
	"Really write three objects: (version, class structure, object). But only when called from the outside.  "

	| version ss object |
	^ topCall
		ifNil: [ 
			topCall _ #marked.
			version _ super inc.
			version class == SmallInteger ifFalse: [^ version].	
				"version number, else just a regular object, not in our format, "
			ss _ super inc.
			ss class == Array ifFalse: [^ ss].  "just a regular object"
			(ss at: 1) = 'class structure' ifFalse: [^ ss].
			structures _ ss at: 2.
			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 
				ifTrue: [ss at: 4]		"class name -> superclass name"
				ifFalse: [Dictionary new].
			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].
			object _ super inc.	"all the action here"

			topCall _ nil.	"reset it"
			object]
		ifNotNil: [
			super inc]
! !
!DataStream methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:36:37' prior: 50909152 overrides: 50909274!
inc
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type _ byteStream inc.
	type ifNil: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType _ self noteCurrentReference: type.
	selector _ #(readNil readTrue readFalse readInteger	"<-4"
			readStringOld readSymbol readByteArray		"<-7"
			readArray readInstance readReference readBitmap	"<-11"
			readClass readUser readFloat errorRead readShortInst 	"<-16"
			readString readWordArray readWordArrayForSegment 	"<-19"
			readWordLike readMethod 
			readCharacter "<-22") at: type.
	selector = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
			byteStream close. 
			self error: 'file is more recent than this system'. ^ nil].
	anObject _ self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject _ anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject! !

!methodRemoval: ThirtyDaysGregorianMonth #next stamp: 'eb 10/4/2020 20:36:37'!
next
	
	^self next: self oneMonth!

!methodRemoval: RWBinaryOrTextStream #next stamp: 'eb 10/4/2020 20:36:37'!
next

	| byte |
	^ isBinary 
			ifTrue: [byte _ super inc.
				 byte ifNil: [nil] ifNotNil: [byte numericValue]]
			ifFalse: [super inc].
!

!methodRemoval: StdIOReadStream #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	"If last call was #peek, not #next, then just answer cached value."
	peeked
		ifFalse: [ self privateRead ]
		ifTrue: [ peeked _ false ].

	"peeked is always false on exit"
	^buffer1 at: 1!

!methodRemoval: ReadStream #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]!

!methodRemoval: ParkMiller88Random #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Answer a random Float in the interval [0, 1).
	NOTE: this is not a uniformly distributed random Float, since only uses 31 bits out of 53 bits mantissa.
	Additionally, #privateNextChunk can not produce all zeros or all ones.

	A higher quality Float RNG is LaggedFibonacciRandom"

	^ self privateNextChunk asFloat / self m
	
	"In any case, an alternative, slower but better answer could be:
	
	^(self nextBits: 53) asFloat  timesTwoPower: -53"!

!methodRemoval: StandardFileStream #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Answer the next byte from this file, or nil if at the end of the file."

	^ self basicNext!

!methodRemoval: ImageReadWriter #next stamp: 'eb 10/4/2020 20:36:37'!
next

	^stream inc!

!methodRemoval: WriteStream #next stamp: 'eb 10/4/2020 20:36:37'!
next

	self shouldNotImplement!

!methodRemoval: ReferenceStream #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."
	| curPosn skipToPosn haveIt theObject wasSkipping |

	haveIt _ true.
	curPosn _ byteStream position - basePos.
	theObject _ objects at: curPosn ifAbsent: [haveIt _ false].
		"probe in objects is done twice when coming from objectAt:.  This is OK."
	skipToPosn _ fwdRefEnds at: curPosn ifAbsent: nil.
	haveIt ifFalse: [ ^ super inc].

	skipToPosn ifNotNil: [
		"Skip over the object and return the already-read-in value."
		byteStream position: skipToPosn + basePos		"make absolute"
	] ifNil: [
		"File is not positioned correctly.  Read object and throw it away."
		wasSkipping _ skipping includes: curPosn.
		skipping add: curPosn.
		"fake _" super inc.
		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: nil].
	].
	^ theObject
		!

!methodRemoval: SmartRefStream #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Really write three objects: (version, class structure, object). But only when called from the outside.  "

	| version ss object |
	^ topCall
		ifNil: [ 
			topCall _ #marked.
			version _ super inc.
			version class == SmallInteger ifFalse: [^ version].	
				"version number, else just a regular object, not in our format, "
			ss _ super inc.
			ss class == Array ifFalse: [^ ss].  "just a regular object"
			(ss at: 1) = 'class structure' ifFalse: [^ ss].
			structures _ ss at: 2.
			superclasses _ (ss size > 3 and: [(ss at: 3) = 'superclasses']) 
				ifTrue: [ss at: 4]		"class name -> superclass name"
				ifFalse: [Dictionary new].
			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].
			object _ super inc.	"all the action here"

			topCall _ nil.	"reset it"
			object]
		ifNotNil: [
			super inc]
!

!methodRemoval: DataStream #next stamp: 'eb 10/4/2020 20:36:37'!
next
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type _ byteStream inc.
	type ifNil: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType _ self noteCurrentReference: type.
	selector _ #(readNil readTrue readFalse readInteger	"<-4"
			readStringOld readSymbol readByteArray		"<-7"
			readArray readInstance readReference readBitmap	"<-11"
			readClass readUser readFloat errorRead readShortInst 	"<-16"
			readString readWordArray readWordArrayForSegment 	"<-19"
			readWordLike readMethod 
			readCharacter "<-22") at: type.
	selector = 0 ifTrue: [pos _ byteStream position.	"absolute!!!!"
			byteStream close. 
			self error: 'file is more recent than this system'. ^ nil].
	anObject _ self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject _ anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject!

!methodRemoval: CircularReadStream #next stamp: 'eb 10/4/2020 20:36:38'!
next

	^self next: (unit with: 1)!

!methodRemoval: I class #next stamp: 'eb 10/4/2020 20:36:38'!
next
	^self createChildNamed: self name, 'I'
!

!methodRemoval: PointInTime #next stamp: 'eb 10/4/2020 20:36:38'!
next
	
	^self next: self defaultIntervalIncrement!

!methodRemoval: FebruaryGregorianMonth #next stamp: 'eb 10/4/2020 20:36:38'!
next
	
	^self class march!

!methodRemoval: FileStream #next stamp: 'eb 10/4/2020 20:36:38'!
next

	(position >= readLimit and: [self atEnd])
		ifTrue: [^nil]
		ifFalse: [^collection at: (position _ position + 1)]!

!methodRemoval: NonSpecificThirtyOneDaysGregorianMonth #next stamp: 'eb 10/4/2020 20:36:38'!
next
	
	^self next: self oneMonth!

!methodRemoval: JanuaryGregorianMonth #next stamp: 'eb 10/4/2020 20:36:38'!
next
	
	^self class february!

!methodRemoval: Timespan #next stamp: 'eb 10/4/2020 20:36:38'!
next

	^self class classDefinesDuration
		ifTrue: [ self class including: start + duration ]
		ifFalse: [ self class starting: start + duration duration: duration ]!

!methodRemoval: SharedQueue #next stamp: 'eb 10/4/2020 20:36:38'!
next
	"Answer the object that was sent through the receiver first and has not 
	yet been received by anyone. If no object has been sent, suspend the 
	requesting process until one is."

	readSynch wait.
	^accessProtect
		critical: [
			| value |
			readPosition = writePosition
					ifTrue: 
						[self error: 'Error in SharedQueue synchronization'.
						 value := nil]
					ifFalse: 
						[value := contentsArray at: readPosition.
						 contentsArray at: readPosition put: nil.
						 readPosition := readPosition + 1].
			value].!

!methodRemoval: Stream #next stamp: 'eb 10/4/2020 20:36:38'!
next
	"Answer the next object accessible by the receiver."

	self subclassResponsibility!

!methodRemoval: TimeLineFilterStream #next stamp: 'eb 10/4/2020 20:36:38'!
next
	
	current := self peek.	
	^current.
!

!methodRemoval: LaggedFibonacciRandom #next stamp: 'eb 10/4/2020 20:36:38'!
next
	"Answer a random Float in the interval [0, 1)"

	| answer tap1 tap2 |
	tap1 _ self ringAt: self last.
	tap2 _ self ringAt: self last - self minorLag + 1.
	answer _ tap2 - tap1.
	answer < 0.0 ifTrue: [answer _ 1.0 + answer].
	self ringAt: self last put: answer.
	self setLast: self last + 1.
	^answer!

!methodRemoval: OOStackIndex #next stamp: 'eb 10/4/2020 20:36:38'!
next
	
	value := value + 1.!

!methodRemoval: ReadWriteStream #next stamp: 'eb 10/4/2020 20:36:38'!
next
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]!

!methodRemoval: Random #next stamp: 'eb 10/4/2020 20:36:38'!
next
	"Answer a random Float in the interval [0, 1)"

	self subclassResponsibility!

----STARTUP---- (4 October 2020 20:36:52) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Program Files\CuisUniversity\Stack-Exercise.st----!
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:37:15'!
inc
	
	value := value + 1.! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:37:20'!
dec
	
	value := value - 1! !

!methodRemoval: OOStackIndex #next stamp: 'eb 10/4/2020 20:37:24'!
next
	
	value := value + 1.!

!methodRemoval: OOStackIndex #prev stamp: 'eb 10/4/2020 20:37:26'!
prev
	
	value := value - 1!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:37:51' prior: 50913228!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex dec .
	
	self removeElementsAfterIndex .
	
	^ topValue .
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:37:57' prior: 50913235!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new with: anElement .
	topIndex  inc .
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:38:19'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:38:19'!
ERROR!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:38:19'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:38:19'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:38:19'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:38:19'!
ERROR!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:38:20'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:38:20'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:38:20'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:38:20'!
FAILURE!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:38:32' prior: 50913388!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex  inc .
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:38:39'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:38:39'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:38:39'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:38:39'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:38:39'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:38:39'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:38:39'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:38:39'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:38:39'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:38:39'!
FAILURE!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:39:41' prior: 50913249!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) <= topIndex ]! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:39:45'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:39:45'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:39:45'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:39:45'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:39:45'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:39:45'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:39:46'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:39:46'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:39:46'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:39:46'!
FAILURE!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:40:53' prior: 50913467!
removeElementsAfterIndex
	
	elements := elements copyFrom: 0 to: topIndex indexValue.! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:40:56'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:40:56'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:40:56'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:40:56'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:40:56'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:40:56'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:40:56'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:40:56'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:40:56'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:40:56'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:41:26'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:41:26'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:41:26'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:41:26'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:41:26'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:41:26'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:41:26'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:41:26'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:41:26'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:41:26'!
FAILURE!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:41:28'!
ERROR!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:41:54' prior: 50913506!
removeElementsAfterIndex
	
	elements := elements copyFrom: 1 to: topIndex indexValue.! !
!OOStack methodsFor: 'initialization' stamp: 'eb 10/4/2020 20:42:01' prior: 50913217 overrides: 16896425!
initialize
	elements := OrderedCollection new .
	topElement := EmptyStackTop new .
	topIndex  := OOStackIndex new initializeWith: 1.! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:42:07' prior: 50913224!
isEmpty
	^ topIndex indexValue = 1 .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:42:29' prior: 50913242 overrides: 16880927!
size
	^ topIndex indexValue - 1.! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:42:34'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:42:34'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:42:35'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:42:35'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:42:35'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:42:35'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:42:35'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:42:35'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:42:35'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:42:35'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:42:50'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:42:50'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:42:50'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:42:50'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:42:50'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:42:50'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:42:50'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:42:50'!
FAILURE!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:42:50'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:42:50'!
FAILURE!
!EmptyStackTop methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:43:26' prior: 50913327 overrides: 50913310!
topValue
	
	^ self error: OOStack stackEmptyErrorDescription .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:43:30'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:43:30'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:43:30'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:43:41'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:43:41'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:43:42'!
FAILURE!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:43:42'!
PASSED!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:45:51' prior: 50913381!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex dec .
	
	self removeElementsAfterIndex .
	
	[topIndex indexValue = 1] ifTrue: [topElement := EmptyStackTop new. ]
	
	^ topValue .
	
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:45:54'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:45:54'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:45:54'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:45:54'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:45:54'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:45:54'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:45:54'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:45:54'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:45:54'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:45:54'!
PASSED!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:46:21' prior: 50913740!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex dec .
	
	self removeElementsAfterIndex .
	
	[topIndex indexValue = 1] ifTrue: [topElement := EmptyStackTop new. ].
	
	^ topValue .
	
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:46:27'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:46:27'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:46:27'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:46:27'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:46:27'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:46:27'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:46:27'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:46:27'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:46:27'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:46:27'!
PASSED!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:47:05' prior: 50913782!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex dec .
	
	self removeElementsAfterIndex .
		
	^ topValue .
	
	! !
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:47:46' prior: 50913580!
removeElementsAfterIndex
	
	elements := elements copyFrom: 1 to: topIndex indexValue.
	
	[elements size = 0] ifTrue: [ topElement := EmptyStackTop new. ]! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:47:49'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:47:49'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:47:49'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:47:49'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:47:49'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:47:49'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:47:49'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:47:49'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:47:49'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:47:49'!
PASSED!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:48:16' prior: 50913831!
removeElementsAfterIndex
	
	elements := elements copyFrom: 1 to: topIndex indexValue.! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:48:37'!
decTo: aStack
	
	value := value - 1! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:49:32' prior: 50913877!
decTo: aStack
	
	value := value - 1.
	[value = 1] ifTrue: aStack! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:49:42' prior: 50913882!
decTo: aStack
	
	value := value - 1.
	[value = 1] ifTrue: aStack reset .! !
!OOStack methodsFor: 'nil' stamp: 'eb 10/4/2020 20:50:34'!
reset
	self initialize .! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 20:51:11' prior: 50913824!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex decTo: self .
	
	self removeElementsAfterIndex .
		
	^ topValue .
	
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:51:14'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:51:15'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:51:15'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:51:15'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:51:15'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:51:15'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:51:15'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:51:15'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:51:15'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:51:15'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:51:19'!
ERROR!
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:51:30' prior: 50913371!
dec
	
	value := value - 1! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:51:41' prior: 50913888!
decTo: aStack
	
	value := value - 1.
	[^value = 1] ifTrue: [aStack reset] .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:51:44'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:51:44'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:51:44'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:51:44'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:51:44'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:51:44'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:51:44'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:51:44'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:51:44'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:51:44'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:51:46'!
ERROR!
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:51:56' prior: 50913945!
decTo: aStack
	
	value := value - 1.
	[value = 1] value ifTrue: [aStack reset] .! !
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:51:59' prior: 50913987!
decTo: aStack
	
	value := value - 1.
	[value = 1] ifTrue: [aStack reset] .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:52:01'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:52:01'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:52:01'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:52:01'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:52:01'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:52:01'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:52:01'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:52:01'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:52:01'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:52:01'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:52:03'!
ERROR!
!OOStackIndex methodsFor: 'as yet unclassified' stamp: 'eb 10/4/2020 20:52:16' prior: 50913993!
decTo: aStack
	
	value := value - 1.
	(value = 1) ifTrue: [aStack reset] .! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:52:18'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:52:18'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:52:18'!
ERROR!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:52:18'!
ERROR!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:52:18'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:52:18'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:52:18'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:52:18'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:52:18'!
ERROR!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:52:18'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:52:20'!
ERROR!

topIndex indexValue!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:53:53' prior: 50913871!
removeElementsAfterIndex
	
	elements := elements select: [ :each | elements indexOf: each <= topIndex ].! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:53:55'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:53:55'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:53:55'!
ERROR!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:54:04'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:54:04'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:54:04'!
ERROR!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:54:41' prior: 50914077!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) <= topIndex ].! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:54:44'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:54:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:54:44'!
ERROR!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:55:01' prior: 50914154!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) <= topIndex indexValue ].! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:55:03'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:55:03'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:55:03'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:55:21'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:55:21'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:55:21'!
FAILURE!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:55:33'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:55:33'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:55:33'!
FAILURE!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:55:55'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:56:00'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:56:06'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:56:13'!
FAILURE!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:56:13'!
FAILURE!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 20:56:38' prior: 50913123!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: True 
	! !
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 20:56:39' prior: 50914324!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: True. 
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:56:41'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 20:56:41'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 20:56:41'!
FAILURE!
!OOStackTest methodsFor: 'test' stamp: 'eb 10/4/2020 20:56:51' prior: 50914338!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'first'.
	secondPushedObject := 'second'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 20:59:57'!
resetTopElement
	| indexValue |
	indexValue := topIndex indexValue.
	(indexValue = 1) 
		ifTrue: [topElement := EmptyStackTop new.] 
		ifFalse: [topElement := NotEmptyStackTop new initializeWith: (elements at: indexValue)]! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 21:00:06' prior: 50913897!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex dec.
	
	self removeElementsAfterIndex .
		
	^ topValue .
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 21:00:14' prior: 50914412!
pop
	| topValue |
	
	topValue := topElement topValue .
	
	topIndex dec.
	
	self removeElementsAfterIndex .
	
	self resetTopElement .
		
	^ topValue .
	
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:00:21'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:00:21'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:00:21'!
FAILURE!

!methodRemoval: OOStackIndex #decTo: stamp: 'eb 10/4/2020 21:00:42'!
decTo: aStack
	
	value := value - 1.
	(value = 1) ifTrue: [aStack reset] .!

----QUIT----(4 October 2020 21:00:54) CuisUniversity-4365.image priorSource: 17671632!

----STARTUP---- (4 October 2020 21:00:56) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:00:59'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:00:59'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:00:59'!
FAILURE!

!methodRemoval: OOStack #reset stamp: 'eb 10/4/2020 21:02:04'!
reset
	self initialize .!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:02:44'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:02:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:02:44'!
FAILURE!

stack pop !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:04:44'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:04:44'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:04:44'!
FAILURE!

stack!

stack!

self indexValue !

self!

stack!

stack!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 21:08:21' prior: 50914196!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) < topIndex indexValue ].! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:08:24'!
ERROR!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:08:24'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:08:24'!
ERROR!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 21:08:28' prior: 50914584!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) <= topIndex indexValue ].! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:08:32'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:08:32'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:08:32'!
FAILURE!

elements select: [ :each | (elements indexOf: each) <= topIndex indexValue ]!

elements!

elements select: [ :each | (elements indexOf: each) <= topIndex indexValue ]!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:10:47'!
ERROR!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:11:03'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:11:03'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:11:03'!
FAILURE!

stack pop!

stack pop!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 21:12:05' prior: 50913427!
push: anElement 
	elements  addLast: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex  inc .
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:12:08'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:12:08'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:12:08'!
FAILURE!

stack pop!
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 21:12:49' prior: 50914712!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex  inc .
	! !
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 21:16:08' prior: 50914402!
resetTopElement
	(topIndex indexValue = 1) 
		ifTrue: [topElement := EmptyStackTop new.] 
		ifFalse: [topElement := NotEmptyStackTop new initializeWith: elements last]! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/4/2020 21:16:11'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/4/2020 21:16:11'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/4/2020 21:16:11'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:16:11'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:16:11'!
FAILURE!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/4/2020 21:16:12'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/4/2020 21:16:12'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:16:12'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/4/2020 21:16:12'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/4/2020 21:16:12'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/4/2020 21:16:12'!
FAILURE!

----STARTUP---- (7 October 2020 17:33:42) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!methodRemoval: OOStack #reset stamp: 'eb 10/7/2020 17:33:44'!
reset
	self initialize .!
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 21:08:21' prior: 50914196!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) < topIndex indexValue ].! !
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 21:08:28' prior: 50914812!
removeElementsAfterIndex
	
	elements := elements select: [ :each | (elements indexOf: each) <= topIndex indexValue ].! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 21:12:05' prior: 50913427!
push: anElement 
	elements  addLast: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex  inc .
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/4/2020 21:12:49' prior: 50914826!
push: anElement 
	elements  add: anElement.	topElement := NotEmptyStackTop new initializeWith: anElement .
	topIndex  inc .
	! !
!OOStack methodsFor: 'private' stamp: 'eb 10/4/2020 21:16:08' prior: 50914402!
resetTopElement
	(topIndex indexValue = 1) 
		ifTrue: [topElement := EmptyStackTop new.] 
		ifFalse: [topElement := NotEmptyStackTop new initializeWith: elements last]! !

----STARTUP---- (8 October 2020 15:37:39) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/8/2020 15:37:49'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NotEmptyStackTop stamp: 'eb 10/8/2020 15:37:49'!
OOStackTop subclass: #NotEmptyStackTop
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #EmptyStackTop stamp: 'eb 10/8/2020 15:37:50'!
OOStackTop subclass: #EmptyStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTop stamp: 'eb 10/8/2020 15:37:50'!
Object subclass: #OOStackTop
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackIndex stamp: 'eb 10/8/2020 15:37:51'!
Object subclass: #OOStackIndex
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/8/2020 15:37:51'!
Object subclass: #OOStack
	instanceVariableNames: 'elements topElement topIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/8/2020 15:37:52'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/8/2020 15:37:52'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\isw1\15-Stack\Stack-Exercise.st----!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:41:17' prior: 50915258!
find: aPrefixToFind in: aStack
	
	| stackElemets sentencesThatMatchWithPrefix  |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	
	stackElemets := OrderedCollection new.
	sentencesThatMatchWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ stackElemets add: aStack pop ].
	
	sentencesThatMatchWithPrefix := stackElemets select:[:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	stackElemets reverse do: [:element| aStack push: element].
	
	^sentencesThatMatchWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:41:32' prior: 50915289!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchWithPrefix  |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchWithPrefix := elementsPoppedFromStack select:[:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element| aStack push: element].
	
	^sentencesThatMatchWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:42:11' prior: 50915315!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix  |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select:[:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element| aStack push: element].
	
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:42:44' prior: 50915343!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select:[:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element| aStack push: element].
	
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:43:23' prior: 50915371!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select:[:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element| aStack push: element].
	
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:44:04' prior: 50915399!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element| aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:44:07' prior: 50915427!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self error: 'El stack esta vacio'].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix class methodsFor: 'no messages' stamp: 'eb 10/8/2020 15:44:38'!
stackIsEmptyErrorMessage
	^ self .! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:45:21' prior: 50915482!
stackIsEmptyErrorMessage
	^ self error: 'El stack esta vacio' .! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:45:33' prior: 50915455!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage ].
	(aPrefixToFind isEmpty) ifTrue: [self error: 'No se admiten prefijos vacios'].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix class methodsFor: 'nil' stamp: 'eb 10/8/2020 15:46:56'!
prefixIsEmptyErrorMessage
	^ self error: 'No se admiten prefijos vacios'! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:47:29' prior: 50915493!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: 'El prefijo no puede contener espacios vacios'].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix class methodsFor: 'nil' stamp: 'eb 10/8/2020 15:50:08'!
prefixContainsEmptySpaces
	^ self error: 'El prefijo no puede contener espacios vacios'.! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:50:10' prior: 50915553!
prefixContainsEmptySpaces

	^ self error: 'El prefijo no puede contener espacios vacios'.! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:50:14' prior: 50915520!
prefixIsEmptyErrorMessage

	^ self error: 'No se admiten prefijos vacios'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:50:18' prior: 50915487!
stackIsEmptyErrorMessage

	^ self error: 'El stack esta vacio' .! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:50:32'!
prefixContainsEmptySpacesErrorMessage

	^ self error: 'El prefijo no puede contener espacios vacios'.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:50:37' prior: 50915526!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix  := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:50:52' prior: 50915586!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	[aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ].
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:52:58'!
popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack

	^ [aStack isEmpty] whileFalse: [ elementsPoppedFromStack add: aStack pop ]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:52:58' prior: 50915614!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1].
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:54:44'!
find: elementsPoppedFromStack inElementCollection: aPrefixToFind

	^ elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:54:44' prior: 50915649!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: elementsPoppedFromStack inElementCollection: aPrefixToFind.
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:55:25' prior: 50915676!
find: aPrefixToFind inElementCollection: elementsPoppedFromStack

	^ elementsPoppedFromStack select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:55:38' prior: 50915712!
find: aPrefixToFind inElementCollection: elements

	^ elements select: [:each| (each findString: aPrefixToFind startingAt: 1) = 1]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:55:49' prior: 50915721!
find: aPrefixToFind inElementCollection: elements

	^ elements select: [:each | (each findString: aPrefixToFind startingAt: 1) = 1]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:56:32' prior: 50915685!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: elementsPoppedFromStack inElementCollection: aPrefixToFind.
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:56:38' prior: 50915737!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: elementsPoppedFromStack inElementCollection: aPrefixToFind.
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	
	^sentencesThatMatchesWithPrefix asBag .	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:56:57' prior: 50915729!
find: aPrefixToFind inElementCollection: elements

	^ elements select: [:each | (each findString: aPrefixToFind startingAt: 1) = 1] asBag.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:57:16' prior: 50915764!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: elementsPoppedFromStack inElementCollection: aPrefixToFind.
	
	elementsPoppedFromStack reverse do: [:element | aStack push: element].
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:57:51'!
restoreStackFrom: elementsPoppedFromStack andSaveInto: aStack

	^ elementsPoppedFromStack reverse do: [:element | aStack push: element]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:57:51' prior: 50915799!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: elementsPoppedFromStack inElementCollection: aPrefixToFind.
	
	self restoreStackFrom: elementsPoppedFromStack andSaveInto: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:58:18'!
restore: aStack from: elementsPoppedFromStack

	^ elementsPoppedFromStack reverse do: [:element | aStack push: element]! !

!methodRemoval: SentenceFinderByPrefix #restoreStackFrom:andSaveInto: stamp: 'eb 10/8/2020 15:58:36'!
restoreStackFrom: elementsPoppedFromStack andSaveInto: aStack

	^ elementsPoppedFromStack reverse do: [:element | aStack push: element]!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 15:58:47' prior: 50915833!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: elementsPoppedFromStack inElementCollection: aPrefixToFind.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:00:00' prior: 50915874!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:00:21' prior: 50915899!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage].
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:04:11'!
assertThatStackIsNotEmpty: aStack

	^ (aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:04:11' prior: 50915924!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:04:43'!
assertThatPrefixIsNotEmptyAndDoesntContainsEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:04:43' prior: 50915956!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	self assertThatPrefixIsNotEmptyAndDoesntContainsEmptySpaces: aPrefixToFind.
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:04:49' prior: 50915992!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ].
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:06:28'!
assertThatPrefixIsntEmptyNorHasntEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:06:28' prior: 50916014!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	self assertThatPrefixIsntEmptyNorHasntEmptySpaces: aPrefixToFind.
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !

!methodRemoval: SentenceFinderByPrefix #assertThatPrefixIsNotEmptyAndDoesntContainsEmptySpaces: stamp: 'eb 10/8/2020 16:06:41'!
assertThatPrefixIsNotEmptyAndDoesntContainsEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:07:13'!
assertThatPrefixIsntEmptyAndHasntEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:07:13' prior: 50916049!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	self assertThatPrefixIsntEmptyAndHasntEmptySpaces: aPrefixToFind.
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !

!methodRemoval: SentenceFinderByPrefix #assertThatPrefixIsntEmptyNorHasntEmptySpaces: stamp: 'eb 10/8/2020 16:07:13'!
assertThatPrefixIsntEmptyNorHasntEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:07:16'!
assertThatPrefixIsntEmptyNorHasntEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]! !

!methodRemoval: SentenceFinderByPrefix #assertThatPrefixIsntEmptyNorHasntEmptySpaces: stamp: 'eb 10/8/2020 16:07:19'!
assertThatPrefixIsntEmptyNorHasntEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self class prefixContainsEmptySpacesErrorMessage ]!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:07:31' prior: 50916093!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	
	self assertThatPrefixIsntEmptyAndHasntEmptySpaces: aPrefixToFind.
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:08:16' prior: 50915949!
assertThatStackIsNotEmpty: aStack

	(aStack isEmpty) ifTrue: [self class stackIsEmptyErrorMessage]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:08:37' prior: 50915791!
find: aPrefixToFind inElementCollection: elements

	^ elements select: [:each | (each findString: aPrefixToFind startingAt: 1) = 1].! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:08:45' prior: 50916147!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	
	self assertThatPrefixIsntEmptyAndHasntEmptySpaces: aPrefixToFind.
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack asBag.
	
	self restore: aStack from: aStack.
	
	^sentencesThatMatchesWithPrefix.	! !

!testRun: #SentenceFinderByPrefixTest #test01 stamp: 'eb 10/8/2020 16:09:12'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02 stamp: 'eb 10/8/2020 16:09:12'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03 stamp: 'eb 10/8/2020 16:09:12'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04 stamp: 'eb 10/8/2020 16:09:12'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test05 stamp: 'eb 10/8/2020 16:09:12'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test06CaseSensitive stamp: 'eb 10/8/2020 16:09:12'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test07 stamp: 'eb 10/8/2020 16:09:12'!
ERROR!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:10:02'!
test01PrefixShouldnBeEmpty
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := ''.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = 'No se admiten prefijos vacios' ]! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:11:18' prior: 50916224!
test01PrefixShouldnBeEmpty
	
	| aStack finder aPrefix |
	
	aStack := OOStack new.
	
	aStack push: 'abc'.
	
	aPrefix := ''.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError equals: SentenceFinderByPrefix prefixIsEmptyErrorMessage ]! !

!methodRemoval: SentenceFinderByPrefix class #prefixContainsEmptySpaces stamp: 'eb 10/8/2020 16:11:23'!
prefixContainsEmptySpaces

	^ self error: 'El prefijo no puede contener espacios vacios'.!

!methodRemoval: SentenceFinderByPrefixTest #test01 stamp: 'eb 10/8/2020 16:11:32'!
test01
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := ''.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = 'No se admiten prefijos vacios' ]!

!testRun: #SentenceFinderByPrefixTest #test01PrefixShouldnBeEmpty stamp: 'eb 10/8/2020 16:11:36'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test01PrefixShouldnBeEmpty stamp: 'eb 10/8/2020 16:11:36'!
ERROR!
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:12:50' prior: 50915579!
prefixContainsEmptySpacesErrorMessage

	^ 'El prefijo no puede contener espacios vacios'.! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:12:57' prior: 50915567!
prefixIsEmptyErrorMessage

	^ 'No se admiten prefijos vacios'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:13:00' prior: 50915573!
stackIsEmptyErrorMessage

	^ 'El stack esta vacio' .! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:13:17' prior: 50916082!
assertThatPrefixIsntEmptyAndHasntEmptySpaces: aPrefixToFind

	(aPrefixToFind isEmpty) ifTrue: [self error: self class prefixIsEmptyErrorMessage].
	((aPrefixToFind findString: ' ') ~= 0) ifTrue: [self error: self class prefixContainsEmptySpacesErrorMessage ]! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:13:24' prior: 50916168!
assertThatStackIsNotEmpty: aStack

	(aStack isEmpty) ifTrue: [self error: self class stackIsEmptyErrorMessage]! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:13:36' prior: 50916238!
test01PrefixShouldnBeEmpty
	
	| aStack finder aPrefix |
	
	aStack := OOStack new.
	
	aStack push: 'abc'.
	
	aPrefix := ''.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText  = SentenceFinderByPrefix prefixIsEmptyErrorMessage ]! !

!testRun: #SentenceFinderByPrefixTest #test01PrefixShouldnBeEmpty stamp: 'eb 10/8/2020 16:13:39'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:13:57'!
test02PrefixShouldnContainEmptySpaces
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := 'a a'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = 'El prefijo no puede contener espacios vacios' ]! !

!methodRemoval: SentenceFinderByPrefixTest #test02 stamp: 'eb 10/8/2020 16:13:59'!
test02
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := 'a a'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = 'El prefijo no puede contener espacios vacios' ]!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:14:29' prior: 50916332!
test02PrefixShouldnContainEmptySpaces
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := 'a a'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = SentenceFinderByPrefix prefixContainsEmptySpacesErrorMessage ]! !

!testRun: #SentenceFinderByPrefixTest #test02PrefixShouldnContainEmptySpaces stamp: 'eb 10/8/2020 16:14:33'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:14:58'!
test01PrefixShouldntBeEmpty
	
	| aStack finder aPrefix |
	
	aStack := OOStack new.
	
	aStack push: 'abc'.
	
	aPrefix := ''.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText  = SentenceFinderByPrefix prefixIsEmptyErrorMessage ]! !

!methodRemoval: SentenceFinderByPrefixTest #test01PrefixShouldnBeEmpty stamp: 'eb 10/8/2020 16:15:01'!
test01PrefixShouldnBeEmpty
	
	| aStack finder aPrefix |
	
	aStack := OOStack new.
	
	aStack push: 'abc'.
	
	aPrefix := ''.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText  = SentenceFinderByPrefix prefixIsEmptyErrorMessage ]!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:15:04'!
test02PrefixShouldntContainEmptySpaces
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := 'a a'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = SentenceFinderByPrefix prefixContainsEmptySpacesErrorMessage ]! !

!methodRemoval: SentenceFinderByPrefixTest #test02PrefixShouldnContainEmptySpaces stamp: 'eb 10/8/2020 16:15:06'!
test02PrefixShouldnContainEmptySpaces
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aStack push: 'abc'.
	aPrefix := 'a a'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = SentenceFinderByPrefix prefixContainsEmptySpacesErrorMessage ]!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:15:14'!
test03StackShouldntBeEmpty
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aPrefix := 'ab'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = 'El stack esta vacio']! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:15:25' prior: 50916437!
test03StackShouldntBeEmpty
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aPrefix := 'ab'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = SentenceFinderByPrefix stackIsEmptyErrorMessage ]! !

!methodRemoval: SentenceFinderByPrefixTest #test03 stamp: 'eb 10/8/2020 16:15:28'!
test03
	
	| aStack finder aPrefix |
	aStack := OOStack new.
	aPrefix := 'ab'.
	
	finder := 	SentenceFinderByPrefix new.
	
	[ finder find: aPrefix in: aStack . self fail] 
		on: Error 
		do: [ :anError | self assert: anError messageText = 'El stack esta vacio']!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:16:08'!
test04FinderReturnsEmptyCollectionIfPrefixIsntInStack
	| sentencesThathMatchWithAPrefix  aStack finder aPrefix emptyCollection |
	aStack := OOStack new.
	aStack push: 'abc'.
	aStack push: 'abcd'.	
	aStack push: 'dabc'.	
	aStack push: 'fabc'.
	aPrefix := 'zz'.
	
	finder := 	SentenceFinderByPrefix new.
	
	sentencesThathMatchWithAPrefix := finder find: aPrefix in: aStack.
	
	emptyCollection := Bag new.
	
	self assert: emptyCollection = sentencesThathMatchWithAPrefix.! !

!methodRemoval: SentenceFinderByPrefixTest #test04 stamp: 'eb 10/8/2020 16:16:10'!
test04
	| sentencesThathMatchWithAPrefix  aStack finder aPrefix emptyCollection |
	aStack := OOStack new.
	aStack push: 'abc'.
	aStack push: 'abcd'.	
	aStack push: 'dabc'.	
	aStack push: 'fabc'.
	aPrefix := 'zz'.
	
	finder := 	SentenceFinderByPrefix new.
	
	sentencesThathMatchWithAPrefix := finder find: aPrefix in: aStack.
	
	emptyCollection := Bag new.
	
	self assert: emptyCollection = sentencesThathMatchWithAPrefix.!

!testRun: #SentenceFinderByPrefixTest #test04FinderReturnsEmptyCollectionIfPrefixIsntInStack stamp: 'eb 10/8/2020 16:16:12'!
ERROR!

!testRun: #SentenceFinderByPrefixTest #test04FinderReturnsEmptyCollectionIfPrefixIsntInStack stamp: 'eb 10/8/2020 16:16:12'!
ERROR!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:16:42' prior: 50916183!
find: aPrefixToFind in: aStack
	
	| elementsPoppedFromStack sentencesThatMatchesWithPrefix |
	
	self assertThatStackIsNotEmpty: aStack.
	
	self assertThatPrefixIsntEmptyAndHasntEmptySpaces: aPrefixToFind.
	
	elementsPoppedFromStack := OrderedCollection new.
	
	sentencesThatMatchesWithPrefix := Bag new.
	
	self popElementsFrom: aStack andStoreTheyIn: elementsPoppedFromStack.
	
	sentencesThatMatchesWithPrefix := self find: aPrefixToFind inElementCollection: elementsPoppedFromStack asBag.
	
	self restore: aStack from: elementsPoppedFromStack.
	
	^sentencesThatMatchesWithPrefix.	! !

!testRun: #SentenceFinderByPrefixTest #test04FinderReturnsEmptyCollectionIfPrefixIsntInStack stamp: 'eb 10/8/2020 16:16:49'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:17:43'!
test05FinderReturnsAllPrefixOccurrencesInStack
	| sentencesThathMatchWithAPrefix  aStack finder aPrefix expectedCollection |
	aStack := OOStack new.
	aStack push: 'abc'.
	aStack push: 'abcd'.	
	aStack push: 'dabc'.	
	aStack push: 'fabc'.
	aStack push: 'abc'.
	aStack push: 'abcdefg'.
	aPrefix := 'ab'.
	
	finder := 	SentenceFinderByPrefix new.
	
	sentencesThathMatchWithAPrefix := finder find: aPrefix in: aStack.
	
	expectedCollection := Bag with: 'abcd' with: 'abc' with: 'abcdefg' with: 'abc'.
	
	self assert: expectedCollection = sentencesThathMatchWithAPrefix.! !

!methodRemoval: SentenceFinderByPrefixTest #test05 stamp: 'eb 10/8/2020 16:17:45'!
test05
	| sentencesThathMatchWithAPrefix  aStack finder aPrefix expectedCollection |
	aStack := OOStack new.
	aStack push: 'abc'.
	aStack push: 'abcd'.	
	aStack push: 'dabc'.	
	aStack push: 'fabc'.
	aStack push: 'abc'.
	aStack push: 'abcdefg'.
	aPrefix := 'ab'.
	
	finder := 	SentenceFinderByPrefix new.
	
	sentencesThathMatchWithAPrefix := finder find: aPrefix in: aStack.
	
	expectedCollection := Bag with: 'abcd' with: 'abc' with: 'abcdefg' with: 'abc'.
	
	self assert: expectedCollection = sentencesThathMatchWithAPrefix.!

!testRun: #SentenceFinderByPrefixTest #test05FinderReturnsAllPrefixOccurrencesInStack stamp: 'eb 10/8/2020 16:17:49'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:18:17'!
test06FinderBehavesCaseSensitive
	| sentencesThathMatchWithAPrefix  aStack finder aPrefix expectedCollection |
	aStack := OOStack new.
	aStack push: 'abc'.
	aStack push: 'abcd'.	
	aStack push: 'dabc'.	
	aStack push: 'fabc'.
	aStack push: 'abc'.
	aStack push: 'abcdefg'.
	aPrefix := 'AB'.
	
	finder := 	SentenceFinderByPrefix new.
	
	sentencesThathMatchWithAPrefix := finder find: aPrefix in: aStack.
	
	expectedCollection := Bag new.
	
	self assert: expectedCollection = sentencesThathMatchWithAPrefix.! !

!methodRemoval: SentenceFinderByPrefixTest #test06CaseSensitive stamp: 'eb 10/8/2020 16:18:17'!
test06CaseSensitive
	| sentencesThathMatchWithAPrefix  aStack finder aPrefix expectedCollection |
	aStack := OOStack new.
	aStack push: 'abc'.
	aStack push: 'abcd'.	
	aStack push: 'dabc'.	
	aStack push: 'fabc'.
	aStack push: 'abc'.
	aStack push: 'abcdefg'.
	aPrefix := 'AB'.
	
	finder := 	SentenceFinderByPrefix new.
	
	sentencesThathMatchWithAPrefix := finder find: aPrefix in: aStack.
	
	expectedCollection := Bag new.
	
	self assert: expectedCollection = sentencesThathMatchWithAPrefix.!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:18:37' prior: 50915119!
test07
	| aStack finder aPrefix firstSentence secondSentence thirdSentence sizeOriginalStack|
	firstSentence := 'abc'.
	secondSentence := 'abcd'.
	thirdSentence := 'abcde'.	
	aPrefix := 'ab'.
	
	aStack := OOStack new.
	aStack push: firstSentence.
	aStack push: secondSentence.
	aStack push: thirdSentence. 
	sizeOriginalStack := aStack size.
	
	finder := 	SentenceFinderByPrefix new.
	finder find: aPrefix in: aStack.
	
	self assert: aStack size = sizeOriginalStack.
	self assert: aStack pop = thirdSentence.
	self assert: aStack pop = secondSentence .
	self assert: aStack pop = firstSentence.
	self assert: aStack size = 0.! !

!testRun: #SentenceFinderByPrefixTest #test07 stamp: 'eb 10/8/2020 16:18:42'!
PASSED!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:19:20'!
test07FinderDoesntModifyStack
	| aStack finder aPrefix firstSentence secondSentence thirdSentence sizeOriginalStack|
	firstSentence := 'abc'.
	secondSentence := 'abcd'.
	thirdSentence := 'abcde'.	
	aPrefix := 'ab'.
	
	aStack := OOStack new.
	aStack push: firstSentence.
	aStack push: secondSentence.
	aStack push: thirdSentence. 
	sizeOriginalStack := aStack size.
	
	finder := 	SentenceFinderByPrefix new.
	finder find: aPrefix in: aStack.
	
	self assert: aStack size = sizeOriginalStack.
	self assert: aStack pop = thirdSentence.
	self assert: aStack pop = secondSentence .
	self assert: aStack pop = firstSentence.
	self assert: aStack size = 0.! !

!methodRemoval: SentenceFinderByPrefixTest #test07 stamp: 'eb 10/8/2020 16:19:22'!
test07
	| aStack finder aPrefix firstSentence secondSentence thirdSentence sizeOriginalStack|
	firstSentence := 'abc'.
	secondSentence := 'abcd'.
	thirdSentence := 'abcde'.	
	aPrefix := 'ab'.
	
	aStack := OOStack new.
	aStack push: firstSentence.
	aStack push: secondSentence.
	aStack push: thirdSentence. 
	sizeOriginalStack := aStack size.
	
	finder := 	SentenceFinderByPrefix new.
	finder find: aPrefix in: aStack.
	
	self assert: aStack size = sizeOriginalStack.
	self assert: aStack pop = thirdSentence.
	self assert: aStack pop = secondSentence .
	self assert: aStack pop = firstSentence.
	self assert: aStack size = 0.!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01PrefixShouldntBeEmpty stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02PrefixShouldntContainEmptySpaces stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03StackShouldntBeEmpty stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04FinderReturnsEmptyCollectionIfPrefixIsntInStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05FinderReturnsAllPrefixOccurrencesInStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06FinderBehavesCaseSensitive stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07FinderDoesntModifyStack stamp: 'eb 10/8/2020 16:19:25'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01PrefixShouldntBeEmpty stamp: 'eb 10/8/2020 16:20:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02PrefixShouldntContainEmptySpaces stamp: 'eb 10/8/2020 16:20:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03StackShouldntBeEmpty stamp: 'eb 10/8/2020 16:20:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04FinderReturnsEmptyCollectionIfPrefixIsntInStack stamp: 'eb 10/8/2020 16:20:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05FinderReturnsAllPrefixOccurrencesInStack stamp: 'eb 10/8/2020 16:20:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06FinderBehavesCaseSensitive stamp: 'eb 10/8/2020 16:20:53'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07FinderDoesntModifyStack stamp: 'eb 10/8/2020 16:20:53'!
PASSED!
!OOStackElement methodsFor: 'no messages' stamp: 'eb 10/8/2020 16:22:46'!
popElement
	
	^ self subclassResponsibility .! !
!OOStackElement methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:23:03' prior: 50916784!
popElement
	
	self subclassResponsibility .! !
!OOStackElement methodsFor: 'as yet unclassified' stamp: 'eb 10/8/2020 16:23:24'!
topElement

	self subclassResponsibility .! !
!OOStackElement methodsFor: 'operations' stamp: 'eb 10/8/2020 16:25:12'!
elementValue

	self subclassResponsibility .! !

!methodRemoval: OOStackElement #popElement stamp: 'eb 10/8/2020 16:25:15'!
popElement
	
	self subclassResponsibility .!

!methodRemoval: OOStackElement #topElement stamp: 'eb 10/8/2020 16:25:16'!
topElement

	self subclassResponsibility .!
!Element methodsFor: 'operations' stamp: 'eb 10/8/2020 16:25:23' overrides: 50916798!
elementValue
	
	^value ! !

!methodRemoval: Element #topElement stamp: 'eb 10/8/2020 16:25:26'!
topElement
	
	^value .!

!methodRemoval: Element #popElement stamp: 'eb 10/8/2020 16:25:28'!
popElement
	
	^value !

!methodRemoval: NoElement #popElement stamp: 'eb 10/8/2020 16:25:34'!
popElement
	self error: OOStack stackEmptyErrorDescription!
!NoElement methodsFor: 'operations' stamp: 'eb 10/8/2020 16:25:39' overrides: 50916798!
elementValue
	self error: OOStack stackEmptyErrorDescription! !

!methodRemoval: NoElement #topElement stamp: 'eb 10/8/2020 16:25:43'!
topElement
	self error: OOStack stackEmptyErrorDescription!
!OOStack methodsFor: 'operations' stamp: 'eb 10/8/2020 16:25:56' prior: 50915153!
pop

	^elements removeLast elementValue .
	
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/8/2020 16:26:28' prior: 50915167!
top

	^elements last elementValue .
	! !
!OOStack methodsFor: 'operations' stamp: 'eb 10/8/2020 16:26:47' prior: 50915157!
push: value

	elements add: (Element new initializeWith: value).
	
	! !

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01PrefixShouldntBeEmpty stamp: 'eb 10/8/2020 16:27:35'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02PrefixShouldntContainEmptySpaces stamp: 'eb 10/8/2020 16:27:36'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03StackShouldntBeEmpty stamp: 'eb 10/8/2020 16:27:36'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04FinderReturnsEmptyCollectionIfPrefixIsntInStack stamp: 'eb 10/8/2020 16:27:36'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05FinderReturnsAllPrefixOccurrencesInStack stamp: 'eb 10/8/2020 16:27:36'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06FinderBehavesCaseSensitive stamp: 'eb 10/8/2020 16:27:36'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07FinderDoesntModifyStack stamp: 'eb 10/8/2020 16:27:36'!
PASSED!

----QUIT----(8 October 2020 16:29:33) CuisUniversity-4365.image priorSource: 18650109!

----STARTUP---- (8 October 2020 19:51:30) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


!classRemoval: #SentenceFinderByPrefix stamp: 'eb 10/8/2020 19:51:37'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #NoElement stamp: 'eb 10/8/2020 19:51:38'!
OOStackElement subclass: #NoElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #Element stamp: 'eb 10/8/2020 19:51:38'!
OOStackElement subclass: #Element
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackElement stamp: 'eb 10/8/2020 19:51:38'!
Object subclass: #OOStackElement
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStack stamp: 'eb 10/8/2020 19:51:39'!
Object subclass: #OOStack
	instanceVariableNames: 'elements'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #SentenceFinderByPrefixTest stamp: 'eb 10/8/2020 19:51:39'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classRemoval: #OOStackTest stamp: 'eb 10/8/2020 19:51:39'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

----End fileIn of C:\Users\ebonansea\Desktop\stack orig.st----!

----STARTUP---- (11 October 2020 12:10:20) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\Parciales\Parciales\2020-1c\1erParcial\ISW1-2020-1C-Parcial-Enunciado.st----!

----STARTUP---- (11 October 2020 12:28:45) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\Parciales\Parciales\2020-1c\1erParcial\ISW1-2020-1C-Parcial-Enunciado.st----!

----End fileIn of C:\Program Files\CuisUniversity\Packages\System\Collections-CompactArrays.pck.st----!

----End fileIn of C:\Program Files\CuisUniversity\Packages\Features\VectorGraphics.pck.st----!

Object subclass: #RobotState
	instanceVariableNames: 'robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotState category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 13:23:22'!
Object subclass: #RobotState
	instanceVariableNames: 'robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotState methodsFor: 'nil' stamp: 'eb 10/11/2020 13:23:57'!
closeOrderUsing

	^ nil.! !
!RobotState methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 13:24:04' prior: 50930072!
closeOrderUsing

	^ self subclassResponsibility .! !
!RobotState methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 13:24:26'!
take
	
	^ self subclassResponsibility .! !
!RobotState methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 13:24:39'!
closeOrderUsing: aCashier

	^ self subclassResponsibility .! !

!methodRemoval: RobotState #closeOrderUsing stamp: 'eb 10/11/2020 13:24:41'!
closeOrderUsing

	^ self subclassResponsibility .!
!RobotState methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 13:24:46'!
take: aProduct
	
	^ self subclassResponsibility .! !

!methodRemoval: RobotState #take stamp: 'eb 10/11/2020 13:24:50'!
take
	
	^ self subclassResponsibility .!

RobotState subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #WorkingNormal category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 13:26:30'!
RobotState subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotState subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #SensorsFailure category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 13:26:50'!
RobotState subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotState subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #MechanicalFailure category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 13:27:05'!
RobotState subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotState subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #OutOfOrder category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 13:27:10'!
RobotState subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 13:31:25'!
closeOrderWhenWorkingNormalUsing: aCashier
	^ aCashier receiveOrder: self .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 13:31:49'!
closeOrderWhenMechanicalFailureUsing: aCashier
	^ aCashier receiveOrder: self .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 13:32:00'!
closeOrderWhenSensorsFailureUsing: aCashier
	^ aCashier receiveOrder: self .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 13:32:26'!
closeOrderWhenOutOfOrderUsing: aCashier
	^ self class signalOutOfOrder .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 13:33:14' prior: 50918668!
closeOrderUsing: aCashier
	
	^self status closeOrderUsing: aCashier.
! !
!RobotState methodsFor: 'nil' stamp: 'eb 10/11/2020 13:41:17'!
initializeFor: aRobot

	robot _ aRobot .! !
!RobotState class methodsFor: 'no messages' stamp: 'eb 10/11/2020 13:41:46'!
for: aRobot
	
	self new initializeFor: aRobot .! !
!MechanicalFailure methodsFor: 'no messages' stamp: 'eb 10/11/2020 13:44:30' overrides: 50930085!
closeOrderUsing: aCashier

	^ robot closeOrderWhenMechanicalFailureUsing: aCashier .! !
!OutOfOrder methodsFor: 'no messages' stamp: 'eb 10/11/2020 15:59:09' overrides: 50930085!
closeOrderUsing: aCashier

	^ robot closeOrderWhenOutOfOrderUsing: aCashier .! !
!SensorsFailure methodsFor: 'no messages' stamp: 'eb 10/11/2020 15:59:33' overrides: 50930085!
closeOrderUsing: aCashier

	^ robot closeOrderWhenSensorsFailureUsing: aCashier .! !
!WorkingNormal methodsFor: 'no messages' stamp: 'eb 10/11/2020 16:00:05' overrides: 50930085!
closeOrderUsing: aCashier

	^ robot closeOrderWhenWorkingNormalUsing: aCashier .! !
!Robot methodsFor: 'initialization' stamp: 'eb 10/11/2020 16:01:50' prior: 50918709!
initializeWith: aTrailer

	trailer := aTrailer.
	status := WorkingNormal for: self.
! !
!Robot methodsFor: 'status' stamp: 'eb 10/11/2020 16:02:17' prior: 50918691!
outOfOrder

	status := OutOfOrder for: self .
! !
!Robot methodsFor: 'status' stamp: 'eb 10/11/2020 16:03:03' prior: 50918695!
withMechanicalFailure

	status := MechanicalFailure for: self .
! !
!Robot methodsFor: 'status' stamp: 'eb 10/11/2020 16:03:10' prior: 50918699!
withSensorsFailure

	status := SensorsFailure for: self .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:04:09'!
takeWhenWorkingNormal: aProduct
	^ trailer carry: aProduct .

! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:04:45'!
takeWhenSensorsFailure: aProduct
	^ trailer carry: aProduct .

! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:04:56'!
takeWhenMechanicalFailure: aProduct
	^ trailer carry: aProduct .

! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:05:11'!
takeWhenOutOfOrder: aProduct
	^ trailer carry: aProduct .

! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:05:22' prior: 50930247!
takeWhenOutOfOrder: aProduct
	^ self class signalOutOfOrder.

! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:05:23' prior: 50930252!
takeWhenOutOfOrder: aProduct
	^ self class signalOutOfOrder .

! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:06:10' prior: 50918680!
take: aProduct
	^ self status take: aProduct .
! !
!MechanicalFailure methodsFor: 'actions' stamp: 'eb 10/11/2020 16:06:47' overrides: 50930094!
take: aProduct

	^ robot takeWhenWorkingNormal: aProduct .! !
!OutOfOrder methodsFor: 'actions' stamp: 'eb 10/11/2020 16:08:18' overrides: 50930094!
take: aProduct

	^ robot takeWhenOutOfOrder: aProduct .! !
!SensorsFailure methodsFor: 'actions' stamp: 'eb 10/11/2020 16:08:41' overrides: 50930094!
take: aProduct

	^ robot takeWhenSensorsFailure: aProduct .! !
!WorkingNormal methodsFor: 'actions' stamp: 'eb 10/11/2020 16:09:01' overrides: 50930094!
take: aProduct

	^ robot takeWhenWorkingNormal: aProduct .! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 16:09:04'!
FAILURE!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 16:09:04'!
FAILURE!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 16:09:04'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 16:09:04'!
FAILURE!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 16:09:04'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 16:09:04'!
ERROR!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:09:04'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 16:09:14'!
ERROR!
!RobotState class methodsFor: 'initialization' stamp: 'eb 10/11/2020 16:10:03' prior: 50930183!
for: aRobot
	
	^ self new initializeFor: aRobot .! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 16:10:06'!
FAILURE!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 16:10:06'!
FAILURE!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 16:10:06'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 16:10:06'!
FAILURE!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:10:06'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:10:06'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:10:06'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:10:06'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:10:10'!
ERROR!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:10:38'!
ERROR!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:10:48'!
ERROR!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:11:03'!
PASSED!
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:12:25' prior: 50930174!
closeOrderUsing: aCashier	self halt.
	
	^self status closeOrderUsing: aCashier.
! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 16:12:29'!
FAILURE!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 16:12:29'!
FAILURE!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 16:12:29'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 16:12:29'!
FAILURE!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:12:29'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:12:29'!
PASSED!
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:14:35' prior: 50930509!
closeOrderUsing: aCashier
	
	^self status closeOrderUsing: aCashier.
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:18:28'!
receiveOrderFromWorkingNormalRobot: aWorkingNormalRobot
	| aTrailer | 
	
	aTrailer _ aWorkingNormalRobot trailer.		
	self assertTrailerNotEmpty: aTrailer.
	
	"Comentario: en este punto el cashier realizara el checkout de los productos."
		
	^ true .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:19:59'!
receiveOrderFromSensorsFailureRobot: aSensorsFailureRobot
	| aTrailer | 
	
	aTrailer _ aSensorsFailureRobot trailer.		
	self assertTrailerNotEmpty: aTrailer.
	
	"Comentario: en este punto el cashier realizara el checkout de los productos."
		
	^ true .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:20:19' prior: 50930618!
receiveOrderFromSensorsFailureRobot: aSensorsFailureRobot
	aSensorsFailureRobot outOfOrder.
	
	self signalRobotSensorsFailure .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:21:10'!
receiveOrderFromMechanicalFailureRobot: aMechanicalFailureRobot
	| aTrailer | 
	
	aTrailer _ aMechanicalFailureRobot trailer.		
	self assertTrailerNotEmpty: aTrailer.
	
	"Comentario: en este punto el cashier realizara el checkout de los productos."
		
	^ true .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:21:54' prior: 50930636!
receiveOrderFromMechanicalFailureRobot: aMechanicalFailureRobot
	| aTrailer | 
	
	aMechanicalFailureRobot outOfOrder.
		
	aTrailer := aMechanicalFailureRobot trailer.	
	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizara el checkout de los productos."

	^ true .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:21:59' prior: 50930648!
receiveOrderFromMechanicalFailureRobot: aMechanicalFailureRobot
	| aTrailer | 
	
	aMechanicalFailureRobot outOfOrder.
		
	aTrailer _ aMechanicalFailureRobot trailer.	
	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizara el checkout de los productos."

	^ true .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:23:01' prior: 50930159!
closeOrderWhenMechanicalFailureUsing: aCashier
	^ aCashier receiveOrderFromMechanicalFailureRobot: self .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:23:28' prior: 50930164!
closeOrderWhenSensorsFailureUsing: aCashier
	^ aCashier receiveOrderFromSensorsFailureRobot: self .
! !
!Robot methodsFor: 'actions' stamp: 'eb 10/11/2020 16:23:34' prior: 50930154!
closeOrderWhenWorkingNormalUsing: aCashier
	^ aCashier receiveOrderFromWorkingNormalRobot: self .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:25:26' prior: 50918459!
receiveOrder: aRobot
	^ aRobot closeOrderUsing: self .
! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:25:28'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:25:28'!
PASSED!
!Cashier methodsFor: 'closing buy order - private' stamp: 'eb 10/11/2020 16:30:46'!
checkoutIfTrailerIsNotEmpty: aRobot

	^ true .
	! !
!Cashier methodsFor: 'closing buy order - private' stamp: 'eb 10/11/2020 16:31:08' prior: 50930799!
checkoutIfTrailerIsNotEmpty: aRobot
	
	| aTrailer | 
	
	aTrailer _ aRobot trailer.	
	
	self assertTrailerNotEmpty: aTrailer.
	
	"Comentario: en este punto el cashier realizara el checkout de los productos."

	^ true .
	! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:31:32' prior: 50930661!
receiveOrderFromMechanicalFailureRobot: aMechanicalFailureRobot	
	aMechanicalFailureRobot outOfOrder.
		
	^ self checkoutIfTrailerIsNotEmpty: aMechanicalFailureRobot .
! !
!Cashier methodsFor: 'closing buy order' stamp: 'eb 10/11/2020 16:31:49' prior: 50930607!
receiveOrderFromWorkingNormalRobot: aWorkingNormalRobot
	^ self checkoutIfTrailerIsNotEmpty: aWorkingNormalRobot .
! !
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 16:46:20' prior: 50918779!
totalProductsHeight
	"Solo importa la altura de los productos apilables"
	| total |
	total := 0.
	
	(container select: [ :product | product isStackable ]) do: [ :product | total _ total +  product height ] .
	^ total .! !
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 16:46:53' prior: 50930830!
totalProductsHeight
	"Solo importa la altura de los productos apilables"
	| total |
	total := 0.
	
	(container select: [ :product | product isStackable ]) do: [ :product | total _ total +  product height ] .
	^ total .! !
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 16:47:38' prior: 50918792!
totalProductsWeight
	
	| total  |
	total := 0.
	
	container do: [ :product | total _ total +  product weight ] .
	
	^ total .! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:47:42'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 16:47:42'!
PASSED!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 16:50:17' prior: 50918041!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot
	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aCashier := Cashier new.
	self should: [  aCashier receiveOrder: aRobot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 16:50:41' prior: 50930958!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot
	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aCashier := Cashier new.
	self should: [ aCashier receiveOrder: aRobot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 16:51:18' prior: 50918055!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot
	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.	
	aCashier := Cashier new.
	self should: [ aRobot withMechanicalFailure. aCashier receiveOrder: aRobot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'eb 10/11/2020 16:52:02' prior: 50918070!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.	
	aCashier := Cashier new.
	self should: [ aRobot withSensorsFailure. aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'eb 10/11/2020 16:52:53' prior: 50918085!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot
	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aCashier := Cashier new.
	self should: [ 			aRobot take: (ProductA with: 1  and: 1). 
				aRobot withMechanicalFailure.				aCashier receiveOrder: aRobot.				aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'eb 10/11/2020 16:54:21' prior: 50931016!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot
	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aCashier := Cashier new.
	self should: [ 			aRobot take: (ProductA with: 1  and: 1). 
				aRobot withMechanicalFailure.				aCashier receiveOrder: aRobot.				aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 16:54:26' prior: 50930972!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot
	| aRobot aTrailer aCashier |
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aCashier := Cashier new.
	self should: [ aCashier receiveOrder: aRobot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !

CashierTest class
	instanceVariableNames: 'aRobot aTrailer aCashier'!

!classDefinition: 'CashierTest class' category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 16:56:14'!
CashierTest class
	instanceVariableNames: 'aRobot aTrailer aCashier'!
!CashierTest methodsFor: 'nil' stamp: 'eb 10/11/2020 16:56:24' overrides: 16927572!
setUp
	! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 16:56:37' prior: 50931052!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot
	| aRobot aCashier |

	self should: [ aCashier receiveOrder: aRobot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !

CashierTest class
	instanceVariableNames: 'robot trailer cashier'!

!classDefinition: 'CashierTest class' category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 16:57:18'!
CashierTest class
	instanceVariableNames: 'robot trailer cashier'!

CashierTest class
	instanceVariableNames: ''!

!classDefinition: 'CashierTest class' category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 16:59:06'!
CashierTest class
	instanceVariableNames: ''!

TestCase subclass: #CashierTest
	instanceVariableNames: 'robot trailer cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 16:59:09'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'robot trailer cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/11/2020 16:59:55' prior: 50931073 overrides: 16927572!
setUp

	trailer _ Trailer with: 20 and: 100.
	robot _ Robot with: trailer.	
	cashier _ Cashier new.! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 17:00:10' prior: 50931077!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot
	self should: [ cashier receiveOrder: robot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'eb 10/11/2020 17:00:31' prior: 50930986!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot
	self should: [ robot withMechanicalFailure. cashier receiveOrder: robot  ]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'eb 10/11/2020 17:00:46' prior: 50931001!
test03ShouldNotAcceptSensorsFailureRobot
	self should: [ robot withSensorsFailure. cashier receiveOrder: robot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'eb 10/11/2020 17:01:07' prior: 50931034!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot
	self should: [ 			robot take: (ProductA with: 1  and: 1). 
				robot withMechanicalFailure.				cashier receiveOrder: robot.				robot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 17:01:13'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 17:01:14'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 17:01:14'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 17:01:14'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:01:14'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:01:14'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:01:14'!
PASSED!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:01:58' prior: 50918285!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight
	self should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:02:14' prior: 50918294!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight
	self should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:02:30' prior: 50918303!
test03CanNotCreateTrailerWithNoIntegerMaxWeight
	self should: [ Trailer with: 1.5  and: 100 ] 		raise: Error		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:02:40' prior: 50918312!
test04CanNotCreateTrailerWithNoIntegerMaxHeight
	self should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:02:58' prior: 50918321!
test05ShouldRejectProductAIfWeightExceeded
	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	self should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:03:02' prior: 50931303!
test05ShouldRejectProductAIfWeightExceeded
	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	self should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:03:20' prior: 50918333!
test06ShouldRejectProductBIfWeightExceeded
	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	self should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.	
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:04:34' prior: 50918345!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).	
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:04:47' prior: 50918361!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:05:04' prior: 50918378!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts
	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |
	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:05:10' prior: 50918399!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts
	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:05:12' prior: 50931395!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts
	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |
	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:05:21' prior: 50931418!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts
	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |
	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:05:52' prior: 50918421!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts
	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |
	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	self  should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:13:35'!
test01CanNotCreateTrailerWithNonPositiveMaxWeight
	self should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:13:39' prior: 50931267!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight
	self should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:13:39'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:13:39'!
PASSED!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:13:48' prior: 50931488!
test01CanNotCreateTrailerWithNonPositiveMaxWeight
	self should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !

!methodRemoval: TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'eb 10/11/2020 17:13:50'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight
	self should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:14:08'!
test02CanNotCreateTrailerWithNonPositiveMaxHeight
	self should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !

!methodRemoval: TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'eb 10/11/2020 17:14:08'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight
	self should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
!
!TrailerTest methodsFor: 'nil' stamp: 'eb 10/11/2020 17:29:59'!
createTrailer
	^ nil.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:30:26' prior: 50931339!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	| aTrailer |
	aTrailer _ self createTrailer .
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:31:00' prior: 50931649!
createTrailer

	| aTrailer |
	
	aTrailer _ Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	
	aTrailer carry: (ProductA with: 2 and: 1).
	
	aTrailer carry: (ProductB with: 3 and: 1).
	
	aTrailer carry: (ProductB with: 4 and: 1).	
	
	^ aTrailer.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:31:36' prior: 50931355!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	| aTrailer |
	aTrailer _ self createTrailer .
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:39:02' prior: 50931663!
createTrailer

	| aTrailer |
	
	aTrailer _ Trailer with: 20  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	
	aTrailer carry: (ProductA with: 2 and: 1).
	
	aTrailer carry: (ProductB with: 3 and: 1).
	
	aTrailer carry: (ProductB with: 13 and: 1).	
	
	^ aTrailer.! !

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 17:39:10'!
TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer exceededHeightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 17:42:42'!
TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer heightCapacity1 exceededHeightCapacity1 halfExceededHeightCapacity1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 17:43:26'!
TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer heightCapacity1 exceededHeightCapacity1 halfExceededHeightCapacity1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'nil' stamp: 'eb 10/11/2020 17:44:25' overrides: 16927572!
setUp
	! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:44:47' prior: 50931929 overrides: 16927572!
setUp
	
	trailer _ Trailer with: 20  and: 100.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:45:12' prior: 50931685!
createTrailer
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:45:50' prior: 50931675!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self createTrailer .
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:46:03' prior: 50931653!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self createTrailer .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:46:20' prior: 50931327!
test06ShouldRejectProductBIfWeightExceeded
	self should: [ trailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.	
	self assert: trailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:46:32' prior: 50931315!
test05ShouldRejectProductAIfWeightExceeded
	self should: [ trailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
	self assert: trailer isEmpty.! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 17:46:57'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 17:46:57'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 17:46:57'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 17:46:58'!
FAILURE!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 17:46:58'!
FAILURE!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:46:58'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 17:47:02'!
FAILURE!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 17:47:02'!
FAILURE!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:47:02'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:47:02'!
PASSED!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:47:22' prior: 50931957!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self createTrailer .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: 10.! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 17:47:27'!
FAILURE!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 17:47:27'!
FAILURE!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:47:27'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:47:27'!
PASSED!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 17:51:23' prior: 50931948!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self createTrailer .
	
	trailer carry: (ProductB with: 1 and: 1).
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:51:50' prior: 50931938!
createTrailer
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !
!TrailerTest methodsFor: 'weight capacity - private' stamp: 'eb 10/11/2020 17:55:34'!
carryProductsUntilRestCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:55:34' prior: 50932127!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self carryProductsUntilRestCapacityIsOne .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:55:34' prior: 50932237!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self carryProductsUntilRestCapacityIsOne .
	
	trailer carry: (ProductB with: 1 and: 1).
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: 11.! !

!methodRemoval: TrailerTest #createTrailer stamp: 'eb 10/11/2020 17:55:35'!
createTrailer
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	!
!TrailerTest methodsFor: 'weight capacity - private' stamp: 'eb 10/11/2020 17:56:20'!
carryProductsUntilRemainingCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:56:20' prior: 50932277!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self carryProductsUntilRemainingCapacityIsOne .
	
	trailer carry: (ProductB with: 1 and: 1).
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:56:20' prior: 50932267!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self carryProductsUntilRemainingCapacityIsOne .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: 10.! !

!methodRemoval: TrailerTest #carryProductsUntilRestCapacityIsOne stamp: 'eb 10/11/2020 17:56:20'!
carryProductsUntilRestCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	!
!TrailerTest methodsFor: 'weight capacity - private' stamp: 'eb 10/11/2020 17:56:28'!
carryProductsUntilRestCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !

!methodRemoval: TrailerTest #carryProductsUntilRestCapacityIsOne stamp: 'eb 10/11/2020 17:56:33'!
carryProductsUntilRestCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	!
!TrailerTest methodsFor: 'weight capacity - private' stamp: 'eb 10/11/2020 17:56:59'!
carryProductsUntilRemainingWeightCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:56:59' prior: 50932320!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self carryProductsUntilRemainingWeightCapacityIsOne .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:56:59' prior: 50932308!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self carryProductsUntilRemainingWeightCapacityIsOne .
	
	trailer carry: (ProductB with: 1 and: 1).
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: 11.! !

!methodRemoval: TrailerTest #carryProductsUntilRemainingCapacityIsOne stamp: 'eb 10/11/2020 17:56:59'!
carryProductsUntilRemainingCapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	!
!TrailerTest methodsFor: 'weight capacity - private' stamp: 'eb 10/11/2020 17:57:02'!
carryProductsUntilRemainingCWeapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	! !

!methodRemoval: TrailerTest #carryProductsUntilRemainingCWeapacityIsOne stamp: 'eb 10/11/2020 17:57:07'!
carryProductsUntilRemainingCWeapacityIsOne
	
	trailer carry: (ProductA with: 1 and: 1).
	
	trailer carry: (ProductA with: 2 and: 1).
	
	trailer carry: (ProductB with: 3 and: 1).
	
	trailer carry: (ProductB with: 13 and: 1).	
	!
!TrailerTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/11/2020 17:57:52' prior: 50931933 overrides: 16927572!
setUp
	
	trailer _ Trailer with: 20  and: 100.
	exceededHeightCapacity1 := 100 + 2.
	halfExceededHeightCapacity1 := exceededHeightCapacity1 / 2.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:58:30' prior: 50931373!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts
	trailer carry: (ProductA with: 10 and: halfExceededHeightCapacity1).
	trailer carry: (ProductA with: 10 and: halfExceededHeightCapacity1).
	self assert: trailer totalProductsAmount equals: 2.
	self assert: trailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:58:53' prior: 50931441!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts
	trailer carry: (ProductA with: 10 and: halfExceededHeightCapacity1).
	trailer carry: (ProductB with: 10 and: halfExceededHeightCapacity1).
	self assert: trailer totalProductsAmount equals: 2.
	self assert: trailer totalProductsHeight equals: halfExceededHeightCapacity1.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'eb 10/11/2020 17:59:17' prior: 50931463!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts
	trailer carry: (ProductB with: 10 and: halfExceededHeightCapacity1).
	self  should: [trailer carry: (ProductB with: 10 and: halfExceededHeightCapacity1)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	self assert: trailer totalProductsAmount equals: 1.
	self assert: trailer totalProductsHeight equals: halfExceededHeightCapacity1.
	! !

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer halfExceededHeightCapacity1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 17:59:34'!
TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer halfExceededHeightCapacity1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 17:59:39'!
TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:59:39' prior: 50932434!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts
	trailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	trailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	self assert: trailer totalProductsAmount equals: 2.
	self assert: trailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:59:39' prior: 50932447!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts
	trailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	trailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	self assert: trailer totalProductsAmount equals: 2.
	self assert: trailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:59:39' prior: 50932426 overrides: 16927572!
setUp
	
	trailer _ Trailer with: 20  and: 100.
	exceededHeightCapacity1 := 100 + 2.
	halfExceededHeightCapacity := exceededHeightCapacity1 / 2.! !
!TrailerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/11/2020 17:59:39' prior: 50932461!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts
	trailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	self  should: [trailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	self assert: trailer totalProductsAmount equals: 1.
	self assert: trailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 17:59:45'!
FAILURE!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 17:59:45'!
FAILURE!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:59:45'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 17:59:45'!
PASSED!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:00:07' prior: 50932371!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self carryProductsUntilRemainingWeightCapacityIsOne .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: 19.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:00:10' prior: 50932382!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self carryProductsUntilRemainingWeightCapacityIsOne .
	
	trailer carry: (ProductB with: 1 and: 1).
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: 20.! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:00:14'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:00:14'!
PASSED!
!TrailerTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/11/2020 18:02:20' prior: 50932530 overrides: 16927572!
setUp
	
	trailer _ Trailer with: 20  and: 100.
	halfExceededHeightCapacity := (100 + 2) / 2.! !

TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer weightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: #'ISW1-2020-1C-Parcial-Enunciado' stamp: 'eb 10/11/2020 18:02:40'!
TestCase subclass: #TrailerTest
	instanceVariableNames: 'trailer weightCapacity halfExceededHeightCapacity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/11/2020 18:03:16' prior: 50932659 overrides: 16927572!
setUp
	
	| heightCapacity |
	
	heightCapacity  _ 100 .
	
	weightCapacity _ 20 .
	
	trailer _ Trailer with: 20  and: 100.
	
	halfExceededHeightCapacity := (heightCapacity + 2) / 2.! !
!TrailerTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/11/2020 18:03:45' prior: 50932682 overrides: 16927572!
setUp
	
	| heightCapacity exceededHeightCapacity |
	
	heightCapacity  _ 100 .
	
	exceededHeightCapacity _ heightCapacity + 2.
	
	weightCapacity _ 20 .
	
	trailer _ Trailer with: 20  and: 100.
	
	halfExceededHeightCapacity := exceededHeightCapacity / 2.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:03:54' prior: 50932596!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity
	self carryProductsUntilRemainingWeightCapacityIsOne .
	self assert: trailer totalProductsAmount equals: 4.
	self assert: trailer totalProductsWeight equals: weightCapacity - 1.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:04:01' prior: 50932606!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity
	self carryProductsUntilRemainingWeightCapacityIsOne .
	
	trailer carry: (ProductB with: 1 and: 1).
	self assert: trailer totalProductsAmount equals: 5.
	self assert: trailer totalProductsWeight equals: weightCapacity .! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:11:39' prior: 50931976!
test05ShouldRejectProductAIfWeightExceeded
	self should: [ trailer carry: (ProductA with: weightCapacity + 1 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
	self assert: trailer isEmpty.! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:11:42'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:11:42'!
PASSED!
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:11:51' prior: 50931966!
test06ShouldRejectProductBIfWeightExceeded
	self should: [ trailer carry: (ProductB with: weightCapacity + 1and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.	
	self assert: trailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'eb 10/11/2020 18:11:52' prior: 50932837!
test06ShouldRejectProductBIfWeightExceeded
	self should: [ trailer carry: (ProductB with: weightCapacity + 1 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.	
	self assert: trailer isEmpty.! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 18:12:58'!
PASSED!

----QUIT----(11 October 2020 18:13:15) CuisUniversity-4365.image priorSource: 18728145!

----STARTUP---- (11 October 2020 20:11:35) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!

!TrailerTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/11/2020 20:17:09' prior: 50932692 overrides: 16927572!
setUp
	
	| heightCapacity exceededHeightCapacity |
	
	heightCapacity  _ 100 .
	
	exceededHeightCapacity _ heightCapacity + 2.
	
	weightCapacity _ 20 .
	
	trailer _ Trailer with: weightCapacity  and: heightCapacity .
	
	halfExceededHeightCapacity := exceededHeightCapacity / 2.! !
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:24:05' prior: 50930850!
totalProductsWeight
	^ container collect: [ :product | product weight ] sum .! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 20:24:10'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 20:24:10'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 20:24:10'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 20:24:10'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 20:24:10'!
FAILURE!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 20:24:10'!
FAILURE!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:10'!
ERROR!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:10'!
ERROR!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:10'!
ERROR!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:10'!
ERROR!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:10'!
ERROR!
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:24:22' prior: 50932978!
totalProductsWeight
	^ (container collect: [ :product | product weight ]) sum .! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 20:24:28'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 20:24:28'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 20:24:28'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 20:24:28'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 20:24:28'!
FAILURE!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 20:24:28'!
FAILURE!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:28'!
ERROR!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:28'!
ERROR!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:28'!
ERROR!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:28'!
ERROR!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:28'!
ERROR!
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:24:44' prior: 50933024!
totalProductsWeight
	
	| total  |
	total := 0.
	
	container do: [ :product | total _ total +  product weight ] .
	
	^ total .! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:48'!
PASSED!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'eb 10/11/2020 20:24:54'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:55'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:24:55'!
PASSED!
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:25:55' prior: 50933070!
totalProductsWeight
	^ container collect: [ :product | product weight ] sum .! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 20:25:59'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 20:25:59'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 20:25:59'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 20:25:59'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 20:25:59'!
FAILURE!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 20:25:59'!
FAILURE!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:25:59'!
ERROR!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 20:25:59'!
ERROR!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:25:59'!
ERROR!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:25:59'!
ERROR!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:25:59'!
ERROR!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:26:01'!
ERROR!
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:26:12' prior: 50933218!
totalProductsWeight
	^ (container collect: [ :product | product weight ]) sum .! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithNonPositiveMaxWeight stamp: 'eb 10/11/2020 20:26:16'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithNonPositiveMaxHeight stamp: 'eb 10/11/2020 20:26:16'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'eb 10/11/2020 20:26:16'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'eb 10/11/2020 20:26:16'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'eb 10/11/2020 20:26:16'!
FAILURE!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'eb 10/11/2020 20:26:16'!
FAILURE!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:26:16'!
ERROR!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/11/2020 20:26:16'!
ERROR!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:26:16'!
ERROR!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:26:16'!
ERROR!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'eb 10/11/2020 20:26:16'!
ERROR!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/11/2020 20:26:18'!
ERROR!
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:27:14' prior: 50933268!
totalProductsWeight	
	| total |
	
	total _ 0.

	(container collect: [ :product | product weight ]) sumTo: total.
	
	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:27:39' prior: 50933318!
totalProductsWeight
	^ (container collect: [ :product | product weight ]) sum.! !
!Trailer methodsFor: 'accessing' stamp: 'eb 10/11/2020 20:28:03' prior: 50933325!
totalProductsWeight
	
	| total  |
	total := 0.
	
	container do: [ :product | total _ total +  product weight ] .
	
	^ total .! !

----QUIT----(11 October 2020 20:28:22) CuisUniversity-4365.image priorSource: 19241853!

----STARTUP---- (14 October 2020 16:01:04) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\Parciales\Parciales\2019-2c\1erParcial\IngSof1-2019-2C-1Parcial.st----!

Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:25:57'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'nil' stamp: 'eb 10/14/2020 18:26:57'!
volume
	
	^ self subclassResponsibility .! !
!CoffeeShopProduct methodsFor: 'nil' stamp: 'eb 10/14/2020 18:27:09'!
price
	
	^ self subclassResponsibility .! !

CoffeeShopProduct subclass: #Combo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1 category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:28:22'!
CoffeeShopProduct subclass: #Combo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

CoffeeShopProduct subclass: #Combo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2 category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:28:33'!
CoffeeShopProduct subclass: #Combo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1 methodsFor: 'nil' stamp: 'eb 10/14/2020 18:28:53' overrides: 50933951!
volume
	
	^ 250 * milliliter .! !
!Combo1 methodsFor: 'nil' stamp: 'eb 10/14/2020 18:29:09' overrides: 50933955!
price
	
	^ 150 * peso .! !
!Combo2 methodsFor: 'nil' stamp: 'eb 10/14/2020 18:29:35' overrides: 50933951!
volume
	
	^ 100 * milliliter .! !
!Combo2 methodsFor: 'nil' stamp: 'eb 10/14/2020 18:29:56' overrides: 50933955!
price
	
	^ 120 * peso .! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'eb 10/14/2020 18:30:28' prior: 50933673!
isForCombo1
	
	^product = Combo1 new.! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'eb 10/14/2020 18:30:36' prior: 50933677!
isForCombo2
	
	^product = Combo2 new.! !
!CoffeeShopSalesSystem methodsFor: 'product volume' stamp: 'eb 10/14/2020 18:31:55' prior: 50933710!
volumeOf: aProduct
	^ aProduct volume .
	! !
!RewardRule methodsFor: 'product price' stamp: 'eb 10/14/2020 18:34:02' prior: 50933799!
priceOf: aProduct
	^ aProduct price .! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:34:25' prior: 50933861 overrides: 50933795!
rewardedProduct
	
	^Combo1 new .! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:34:50' prior: 50933913 overrides: 50933795!
rewardedProduct
	
	^ Combo2 new .! !

Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomerType category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:38:41'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

CoffeeShopCustomerType subclass: #Gold
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Gold category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:38:56'!
CoffeeShopCustomerType subclass: #Gold
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

CoffeeShopCustomerType subclass: #Silver
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Silver category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:39:02'!
CoffeeShopCustomerType subclass: #Silver
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

CoffeeShopCustomerType subclass: #Normal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Normal category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 18:39:08'!
CoffeeShopCustomerType subclass: #Normal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:41:06' prior: 50933843 overrides: 50933786!
createRewardFor: aCustomer 
	| price |
	product := self rewardedProduct.
	aCustomer type = #Gold ifTrue: [ price := 75*peso ].
	aCustomer type = #Silver ifTrue: [ price := 83*peso ].
	aCustomer type = #Normal ifTrue: [ price := 97*peso ].
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:41:30' prior: 50933893 overrides: 50933786!
createRewardFor: aCustomer 
	| price |
	product := self rewardedProduct.
	aCustomer type = #Gold ifTrue: [ price := (self priceOf: product)/2 ].
	aCustomer type = #Silver ifTrue: [ price := (self priceOf: product)*3/4 ].
	aCustomer type = #Normal ifTrue: [ price := (self priceOf: product)*9/10 ].
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!CoffeeShopCustomerType methodsFor: 'nil' stamp: 'eb 10/14/2020 18:43:10'!
combo1RewardPrice
	
	^ self subclassResponsibility .! !
!CoffeeShopCustomerType methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:43:19'!
combo2RewardPrice: aProduct
	
	^ self subclassResponsibility .! !
!Gold methodsFor: 'no messages' stamp: 'eb 10/14/2020 18:44:13' overrides: 50934110!
combo1RewardPrice
	
	^ self shouldBeImplemented .! !
!Gold methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:44:24' overrides: 50934115!
combo2RewardPrice: aProduct
	
	^ self shouldBeImplemented .! !
!Normal methodsFor: 'nil' stamp: 'eb 10/14/2020 18:45:23' overrides: 50934110!
combo1RewardPrice
	
	^ self shouldBeImplemented .! !
!Normal methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:45:30' overrides: 50934115!
combo2RewardPrice: aProduct
	
	^ self shouldBeImplemented .! !
!Silver methodsFor: 'nil' stamp: 'eb 10/14/2020 18:45:46' overrides: 50934115!
combo2RewardPrice: aProduct

	^ self shouldBeImplemented .! !
!Silver methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:45:52' overrides: 50934110!
combo1RewardPrice

	^ self shouldBeImplemented .! !
!Gold methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:46:46' prior: 50934120 overrides: 50934110!
combo1RewardPrice
	
	^ 75 * peso .! !
!Silver methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:47:17' prior: 50934145 overrides: 50934110!
combo1RewardPrice

	^ 83*peso .! !
!Normal methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:47:30' prior: 50934130 overrides: 50934110!
combo1RewardPrice
	
	^ 97*peso .! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:47:54' prior: 50934081 overrides: 50933786!
createRewardFor: aCustomer 
	| price |
	product := self rewardedProduct.
	price _ aCustomer type combo1RewardPrice .
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:48:03' prior: 50934165 overrides: 50933786!
createRewardFor: aCustomer 
	| price |
	product _ self rewardedProduct.
	price _ aCustomer type combo1RewardPrice .
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo2RewardRule methodsFor: 'nil' stamp: 'eb 10/14/2020 18:50:41'!
priceForGold
	
	^ 0 .! !
!Combo2RewardRule methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:50:45'!
priceForSilver
	
	^ 0 .! !
!Combo2RewardRule methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:50:47'!
priceForNormal
	
	^ 0 .! !
!Combo2RewardRule methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:51:28' prior: 50934184!
priceForGold
	
	^ (self priceOf: product)/2  .! !
!Combo2RewardRule methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:51:42' prior: 50934188!
priceForSilver
	
	^ (self priceOf: product)*3/4 .! !
!Combo2RewardRule methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:51:53' prior: 50934192!
priceForNormal
	
	^ (self priceOf: product)*9/10 .! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'eb 10/14/2020 18:52:42' prior: 50934095 overrides: 50933786!
createRewardFor: aCustomer 
	| price |
	product _ self rewardedProduct.
	
	price _ aCustomer type combo2RewardPrice: self .
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!CoffeeShopCustomerType methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:52:55' prior: 50934115!
combo2RewardPrice: aCombo2RewardRule
	
	^ self subclassResponsibility .! !
!Gold methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:53:07' prior: 50934125 overrides: 50934222!
combo2RewardPrice: aCombo2RewardRule
	
	^ self shouldBeImplemented .! !
!Gold methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:53:15' prior: 50934228 overrides: 50934222!
combo2RewardPrice: aCombo2RewardRule
	
	^ aCombo2RewardRule priceForGold .! !
!Silver methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:53:27' prior: 50934140 overrides: 50934222!
combo2RewardPrice: aCombo2RewardRule
	
	^ aCombo2RewardRule priceForSilver  .! !
!Normal methodsFor: 'rewards' stamp: 'eb 10/14/2020 18:53:39' prior: 50934135 overrides: 50934222!
combo2RewardPrice: aCombo2RewardRule
	
	^ aCombo2RewardRule priceForNormal  .! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'eb 10/14/2020 18:56:20' prior: 50933370!
combo1

	^ Combo1 new .! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'eb 10/14/2020 18:56:25' prior: 50933374!
combo2

	^Combo2 new .! !
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/14/2020 18:56:56' prior: 50933360 overrides: 16927572!
setUp

	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: Gold new.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: Silver new.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: Normal new .! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 18:57:47'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 18:57:47'!
FAILURE!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 18:57:47'!
FAILURE!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 18:57:47'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 18:57:47'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 18:57:47'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 18:57:47'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 18:57:47'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 18:57:47'!
FAILURE!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 18:57:47'!
FAILURE!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 18:57:47'!
FAILURE!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 18:57:47'!
FAILURE!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 18:57:48'!
FAILURE!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 18:57:48'!
FAILURE!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 18:58:04'!
FAILURE!
!CoffeeShopProduct methodsFor: 'nil' stamp: 'eb 10/14/2020 18:59:19' overrides: 16881029!
= aProduct
	
	self isKindOf: aProduct .! !
!CoffeeShopProduct methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:59:22' prior: 50934331 overrides: 16881029!
= aProduct
	
	^self isKindOf: aProduct .! !
!CoffeeShopProduct methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 18:59:54' prior: 50934337 overrides: 16881029!
= aProduct
	
	^self subclassResponsibility .! !
!Combo1 methodsFor: 'nil' stamp: 'eb 10/14/2020 19:00:34' overrides: 50934343!
= aProduct
	
	^ aProduct isKindOf: Combo1 .! !
!Combo2 methodsFor: 'nil' stamp: 'eb 10/14/2020 19:00:44' overrides: 50934343!
= aProduct
	
	^ aProduct isKindOf: Combo2 .! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:00:59'!
PASSED!

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:01:17'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:01:18'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:01:18'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:01:18'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:01:18'!
PASSED!
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:03:28' prior: 50933386!
test02CanQuerySalesByCustomer
	| salesToAdaLovelace |
	salesSystem := CoffeeShopSalesSystem new.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:03:39' prior: 50933401!
test03SalesAreDistinguishedByCustomer
	| salesToAdaLovelace salesToAlanKay |
	salesSystem := CoffeeShopSalesSystem new.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]).
	salesToAlanKay := salesSystem salesMadeTo: alanKay.
	self assert: 1 equals: salesToAlanKay size.
	self assert: 1 equals: (salesToAlanKay  count: [ :aProduct | aProduct = self combo2 ])! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:05:22' prior: 50934483!
test03SalesAreDistinguishedByCustomer
	| salesToAdaLovelace salesToAlanKay |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]).
	salesToAlanKay := salesSystem salesMadeTo: alanKay.
	self assert: 1 equals: salesToAlanKay size.
	self assert: 1 equals: (salesToAlanKay  count: [ :aProduct | aProduct = self combo2 ])! !
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/14/2020 19:05:28' prior: 50934261 overrides: 16927572!
setUp

	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: Gold new.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: Silver new.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: Normal new .
	
	salesSystem := CoffeeShopSalesSystem new.! !
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'eb 10/14/2020 19:05:32' prior: 50934528 overrides: 16927572!
setUp
	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: Gold new.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: Silver new.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: Normal new .
	
	salesSystem := CoffeeShopSalesSystem new.! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:05:34'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:05:34'!
PASSED!
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:05:47' prior: 50933378!
test01ThereAreNoSalesWhenSalesSystemIsCreated
	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:05:54' prior: 50934468!
test02CanQuerySalesByCustomer
	| salesToAdaLovelace |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'eb 10/14/2020 19:06:24' prior: 50933424!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered
	| volumeSoldToCustomer |
	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.
	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'eb 10/14/2020 19:06:33' prior: 50933435!
test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer
	| volumeSoldToCustomer |
	salesSystem := CoffeeShopSalesSystem new.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.
	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'eb 10/14/2020 19:06:45' prior: 50933448!
test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer
	| volumeSoldToCustomer |
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.
	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'eb 10/14/2020 19:06:57' prior: 50933461!
test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts
	| volumeSoldToCustomer |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.
	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:07:06' prior: 50933476!
test08NoRewardExpectedWhenCustomerHasNotBuyAnything
	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	self failWith: 'No reward expected when customer has not buy anything'! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:07:10'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:07:10'!
PASSED!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:07:32' prior: 50933486!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	| adaLovelaceReward |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].
	self assert: 1 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo2.
	self assert: 60*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:07:49' prior: 50933505!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds
	| alaKayReward |
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	alaKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].
	self assert: 1 equals: alaKayReward quantity.
	self assert: alaKayReward isForCombo2.
	self assert: 120*3/4*peso equals: alaKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:07:59' prior: 50933523!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds
	| billGatesReward |
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].
	self assert: 1 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo2.
	self assert: 120*9/10*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:08:10' prior: 50933542!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	| adaLovelaceReward |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].
	self assert: 2 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo1.
	self assert: 75*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:08:22' prior: 50933563!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds
	| alanKayReward |
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	alanKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].
	self assert: 2 equals: alanKayReward quantity.
	self assert: alanKayReward isForCombo1.
	self assert: 83*peso equals: alanKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:08:32' prior: 50933582!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds
	| billGatesReward |
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].
	self assert: 2 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo1.
	self assert: 97*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'eb 10/14/2020 19:08:49' prior: 50934640!
test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer
	| volumeSoldToCustomer |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.
	self assert: 250*milliliter equals: volumeSoldToCustomer ! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:09:02'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:09:03'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:09:03'!
PASSED!
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:12:32' prior: 50934616!
test02CanQuerySalesByCustomer
	| salesToAdaLovelace |
	
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	
	self assert: 1 equals: salesToAdaLovelace size.
	
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]) .
	salesSystem registerSaleTo: adaLovelace of: self combo1.
! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:12:49' prior: 50934921!
test02CanQuerySalesByCustomer
	| salesToAdaLovelace |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'nil' stamp: 'eb 10/14/2020 19:13:52'!
shouldSalesTo: aCustomer be: aQuantity ofType: aProductType
	
	^ self shouldBeImplemented .! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:15:14' prior: 50934948!
shouldSalesTo: aCustomer be: aQuantity ofType: aProductType
	
	| sales |
	
	sales := salesSystem salesMadeTo: aCustomer.
	
	self assert: aQuantity equals: sales size.
	
	self assert: aQuantity equals: (sales count: [ :aProduct | aProduct = aProductType ])
	
	^ self shouldBeImplemented .! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:15:17' prior: 50934955!
shouldSalesTo: aCustomer be: aQuantity ofType: aProductType
	
	| sales |
	
	sales := salesSystem salesMadeTo: aCustomer.
	
	self assert: aQuantity equals: sales size.
	
	self assert: aQuantity equals: (sales count: [ :aProduct | aProduct = aProductType ]).
	
	^ self shouldBeImplemented .! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:15:23' prior: 50934968!
shouldSalesTo: aCustomer be: aQuantity ofType: aProductType
	
	| sales |
	
	sales := salesSystem salesMadeTo: aCustomer.
	
	self assert: aQuantity equals: sales size.
	
	self assert: aQuantity equals: (sales count: [ :aProduct | aProduct = aProductType ]).! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:15:49' prior: 50934935!
test02CanQuerySalesByCustomer
	| salesToAdaLovelace |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	
	self shouldSalesTo: adaLovelace be: 1 ofType: self combo1 .! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:15:55' prior: 50934993!
test02CanQuerySalesByCustomer
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	
	self shouldSalesTo: adaLovelace be: 1 ofType: self combo1 .! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:16:30' prior: 50934506!
test03SalesAreDistinguishedByCustomer
	| salesToAdaLovelace salesToAlanKay |
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	self shouldSalesTo: adaLovelace be: 1 ofType: self combo1 .
	self shouldSalesTo: alanKay be: 1 ofType: self combo2 .! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'eb 10/14/2020 19:16:34' prior: 50935010!
test03SalesAreDistinguishedByCustomer
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	self shouldSalesTo: adaLovelace be: 1 ofType: self combo1 .
	self shouldSalesTo: alanKay be: 1 ofType: self combo2 .! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:16:37'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:16:37'!
PASSED!
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:23:27'!
should: aCustomer getsRewardedWhenRule1HoldsWithAPercentOf: aPercentaje
	
	^ self shouldBeImplemented .! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:23:38' prior: 50935091!
should: aCustomer getsRewardedWhenRule1HoldsWithAPercentOf: aPercentage
	
	^ self shouldBeImplemented .! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:26:07' prior: 50935098!
should: aCustomer getsRewardedWhenRule1HoldsWithAPercentOf: aPercentage
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: 60*peso equals: reward price.! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:26:45'!
should: aCustomer getsRewardedWithOneCombo2WhenRule1HoldsWithAPercentOf: aPercentage
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: 60*peso equals: reward price.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:28:01' prior: 50934744!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: adaLovelace getsRewardedWithOneCombo2WhenRule1HoldsWithAPercentOf: 60*peso.
! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:29:10'!
should: aCustomer getsRewardedWithOneCombo2WithFinalPrice: aPercentage
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: 60*peso equals: reward price.! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:29:16' prior: 50935142!
should: aCustomer getsRewardedWithOneCombo2WithFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: 60*peso equals: reward price.! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:29:20' prior: 50935154!
should: aCustomer getsRewardedWithOneCombo2WithFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: aPrice equals: reward price.! !

!methodRemoval: CoffeeShopTest #should:getsRewardedWhenRule1HoldsWithAPercentOf: stamp: 'eb 10/14/2020 19:29:45'!
should: aCustomer getsRewardedWhenRule1HoldsWithAPercentOf: aPercentage
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: 60*peso equals: reward price.!

!methodRemoval: CoffeeShopTest #should:getsRewardedWithOneCombo2WhenRule1HoldsWithAPercentOf: stamp: 'eb 10/14/2020 19:29:48'!
should: aCustomer getsRewardedWithOneCombo2WhenRule1HoldsWithAPercentOf: aPercentage
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: 60*peso equals: reward price.!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:30:18' prior: 50935130!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: adaLovelace getsRewardedWithOneCombo2WithFinalPrice: 60*peso.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:31:30' prior: 50934762!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	
	self should: alanKay getsRewardedWithOneCombo2WithFinalPrice: 120*3/4*peso .
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:31:58' prior: 50934779!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	self should: billGates getsRewardedWithOneCombo2WithFinalPrice: 120*9/10*peso.
! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:32:01'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:32:01'!
PASSED!
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:38:20'!
should: aCustomer reward: isFor with: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: aPrice equals: reward price.! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:38:57'!
should: aCustomer getsRewardedAndReward: isForCombo withFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: aPrice equals: reward price.! !

!methodRemoval: CoffeeShopTest #should:getsRewardedWithOneCombo2WithFinalPrice: stamp: 'eb 10/14/2020 19:39:01'!
should: aCustomer getsRewardedWithOneCombo2WithFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: aPrice equals: reward price.!

!methodRemoval: CoffeeShopTest #should:reward:with: stamp: 'eb 10/14/2020 19:39:03'!
should: aCustomer reward: isFor with: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: reward isForCombo2.
	
	self assert: aPrice equals: reward price.!
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:39:27' prior: 50935306!
should: aCustomer getsRewardedAndReward: isForCombo withFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: (isForCombo sendTo: reward).
	
	self assert: aPrice equals: reward price.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:40:15' prior: 50935203!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should:  adaLovelace getsRewardedAndReward: #isForCombo2 withFinalPrice: 60*peso.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:40:27' prior: 50935354!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: adaLovelace getsRewardedAndReward: #isForCombo2 withFinalPrice: 60*peso.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:40:41' prior: 50935215!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	
	self should: alanKay getsRewardedAndReward: #isForCombo2 withFinalPrice: 120*3/4*peso .
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:40:49' prior: 50935227!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	self should: billGates getsRewardedAndReward: #isForCombo2 withFinalPrice: 120*9/10*peso.
! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:40:57'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:40:57'!
PASSED!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:41:58' prior: 50934797!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: billGates getsRewardedAndReward: #isForCombo1 withFinalPrice: 75*peso.
! !
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:42:17'!
should: aCustomer getsRewardedWith: aQuantity productsAndReward: isForCombo withFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: (isForCombo sendTo: reward).
	
	self assert: aPrice equals: reward price.! !

!methodRemoval: CoffeeShopTest #should:getsRewardedAndReward:withFinalPrice: stamp: 'eb 10/14/2020 19:42:21'!
should: aCustomer getsRewardedAndReward: isForCombo withFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: 1 equals: reward quantity.
	
	self assert: (isForCombo sendTo: reward).
	
	self assert: aPrice equals: reward price.!
!CoffeeShopTest methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 19:42:30' prior: 50935474!
should: aCustomer getsRewardedWith: aQuantity productsAndReward: isForCombo withFinalPrice: aPrice
	
	| reward |
	
	reward _ salesSystem rewardOf: aCustomer ifNone: [ self fail ].
	
	self assert: aQuantity equals: reward quantity.
	
	self assert: (isForCombo sendTo: reward).
	
	self assert: aPrice equals: reward price.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:42:50' prior: 50935460!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: billGates getsRewardedWith: 2 productsAndReward: #isForCombo1 withFinalPrice: 75*peso.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:43:10' prior: 50935367!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: adaLovelace getsRewardedWith: 1 productsAndReward: #isForCombo2 withFinalPrice: 60*peso.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:43:23' prior: 50935379!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	
	self should: alanKay getsRewardedWith: 1 productsAndReward: #isForCombo2 withFinalPrice: 120*3/4*peso .
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:43:37' prior: 50935391!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	self should: billGates getsRewardedWith: 1 productsAndReward: #isForCombo2 withFinalPrice: 120*9/10*peso.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:46:09' prior: 50934816!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.
	
	self should: alanKay getsRewardedWith: 2 productsAndReward: #isForCombo1 withFinalPrice: 83*peso.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:46:39' prior: 50934834!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds
	| billGatesReward |
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	
	self should:  billGates getsRewardedWith: 2 productsAndReward: #isForCombo1 withFinalPrice: 97*peso.
	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].
	self assert: 2 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo1.
	self assert: 97*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:46:47' prior: 50935581!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.
	
	self should:  billGates getsRewardedWith: 2 productsAndReward: #isForCombo1 withFinalPrice: 97*peso.
! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:46:58'!
FAILURE!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:46:58'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:46:58'!
FAILURE!

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:47:57'!
FAILURE!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:47:57'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:47:57'!
FAILURE!

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:48:32'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:48:36'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:48:37'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:48:41'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:48:42'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:48:45'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:48:46'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:48:49'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:48:50'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:48:52'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:48:53'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:48:54'!
FAILURE!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:48:54'!
FAILURE!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:50:00' prior: 50935514!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: billGates getsRewardedWith: 2 productsAndReward: #isForCombo2 withFinalPrice: 75*peso.
! !

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:50:02'!
FAILURE!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:50:02'!
FAILURE!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:50:06' prior: 50935790!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: billGates getsRewardedWith: 2 productsAndReward: #isForCombo3 withFinalPrice: 75*peso.
! !

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:50:09'!
FAILURE!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:50:09'!
FAILURE!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:50:15' prior: 50935813!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: billGates getsRewardedWith: 2 productsAndReward: #isForCombo1 withFinalPrice: 75*peso.
! !

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:53:06'!
FAILURE!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:53:06'!
FAILURE!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:54:06'!
FAILURE!
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'eb 10/14/2020 19:55:33' prior: 50935836!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.
	
	self should: adaLovelace getsRewardedWith: 2 productsAndReward: #isForCombo1 withFinalPrice: 75*peso.
! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 19:55:40'!
PASSED!

Combo1 class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'Combo1 class' category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 20:03:54'!
Combo1 class
	instanceVariableNames: 'uniqueInstance'!

Combo1 class
	instanceVariableNames: ''!

!classDefinition: 'Combo1 class' category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 20:05:06'!
Combo1 class
	instanceVariableNames: ''!

CoffeeShopProduct class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'CoffeeShopProduct class' category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 20:05:10'!
CoffeeShopProduct class
	instanceVariableNames: 'uniqueInstance'!
!CoffeeShopProduct class methodsFor: 'nil' stamp: 'eb 10/14/2020 20:05:31' overrides: 16783533!
new
	
	uniqueInstance  _ self basicNew .! !
!CoffeeShopProduct class methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 20:05:37' prior: 50935954 overrides: 16783533!
new
	
	uniqueInstance  _ self basicNew .
	^ uniqueInstance .! !
!CoffeeShopProduct class methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 20:06:40' prior: 50935960 overrides: 16783533!
new
	
	uniqueInstance ifNil: [ uniqueInstance _ self basicNew .].
	
	^ uniqueInstance .! !
!CoffeeShopProduct class methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 20:06:45' prior: 50935966 overrides: 16783533!
new
	
	uniqueInstance ifNil: [ uniqueInstance _ self basicNew ].
	
	^ uniqueInstance .! !

!methodRemoval: CoffeeShopProduct #= stamp: 'eb 10/14/2020 20:07:39'!
= aProduct
	
	^self subclassResponsibility .!

!methodRemoval: Combo1 #= stamp: 'eb 10/14/2020 20:07:43'!
= aProduct
	
	^ aProduct isKindOf: Combo1 .!

!methodRemoval: Combo2 #= stamp: 'eb 10/14/2020 20:07:47'!
= aProduct
	
	^ aProduct isKindOf: Combo2 .!

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 20:07:54'!
PASSED!

CoffeeShopCustomerType class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'CoffeeShopCustomerType class' category: #'IngSof1-2019-2C-1Parcial' stamp: 'eb 10/14/2020 20:08:49'!
CoffeeShopCustomerType class
	instanceVariableNames: 'uniqueInstance'!
!CoffeeShopCustomerType class methodsFor: 'nil' stamp: 'eb 10/14/2020 20:09:20' overrides: 16783533!
new
	
	uniqueInstance ifNil: [ uniqueInstance  _ self basicNew ].
	^ uniqueInstance .! !
!CoffeeShopCustomerType class methodsFor: 'as yet unclassified' stamp: 'eb 10/14/2020 20:09:23' prior: 50936054 overrides: 16783533!
new
	
	uniqueInstance ifNil: [ uniqueInstance  _ self basicNew ].
	
	^ uniqueInstance .! !

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'eb 10/14/2020 20:09:36'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'eb 10/14/2020 20:09:37'!
PASSED!

!classRemoval: #Combo2RewardRule stamp: 'eb 10/14/2020 20:10:53'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'eb 10/14/2020 20:10:54'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'eb 10/14/2020 20:10:54'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'eb 10/14/2020 20:10:54'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'eb 10/14/2020 20:10:54'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo2 stamp: 'eb 10/14/2020 20:10:55'!
CoffeeShopProduct subclass: #Combo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1 stamp: 'eb 10/14/2020 20:10:55'!
CoffeeShopProduct subclass: #Combo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'eb 10/14/2020 20:10:55'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Silver stamp: 'eb 10/14/2020 20:10:55'!
CoffeeShopCustomerType subclass: #Silver
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Normal stamp: 'eb 10/14/2020 20:10:56'!
CoffeeShopCustomerType subclass: #Normal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Gold stamp: 'eb 10/14/2020 20:10:56'!
CoffeeShopCustomerType subclass: #Gold
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'eb 10/14/2020 20:10:56'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'eb 10/14/2020 20:10:56'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'eb 10/14/2020 20:10:57'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

----End fileIn of C:\Program Files\CuisUniversity\IngSof1-2019-2C-1Parcial.st----!

----End fileIn of C:\Program Files\CuisUniversity\IngSof1-2019-2C-1Parcial-Singleton.st----!

----QUIT----(14 October 2020 22:42:54) CuisUniversity-4365.image priorSource: 19253987!

----STARTUP---- (14 October 2020 22:47:46) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Program Files\CuisUniversity\IngSof1-2019-2C-1Parcial.st----!

!classRemoval: #Combo2RewardRule stamp: 'eb 10/14/2020 22:48:49'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'eb 10/14/2020 22:48:50'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'eb 10/14/2020 22:48:50'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'eb 10/14/2020 22:48:51'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'eb 10/14/2020 22:48:51'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo2 stamp: 'eb 10/14/2020 22:48:52'!
CoffeeShopProduct subclass: #Combo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1 stamp: 'eb 10/14/2020 22:48:52'!
CoffeeShopProduct subclass: #Combo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'eb 10/14/2020 22:48:52'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Silver stamp: 'eb 10/14/2020 22:48:53'!
CoffeeShopCustomerType subclass: #Silver
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Normal stamp: 'eb 10/14/2020 22:48:53'!
CoffeeShopCustomerType subclass: #Normal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Gold stamp: 'eb 10/14/2020 22:48:54'!
CoffeeShopCustomerType subclass: #Gold
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'eb 10/14/2020 22:48:54'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'eb 10/14/2020 22:48:54'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'eb 10/14/2020 22:48:55'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

----End fileIn of C:\Program Files\CuisUniversity\IngSof1-2019-2C-1Parcial.st----!

!classRemoval: #Combo2RewardRule stamp: 'eb 10/14/2020 23:01:31'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'eb 10/14/2020 23:01:32'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'eb 10/14/2020 23:01:32'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'eb 10/14/2020 23:01:32'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'eb 10/14/2020 23:01:33'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo2 stamp: 'eb 10/14/2020 23:01:33'!
CoffeeShopProduct subclass: #Combo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1 stamp: 'eb 10/14/2020 23:01:34'!
CoffeeShopProduct subclass: #Combo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'eb 10/14/2020 23:01:34'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Silver stamp: 'eb 10/14/2020 23:01:35'!
CoffeeShopCustomerType subclass: #Silver
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Normal stamp: 'eb 10/14/2020 23:01:35'!
CoffeeShopCustomerType subclass: #Normal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Gold stamp: 'eb 10/14/2020 23:01:36'!
CoffeeShopCustomerType subclass: #Gold
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'eb 10/14/2020 23:01:36'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'eb 10/14/2020 23:01:37'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'eb 10/14/2020 23:01:37'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

----End fileIn of C:\Program Files\CuisUniversity\IngSof1-2019-2C-1Parcial-Singleton.st----!

----QUIT----(14 October 2020 23:09:09) CuisUniversity-4365.image priorSource: 19393577!

----STARTUP---- (15 October 2020 10:03:33) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\Parciales\Parciales\2019-1c\ISW1-2019-1C-Parcial.st----!
!Slot methodsFor: 'nil' stamp: 'eb 10/15/2020 10:11:01'!
isOccupied
	 ^ self shouldBeImplemented .! !

!testRun: #SlotTest #test03CanReserveASlot stamp: 'eb 10/15/2020 10:11:17'!
ERROR!

!testRun: #SlotTest #test03CanReserveASlot stamp: 'eb 10/15/2020 10:11:17'!
ERROR!
!Slot methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 10:11:45'!
reserve
	self shouldBeImplemented.! !

!testRun: #SlotTest #test03CanReserveASlot stamp: 'eb 10/15/2020 10:12:14'!
ERROR!

!testRun: #SlotTest #test03CanReserveASlot stamp: 'eb 10/15/2020 10:12:14'!
ERROR!
!Slot methodsFor: 'nil' stamp: 'eb 10/15/2020 10:13:00'!
isReserved
	
	^ self shouldBeImplemented .! !

!testRun: #SlotTest #test11CostOfAnEmptySlotIsCeroPesos stamp: 'eb 10/15/2020 10:13:29'!
ERROR!

!testRun: #SlotTest #test11CostOfAnEmptySlotIsCeroPesos stamp: 'eb 10/15/2020 10:13:29'!
ERROR!
!Slot methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 10:13:37'!
costUsing: aDictionary ifUnknowVehicleType: aBlockClosure 
	self shouldBeImplemented.! !

Object subclass: #Slot
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!

!classDefinition: #Slot category: #'ISW1-2019-1C-Parcial' stamp: 'eb 10/15/2020 10:14:23'!
Object subclass: #Slot
	instanceVariableNames: 'state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2019-1C-Parcial'!
!Slot methodsFor: 'nil' stamp: 'eb 10/15/2020 10:18:48'!
isEmpty
	
	^ self shouldBeImplemented .! !
!Slot methodsFor: 'nil' stamp: 'eb 10/15/2020 10:20:48'!
release
	
	^ self shouldBeImplemented .! !

----QUIT----(15 October 2020 12:26:04) CuisUniversity-4365.image priorSource: 19470249!

----STARTUP---- (15 October 2020 16:58:07) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Downloads\ISW1-2020-2C-Parcial-Enunciado.st----!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 17:31:09'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 17:31:09'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 17:35:11' prior: 50941254!
totalPoints
		
	| total  |

	total _ 0.	

	(container detect: [ :portableObject | portableObject doesItAddPoints ]) 
		collect: [ :portableObject | total := total +  portableObject points ].

	^ total.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:35:13'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 17:35:13'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 17:35:13'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 17:35:13'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 17:35:13'!
ERROR!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 17:35:14'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 17:35:14'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 17:35:14'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 17:35:14'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 17:35:54' prior: 50941940!
totalPoints
		
	| total  |

	total _ 0.	

	(container detect: [ :portableObject | portableObject doesItAddPoints ]) 
		do: [ :portableObject | total := total +  portableObject points ].

	^ total.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 17:35:56'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 17:35:56'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:35:57'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 17:35:57'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 17:35:57'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 17:35:57'!
ERROR!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 17:35:57'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 17:35:57'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 17:35:57'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:35:59'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 17:36:49' prior: 50942042!
totalPoints
		
	| total  |

	total _ 0.	

	(container select: [ :portableObject | portableObject doesItAddPoints ]) 
		do: [ :portableObject | total := total +  portableObject points ].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 17:36:55' prior: 50942148!
totalPoints
		
	| total  |

	total _ 0.	

	(container select: [ :portableObject | portableObject doesItAddPoints ]) 
		do: [ :portableObject | total := total +  portableObject points ].

	^ total.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 17:36:58'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 17:36:58'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 17:38:01' prior: 50941266!
totalWeight
	
	| total |

	total := 0.

	container do: [ :portableObject | total _ total + portableObject weight ].

	^ total.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 17:38:04'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 17:38:04'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 17:38:09' prior: 50942157!
totalPoints
		
	| total  |

	total _ 0.	

	(container select: [ :portableObject | portableObject doesItAddPoints ]) 
		do: [ :portableObject | total _ total +  portableObject points ].

	^ total.! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'eb 10/15/2020 17:40:24' overrides: 50941675!
addTo: aBackpack
	
	^ aBackpack addNoPointsPortableObject .! !
!PointsPortableObject methodsFor: 'nil' stamp: 'eb 10/15/2020 17:41:13' overrides: 50941675!
addTo: aBackpack
	
	^ aBackpack addPointsPortableObject .! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:41:39'!
addNoPointsPortableObject
	! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:41:42'!
addPointsPortableObject
	! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:41:59'!
addNoPointsPortableObject: aNoPointsPortableObject
	! !

!methodRemoval: Backpack #addNoPointsPortableObject stamp: 'eb 10/15/2020 17:42:06'!
addNoPointsPortableObject
	!
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:42:15'!
addPointsPortableObject: aPointsPortableObject
	! !

!methodRemoval: Backpack #addPointsPortableObject stamp: 'eb 10/15/2020 17:42:18'!
addPointsPortableObject
	!
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:43:04' prior: 50942384!
addNoPointsPortableObject: aNoPointsPortableObject
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	container add: aNoPointsPortableObject.! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:43:20' prior: 50942392!
addPointsPortableObject: aPointsPortableObject
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	container add: aPointsPortableObject.! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:43:45' prior: 50941292!
add: aPortableObject
	
	aPortableObject addTo: self .! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:43:57' prior: 50942369 overrides: 50941675!
addTo: aBackpack
	
	^ aBackpack addNoPointsPortableObject: self .! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:44:06' prior: 50942374 overrides: 50941675!
addTo: aBackpack
	
	^ aBackpack addPointsPortableObject: self .! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:44:16' prior: 50942400!
addNoPointsPortableObject: aNoPointsPortableObject

	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	container add: aNoPointsPortableObject.! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:44:17' prior: 50942435!
addNoPointsPortableObject: aNoPointsPortableObject

	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	
	container add: aNoPointsPortableObject.! !
!Backpack methodsFor: 'adding' stamp: 'eb 10/15/2020 17:44:23' prior: 50942408!
addPointsPortableObject: aPointsPortableObject

	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	
	self assertPointsAdding: aPointsPortableObject.
	
	container add: aPointsPortableObject.! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:44:37' prior: 50942423 overrides: 50941675!
addTo: aBackpack
	
	aBackpack addNoPointsPortableObject: self .! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:44:42' prior: 50942430 overrides: 50941675!
addTo: aBackpack
	
	aBackpack addPointsPortableObject: self .! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 17:44:45'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 17:44:46'!
PASSED!

DoorState subclass: #Opened
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #Opened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Opened category: #'ISW1-2020-2C-Parcial-Enunciado' stamp: 'eb 10/15/2020 17:47:12'!
DoorState subclass: #Opened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #Closed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Closed category: #'ISW1-2020-2C-Parcial-Enunciado' stamp: 'eb 10/15/2020 17:47:18'!
DoorState subclass: #Closed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #KeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #KeyClosed category: #'ISW1-2020-2C-Parcial-Enunciado' stamp: 'eb 10/15/2020 17:47:22'!
DoorState subclass: #KeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door class methodsFor: 'instance creation' stamp: 'eb 10/15/2020 17:50:16' prior: 50941610!
closed

	| door state |
	
	door _ Door new.
	state _ Closed for: self.
	door initializeWith: state.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'eb 10/15/2020 17:51:25' prior: 50941616!
closedWith: aKey

	| door state |
	
	door _ Door new.
	state _ KeyClosed for: self .
	door initializeWith: state using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'eb 10/15/2020 17:51:56' prior: 50941622!
opened

	| door state |
	
	door _ Door new.
	state _ Opened for: self .
	door initializeWith: state.
	
	^ door.! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 17:53:31' prior: 50941553 overrides: 50941506!
toBeClosedBy: aPlayableCharacter
	
	state close .

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 17:53:40' prior: 50941565 overrides: 50941511!
toBeOpenedBy: aPlayableCharacter

	state open .

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 17:53:53' prior: 50941577 overrides: 50941516!
toBeOpenedBy: aPlayableCharacter using: aKey

	state openUsing: aKey.

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Opened methodsFor: 'nil' stamp: 'eb 10/15/2020 17:55:28' overrides: 50941409!
close
	
	door! !
!Door methodsFor: 'nil' stamp: 'eb 10/15/2020 17:57:00'!
closeWhenOpened
	
	state _ Closed for: self .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:57:23' prior: 50942676!
closeWhenOpened
	
	state _ Closed for: self .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:57:40'!
closeWhenClosed
	
	self error: self class .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:57:51' prior: 50942685!
closeWhenClosed
	
	self error: self class alreadyClosedErrorDescription.! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:58:07'!
closeWhenKwyClosed
	
	self error: self class alreadyClosedErrorDescription.! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:58:13'!
closeWhenKeyClosed
	
	self error: self class alreadyClosedErrorDescription.! !

!methodRemoval: Door #closeWhenKwyClosed stamp: 'eb 10/15/2020 17:58:13'!
closeWhenKwyClosed
	
	self error: self class alreadyClosedErrorDescription.!
!Opened methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:58:31' prior: 50942673 overrides: 50941409!
close
	
	door closeWhenOpened .! !
!Closed methodsFor: 'nil' stamp: 'eb 10/15/2020 17:58:49' overrides: 50941409!
close

	door closeWhenKeyClosed .! !
!KeyClosed methodsFor: 'nil' stamp: 'eb 10/15/2020 17:59:01' overrides: 50941409!
close
	
	door closeWhenKeyClosed .! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 17:59:12' prior: 50942632 overrides: 50941506!
toBeClosedBy: aPlayableCharacter
	
	state close .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:59:45'!
openWhenClosed
	
	state _ Opened for: self .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 17:59:55'!
openWhenOpen
	
	self error: self class ! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:00:04' prior: 50942732!
openWhenOpen
	
	self error: self class alreadyOpenedErrorDescription .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:00:19'!
openWhenKeyClosed
	
	self error: self class closedWithKeyErrorDescription .! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 18:00:30' prior: 50942645 overrides: 50941511!
toBeOpenedBy: aPlayableCharacter

	state open .! !
!Closed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:00:44' overrides: 50941413!
open
	
	door openWhenClosed .! !
!KeyClosed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:00:59' overrides: 50941413!
open
	
	door openWhenKeyClosed .! !
!Opened methodsFor: 'nil' stamp: 'eb 10/15/2020 18:01:16' overrides: 50941413!
open
	
	door openWhenOpen .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:01:21'!
openWhenOpened
	
	self error: self class alreadyOpenedErrorDescription .! !

!methodRemoval: Door #openWhenOpen stamp: 'eb 10/15/2020 18:01:24'!
openWhenOpen
	
	self error: self class alreadyOpenedErrorDescription .!
!Opened methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:01:30' prior: 50942762 overrides: 50941413!
open
	
	door openWhenOpened .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:02:13'!
openUsingWhenClosed: aKey
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:02:18'!
openUsingWhenKeyClosed: aKey
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:02:23'!
openUsingWhenOpened: aKey
	! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:02:44' prior: 50942789!
openUsingWhenOpened: aKey

	self error: self class alreadyOpenedErrorDescription! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:02:46' prior: 50942793!
openUsingWhenOpened: aKey

	self error: self class alreadyOpenedErrorDescription .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:03:03' prior: 50942781!
openUsingWhenClosed: aKey
	
	self error: self class noNeedForAKeyErrorDescription .! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:03:29'!
openWhenKeyClosed: aKey
	
	(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. ! !

!methodRemoval: Door #openWhenKeyClosed: stamp: 'eb 10/15/2020 18:03:44'!
openWhenKeyClosed: aKey
	
	(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:03:57' prior: 50942785!
openUsingWhenKeyClosed: aKey

	(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. ! !
!Door methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:05:08' prior: 50942823!
openUsingWhenKeyClosed: aKey

	(key == aKey) ifTrue: [ ^ state _ Opened for: self ].
	
	self error: Door notCorrectKeyErrorDescription. ! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 18:06:27' prior: 50941591 overrides: 50941522!
toBeUsedBy: aPlayableCharacter

	(state = Opened for: self) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state = Closed for: self) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state = KeyClosed for: self) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:06:30'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:06:30'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:06:30'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:06:30'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:06:30'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:06:34'!
ERROR!
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 18:07:11' prior: 50942658 overrides: 50941516!
toBeOpenedBy: aPlayableCharacter using: aKey

	state openUsing: aKey.! !
!Closed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:08:27' overrides: 50941417!
openUsing: aKey
	
	door openUsingWhenClosed: aKey .! !
!KeyClosed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:08:40' overrides: 50941417!
openUsing: aKey
	
	door openUsingWhenKeyClosed: aKey .! !
!Opened methodsFor: 'nil' stamp: 'eb 10/15/2020 18:08:47' overrides: 50941417!
openUsing: aKey
	
	door openUsingWhenOpened: aKey .! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:08:50'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:08:50'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:08:50'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:08:50'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:08:50'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:08:52'!
ERROR!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:09:37'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:09:38'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:09:38'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:09:38'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:09:38'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:09:38'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:09:38'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:09:38'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:09:41'!
ERROR!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:10:55'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:10:55'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:10:55'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:10:55'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:10:55'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:10:56'!
ERROR!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:11:11'!
ERROR!
!Closed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:12:16' overrides: 50941421!
isOpen
	
	^ false .! !
!KeyClosed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:12:21' overrides: 50941421!
isOpen
	
	^ false .! !
!Opened methodsFor: 'nil' stamp: 'eb 10/15/2020 18:12:26' overrides: 50941421!
isOpen
	
	^ true .! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:12:28'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:12:28'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:12:28'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:12:28'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:12:28'!
FAILURE!
!Closed methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:12:53' prior: 50942715 overrides: 50941409!
close

	door closeWhenClosed .! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 18:14:05' prior: 50942839 overrides: 50941522!
toBeUsedBy: aPlayableCharacter

	(state = (Opened for: self)) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state = (Closed for: self)) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state = (KeyClosed for: self)) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:14:07'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:14:07'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:14:07'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:14:07'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:14:10'!
ERROR!

	door openWhenClosed .!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:16:21'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:16:21'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:16:21'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:16:21'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:16:23'!
ERROR!
!Door class methodsFor: 'instance creation' stamp: 'eb 10/15/2020 18:18:23' prior: 50942609!
closed

	| door state |
	
	door _ Door new.
	state _ Closed for: door.
	door initializeWith: state.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'eb 10/15/2020 18:18:28' prior: 50942616!
closedWith: aKey

	| door state |
	
	door _ Door new.
	state _ KeyClosed for: door .
	door initializeWith: state using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'eb 10/15/2020 18:18:31' prior: 50942624!
opened

	| door state |
	
	door _ Door new.
	state _ Opened for: door .
	door initializeWith: state.
	
	^ door.! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:18:34'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:18:34'!
FAILURE!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:18:39'!
FAILURE!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:19:52'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:19:52'!
FAILURE!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:20:01'!
FAILURE!
!Door methodsFor: 'testing' stamp: 'eb 10/15/2020 18:20:23' prior: 50941539!
isOpen

	^ state isOpen .
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:20:25'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:20:25'!
FAILURE!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:20:25'!
FAILURE!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:20:25'!
FAILURE!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:20:28'!
FAILURE!
!DoorState methodsFor: 'nil' stamp: 'eb 10/15/2020 18:23:23'!
useBy: aPlayableCharacter
	
	self subclassResponsibility .! !
!Closed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:23:54' overrides: 50943887!
useBy: aPlayableCharacter
	
	self subclassResponsibility .! !
!KeyClosed methodsFor: 'nil' stamp: 'eb 10/15/2020 18:24:00' overrides: 50943887!
useBy: aPlayableCharacter
	
	self subclassResponsibility .! !
!Opened methodsFor: 'nil' stamp: 'eb 10/15/2020 18:24:06' overrides: 50943887!
useBy: aPlayableCharacter
	
	self subclassResponsibility .! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 18:24:30' prior: 50943369 overrides: 50941522!
toBeUsedBy: aPlayableCharacter
	
	state useBy: aPlayableCharacter .
	(state = (Opened for: self)) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state = (Closed for: self)) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state = (KeyClosed for: self)) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!Opened methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:24:57' prior: 50943902 overrides: 50943887!
useBy: aPlayableCharacter
	
	door toBeClosedBy: aPlayableCharacter .! !
!Closed methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:25:26' prior: 50943892 overrides: 50943887!
useBy: aPlayableCharacter
	
	door toBeOpenedBy: aPlayableCharacter .! !
!KeyClosed methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:25:39' prior: 50943897 overrides: 50943887!
useBy: aPlayableCharacter
	
	door toBeOpenedBy: aPlayableCharacter.! !
!Door methodsFor: 'playable character reactions' stamp: 'eb 10/15/2020 18:25:53' prior: 50943908 overrides: 50941522!
toBeUsedBy: aPlayableCharacter
	
	state useBy: aPlayableCharacter .! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:25:56'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:27:54'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:27:54'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:36:50' prior: 50940842!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack aNoPointsPortableObject |
	
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	aNoPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) .

	self
		should: [ aBackpack add: aNoPointsPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:37:17' prior: 50940856!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack aPointsPortableObject |
	
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	aPointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) .

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:37:24' prior: 50944148!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack aPointsPortableObject |
	
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	aPointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) .

	self
		should: [ aBackpack add: aPointsPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:39:00'!
shouldAdding: aNoPointsPortableObject raisesAnErrorOfWeightExceededIn: aBackpack

	self
		should: [ aBackpack add: aNoPointsPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:39:00' prior: 50944131!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack aNoPointsPortableObject |
	
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.
	
	aNoPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) .

	self shouldAdding: aNoPointsPortableObject raisesAnErrorOfWeightExceededIn: aBackpack. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:39:50' prior: 50944183!
shouldAdding: aNoPointsPortableObject raisesAnErrorOfWeightExceededIn: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aNoPointsPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:40:10' prior: 50944208!
shouldAdding: aPortableObject raisesAnErrorOfWeightExceededIn: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:40:20' prior: 50944223!
shouldAdding: aWeigthExceededPortableObject raisesAnErrorOfWeightExceededIn: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:41:19' prior: 50944194!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aNoPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aNoPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: aBackpackWeightCapacity + 1) .

	self shouldAdding: aNoPointsPortableObject raisesAnErrorOfWeightExceededIn: aBackpackWeightCapacity. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:41:49' prior: 50944252!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aWeightExceededNoPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aWeightExceededNoPointsPortableObject _ 
	(NoPointsPortableObject named: 'help-wanted sign' weighing: aBackpackWeightCapacity + 1) .

	self shouldAdding: aWeightExceededNoPointsPortableObject raisesAnErrorOfWeightExceededIn: aBackpackWeightCapacity. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:42:58'!
should: aWeigthExceededPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !

!methodRemoval: BackpackTest #shouldAdding:raisesAnErrorOfWeightExceededIn: stamp: 'eb 10/15/2020 18:43:03'!
shouldAdding: aWeigthExceededPortableObject raisesAnErrorOfWeightExceededIn: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty!
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:43:37' prior: 50944267!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aWeightExceededNoPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aWeightExceededNoPointsPortableObject _ 
	(NoPointsPortableObject named: 'help-wanted sign' weighing: aBackpackWeightCapacity + 1) .
	
	self should:  aWeightExceededNoPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:44:01' prior: 50944314!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity aWeightExceededNoPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	aWeightExceededNoPointsPortableObject _ 
	(NoPointsPortableObject named: 'help-wanted sign' weighing: backpackWeightCapacity + 1) .
	
	self should:  aWeightExceededNoPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:44:22' prior: 50944331!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity noPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ 
	(NoPointsPortableObject named: 'help-wanted sign' weighing: backpackWeightCapacity + 1) .
	
	self should:  noPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:44:25' prior: 50944348!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity noPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: backpackWeightCapacity + 1) .
	
	self should:  noPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:44:50' prior: 50944363!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity noPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: backpackWeightCapacity + 1) .
	
	self should: noPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:46:36' prior: 50944167!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity noPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) .
	
	self should: noPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:46:44' prior: 50944393!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) .
	
	self should: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:47:07' prior: 50944283!
should: aWeigthExceededPortableObject 
raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !
!BackpackTest methodsFor: 'nil' stamp: 'eb 10/15/2020 18:51:29'!
createBackpackWithARemainingWeightCapacityOfOne
	! !
!BackpackTest methodsFor: 'adding - private' stamp: 'eb 10/15/2020 18:52:08' prior: 50944438!
createBackpackWithARemainingWeightCapacityOfOne

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	^ aBackpack .! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:52:28' prior: 50940870!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	
	aBackpack _ self createBackpackWithARemainingWeightCapacityOfOne .
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'nil' stamp: 'eb 10/15/2020 18:53:33'!
assert: aBackpack hasSizeOf: aSize withWeightOf: aWeight
	! !
!BackpackTest methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:53:47'!
assert: aBackpack hasSizeOf: aSize withWeightOf: aWeight andPoints: aPoints
	! !

!methodRemoval: BackpackTest #assert:hasSizeOf:withWeightOf: stamp: 'eb 10/15/2020 18:54:26'!
assert: aBackpack hasSizeOf: aSize withWeightOf: aWeight
	!
!BackpackTest methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 18:54:38' prior: 50944473!
assert: aBackpack hasSizeOf: aSize withWeightOf: aWeight andPoints: aPoints

	self assert: aBackpack size equals: aSize.
	
	self assert: aBackpack totalWeight equals: aWeight.
	
	self assert: aBackpack totalPoints equals: aPoints.
	! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:55:15' prior: 50944456!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	
	aBackpack _ self createBackpackWithARemainingWeightCapacityOfOne .
	
	self assert: aBackpack hasSizeOf:  2 withWeightOf:  41 andPoints: 5.
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:55:19' prior: 50944494!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	
	aBackpack _ self createBackpackWithARemainingWeightCapacityOfOne .
	
	self assert: aBackpack hasSizeOf:  2 withWeightOf:  41 andPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:55:54' prior: 50940887!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	
	aBackpack _ self createBackpackWithARemainingWeightCapacityOfOne .
	
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:56:15' prior: 50944518!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	
	aBackpack _ self createBackpackWithARemainingWeightCapacityOfOne .
	
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert:  aBackpack hasSizeOf:  3 withWeightOf: 42 andPoints: 10 .
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:56:19'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:56:20'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:56:20'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:58:05' prior: 50944408!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity + 6 worth: 5) .
	
	self should: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:58:22' prior: 50944639!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity + 6 worth: 5) .
	
	self should: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:58:39' prior: 50944654!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity+6 worth: 5) .
	
	self should: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:58:48' prior: 50944669!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity + 6 worth: 5) .
	
	self should: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:58:48'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 18:58:49'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 18:58:49'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:58:54' prior: 50944684!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity+6 worth: 5) .
	
	self should: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 18:59:26' prior: 50944508!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	
	aBackpack _ self createBackpackWithARemainingWeightCapacityOfOne .
	
	self assert: aBackpack hasSizeOf: 2 withWeightOf:  41 andPoints: 5.
! !
!BackpackTest methodsFor: 'adding - private' stamp: 'eb 10/15/2020 19:00:19' prior: 50944443!
createBackpackWithARemainingWeightCapacityOfOne

	| aBackpack |
	
	aBackpack _ Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	^ aBackpack .! !
!BackpackTest methodsFor: 'adding - private' stamp: 'eb 10/15/2020 19:00:58'!
shouldAdding: aWeigthExceededPortableObject 
raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !
!BackpackTest methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 19:00:58' prior: 50944893!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity+6 worth: 5) .
	
	self shouldAdding: pointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !
!BackpackTest methodsFor: 'as yet unclassified' stamp: 'eb 10/15/2020 19:00:58' prior: 50944378!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity noPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: backpackWeightCapacity + 1) .
	
	self shouldAdding: noPointsPortableObject raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity . 
! !

!methodRemoval: BackpackTest #should:raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: stamp: 'eb 10/15/2020 19:00:58'!
should: aWeigthExceededPortableObject 
raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty!
!BackpackTest methodsFor: 'adding - private' stamp: 'eb 10/15/2020 19:01:16'!
should: aWeigthExceededPortableObject 
raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty! !

!methodRemoval: BackpackTest #should:raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: stamp: 'eb 10/15/2020 19:01:18'!
should: aWeigthExceededPortableObject 
raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: aBackpackWeightCapacity limitingPointsTo: 100.
	
	self
		should: [ aBackpack add: aWeigthExceededPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty!
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:01:47' prior: 50944963!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity noPointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: backpackWeightCapacity + 1) .
	
	self shouldAdding: noPointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:01:54' prior: 50944947!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| backpackWeightCapacity pointsPortableObject |
	
	backpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: backpackWeightCapacity+6 worth: 5) .
	
	self shouldAdding: pointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: backpackWeightCapacity .
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 19:02:00'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 19:02:01'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 19:02:01'!
PASSED!
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:02:19' prior: 50945027!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity noPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	noPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: aBackpackWeightCapacity + 1) .
	
	self shouldAdding: noPointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:02:26' prior: 50945150!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aNoPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aNoPointsPortableObject _ (NoPointsPortableObject named: 'help-wanted sign' weighing: aBackpackWeightCapacity + 1) .
	
	self shouldAdding: aNoPointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity . 
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:02:38' prior: 50945042!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity pointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	pointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: aBackpackWeightCapacity+6 worth: 5) .
	
	self shouldAdding: pointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:02:50' prior: 50945182!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aPointsPortableObject _ (PointsPortableObject named: 'left-handed hammer' weighing: aBackpackWeightCapacity+6 worth: 5) .
	
	self shouldAdding: aPointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:02:55' prior: 50945197!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aPointsPortableObject _ (PointsPortableObject 
		named: 'left-handed hammer' weighing: aBackpackWeightCapacity+6 worth: 5) .
	
	self shouldAdding: aPointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity .
! !
!BackpackTest methodsFor: 'adding' stamp: 'eb 10/15/2020 19:03:19' prior: 50945166!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpackWeightCapacity aNoPointsPortableObject |
	
	aBackpackWeightCapacity _ 42 .
	
	aNoPointsPortableObject _ (NoPointsPortableObject 
		named: 'help-wanted sign' weighing: aBackpackWeightCapacity + 1) .
	
	self shouldAdding: aNoPointsPortableObject 
		raisesAnErrorOfWeightExceededWhenAddingToABackpackWith: aBackpackWeightCapacity . 
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 19:04:08'!
PASSED!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 19:04:15'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 19:04:15'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 19:06:39' prior: 50942359!
totalPoints
		
	| total  |

	total _ 0.	

	(container select: [ :portableObject | portableObject doesItAddPoints ]) do: [ :portableObject | total _ total +  portableObject points ].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 19:06:43' prior: 50945430!
totalPoints
		
	| total  |

	total _ 0.	

	(container select: [ :portableObject | portableObject doesItAddPoints ]) 
		do: [ :portableObject | total _ total +  portableObject points ].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'eb 10/15/2020 19:06:54' prior: 50942259!
totalWeight
	
	| total |

	total _ 0.

	container do: [ :portableObject | total _ total + portableObject weight ].

	^ total.! !
!Door methodsFor: 'state dependent playable character reactions' stamp: 'eb 10/15/2020 19:11:33' prior: 50942830!
openUsingWhenKeyClosed: aKey

	(key == aKey) ifTrue: [ ^ state _ Opened for: self ].
	
	self error: self class notCorrectKeyErrorDescription. ! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 19:12:45'!
PASSED!

!classRemoval: #PointsPortableObject stamp: 'eb 10/15/2020 19:14:48'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'eb 10/15/2020 19:14:48'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'eb 10/15/2020 19:14:49'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'eb 10/15/2020 19:14:49'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'eb 10/15/2020 19:14:49'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'eb 10/15/2020 19:14:50'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Opened stamp: 'eb 10/15/2020 19:14:50'!
DoorState subclass: #Opened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #KeyClosed stamp: 'eb 10/15/2020 19:14:50'!
DoorState subclass: #KeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Closed stamp: 'eb 10/15/2020 19:14:51'!
DoorState subclass: #Closed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'eb 10/15/2020 19:14:51'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'eb 10/15/2020 19:14:51'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'eb 10/15/2020 19:14:52'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'eb 10/15/2020 19:14:52'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

----End fileIn of C:\Users\ebonansea\Desktop\entrega isw1\ISW1-2020-2C-Parcial-Enunciado.st----!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'eb 10/15/2020 19:15:15'!
PASSED!

----QUIT----(15 October 2020 19:28:42) CuisUniversity-4365.image priorSource: 19493514!

----STARTUP---- (22 October 2020 17:18:44) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


Object subclass: #Rot13test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Rot13test category: #'ISW1-2020-2C-Parcial-Enunciado' stamp: 'eb 10/22/2020 17:22:28'!
Object subclass: #Rot13test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Rot13test stamp: 'eb 10/22/2020 17:22:46'!
Object subclass: #Rot13test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

Object subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!

!classDefinition: #Rot13Test category: #Rot13 stamp: 'eb 10/22/2020 17:23:08'!
Object subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!
!Rot13Test methodsFor: 'no messages' stamp: 'eb 10/22/2020 17:23:56'!
test01

	self assert: '' equals: '' asRot13.! !

self assert: '' equals: '' asRot13.!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:25:21'!
asRot13
	self shouldBeImplemented.! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:25:41' prior: 50946974!
asRot13
	self shouldBeImplemented.! !

TestCase subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!

!classDefinition: #Rot13Test category: #Rot13 stamp: 'eb 10/22/2020 17:27:44'!
TestCase subclass: #Rot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Rot13'!
!Rot13Test methodsFor: 'nil' stamp: 'eb 10/22/2020 17:29:30'!
test02
	
	self assert: 'n' equals: 'a' asRot13 .! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 17:29:36'!
ERROR!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:29:36'!
ERROR!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:31:06' prior: 50946978!
asRot13
	
	self isEmpty ifTrue: [ ^self ] ifFalse: [ ^'n' ].! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 17:31:14'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:31:14'!
PASSED!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:41:52' prior: 50947001!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	self = 'a' ifTrue:  [^'n'].
	^ 'o' .! !
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 17:42:04'!
test03
	
	self assert: 'o' equals: 'b' asRot13 .! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 17:42:07'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:42:07'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 17:42:07'!
PASSED!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:52:03' prior: 50947010!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	^ Character asciiValue: (self first asciiValue + 13) asString .! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 17:52:09'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:52:09'!
ERROR!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 17:52:09'!
ERROR!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:52:15'!
ERROR!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:52:54' prior: 50947027!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	^ (Character asciiValue: (self first asciiValue + 13)) asString .! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 17:53:08'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:53:08'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 17:53:08'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 17:54:13'!
test04

	self assert: 'n' equals: 'a' asRot13.! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 17:54:18'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 17:54:18'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 17:54:18'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 17:54:18'!
PASSED!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:57:23' prior: 50947042!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ]
			ifFalse: [ ^'a' ].! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:57:32' prior: 50947068!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ]
		       ifFalse: [ ^'a' ].! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 17:57:41' prior: 50947076!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	self < 'n'  ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ]
		       ifFalse: [ ^'a' ].! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:01:01' prior: 50947084!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	
	self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ].
	
	self = 'n' ifTrue: [ ^'a' ].
	
	self = 'o' ifTrue: [ ^ 'b' ].
		       ! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:01:06'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:01:06'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:01:06'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:01:06'!
PASSED!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:04:19' prior: 50947092!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	
	self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ].
	
	^ (Character asciiValue: (self first asciiValue - 13)) asString .
		       ! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:04:25'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:04:25'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:04:25'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:04:25'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 18:07:09'!
test05

	self assert: 'b' equals: 'o' asRot13.! !
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 18:07:24'!
test06

	self assert: 'ubyn' equals: 'hola' asRot13.! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:07:27'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:07:28'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:07:28'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:07:28'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:07:28'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:07:28'!
FAILURE!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:07:28'!
FAILURE!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:08:28' prior: 50947110!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	
	self size = 1 & self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ].
	
	^ (Character asciiValue: (self first asciiValue - 13)) asString .
		       ! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:09:31' prior: 50947153!
asRot13
	
	self isEmpty ifTrue: [ ^self ] .
	
	self size = 1 
		ifTrue: [
			self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ].
	
	^ (Character asciiValue: (self first asciiValue - 13)) asString .
		]
	 	ifFalse: [
			^ 'ubyn']
		       ! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:10:00' prior: 50947163!
asRot13
	self isEmpty ifTrue: [ ^self ] .
	self size = 1 
		ifTrue: [
			self < 'n' ifTrue: [^ (Character asciiValue: (self first asciiValue + 13)) asString ].
			^ (Character asciiValue: (self first asciiValue - 13)) asString .
		]
	 	ifFalse: [^ 'ubyn']
		       ! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:10:07'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:10:07'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:10:07'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:10:07'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:10:07'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:10:07'!
PASSED!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:19:21' prior: 50947175!
asRot13
	| auxString |
	self isEmpty ifTrue: [^self].
	auxString _ ''.
	self do: [ :aCharacter |
		aCharacter < $n ifTrue: [
			auxString _ auxString, ((Character asciiValue: (self first asciiValue + 13)) asString)
		]
		ifFalse: [
			auxString _ auxString, ((Character asciiValue: (self first asciiValue - 13)) asString)
		] 
	].

	^ auxString .
		       ! !
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 18:19:36' prior: 50947016!
test03
	
	self assert: 'o' equals: 'b' asRot13 .
! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:19:41'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:19:41'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:19:41'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:19:41'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:19:41'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:19:41'!
FAILURE!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:19:41'!
FAILURE!
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:23:42' prior: 50947200!
asRot13
	
	^ self collect: [ :aCharacter | 
		aCharacter < $n
			ifTrue: [ Character asciiValue: (aCharacter asciiValue + 13)] 
			ifFalse: [Character asciiValue: (aCharacter asciiValue - 13)] ].! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:23:48'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:23:48'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:23:48'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:23:48'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:23:48'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:23:48'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 18:34:38'!
test07

	self assert: 'UBYN' equals: 'HOLA' asRot13.! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:36:00' prior: 50947235!
asRot13
	
	^ self collect: [ :aCharacter | 
		aCharacter asLowercase < $n
			ifTrue: [ Character asciiValue: (aCharacter asciiValue + 13)] 
			ifFalse: [Character asciiValue: (aCharacter asciiValue - 13)] ].! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!

!testRun: #Rot13Test #test07 stamp: 'eb 10/22/2020 18:36:04'!
PASSED!
!Character methodsFor: 'nil' stamp: 'eb 10/22/2020 18:38:47'!
asRot13
	! !
!Character methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:40:11' prior: 50947287!
asRot13
	
	^self asLowercase < $n
			ifTrue: [ self class asciiValue: (self asciiValue + 13)] 
			ifFalse: [self class asciiValue: (self asciiValue - 13)] .! !
!String methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:40:39' prior: 50947262!
asRot13
	
	^ self collect: [ :aCharacter | aCharacter asRot13 ].! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:40:44'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:40:44'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:40:44'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:40:44'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:40:44'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:40:45'!
PASSED!

!testRun: #Rot13Test #test07 stamp: 'eb 10/22/2020 18:40:45'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 18:49:07'!
test08

	self assert: 'U&%N' equals: 'H&%A' asRot13.! !
!Character methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:51:12' prior: 50947290!
asRot13
	
	^ (self asLowercase <= $z and: self asLowercase >= $a) 
		ifTrue:  [
			self asLowercase < $n
				ifTrue: [ self class asciiValue: (self asciiValue + 13)] 
				ifFalse: [self class asciiValue: (self asciiValue - 13)] .
		]
		ifFalse: [ self ] .
	
	
	! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test07 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!

!testRun: #Rot13Test #test08 stamp: 'eb 10/22/2020 18:51:19'!
PASSED!
!Character methodsFor: '*Rot13' stamp: 'eb 10/22/2020 18:58:59' prior: 50947324!
asRot13
	
	^ (self asLowercase asciiValue <= $z asciiValue and: 
	     self asLowercase asciiValue >= $a asciiValue) 
		ifTrue:  [
			self asLowercase < $n
				ifTrue: [ self class asciiValue: (self asciiValue + 13)] 
				ifFalse: [self class asciiValue: (self asciiValue - 13)] .
		]
		ifFalse: [ self ] .
	
	
	! !
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 18:59:21'!
test09

	self assert: '' equals: '' asRot13.! !

!testRun: #Rot13Test #test09 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test07 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test08 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!

!testRun: #Rot13Test #test09 stamp: 'eb 10/22/2020 18:59:22'!
PASSED!
!Character methodsFor: '*Rot13' stamp: 'eb 10/22/2020 19:05:05' prior: 50947353!
asRot13

	| selfAsLowercaseAsciiValue |
	
	selfAsLowercaseAsciiValue _ self asLowercase asciiValue .
	
	^ (self asLowercase asciiValue <= $z asciiValue and: 
	     self asLowercase asciiValue >= $a asciiValue) 
		ifTrue:  [
			self asLowercase < $n
				ifTrue: [ self class asciiValue: (self asciiValue + 13)] 
				ifFalse: [self class asciiValue: (self asciiValue - 13)] .
		]
		ifFalse: [ self ] .
	
	
	! !
!Character methodsFor: '*Rot13' stamp: 'eb 10/22/2020 19:06:25' prior: 50947393!
asRot13

	| selfAsLowercaseAsciiValue |
	
	selfAsLowercaseAsciiValue _ self asLowercase asciiValue .
	
	^ (selfAsLowercaseAsciiValue between: `$a asciiValue` and: `$z asciiValue`)
		ifTrue:  [
			selfAsLowercaseAsciiValue < `$n asciiValue`
				ifTrue: [ self class asciiValue: (self asciiValue + 13)] 
				ifFalse: [self class asciiValue: (self asciiValue - 13)] .
		]
		ifFalse: [ self ] .
	
	
	! !

!testRun: #Rot13Test #test01 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test02 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test03 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test04 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test05 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test06 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test07 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test08 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!

!testRun: #Rot13Test #test09 stamp: 'eb 10/22/2020 19:06:30'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45'!
test01EmptyStringIsNotConverted

	self assert: '' equals: '' asRot13.! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50823287!
test15WhenTheTestIsRemovedThenIsInGreen
	| result |

	self logChangesWhile: [ 	
		self newClassNamed: #TestSomethingA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true' in: #TestSomethingA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestSomethingA.
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Green.
	self assertHasNoErrors: result.
! !
!OtherTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50822100!
test06WhenATestHasAnErrorThisTestDoesNotFail
	| result changes |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 ^ self error: ''An error''' in: #TestClassA.
	
	self logChangesWhile: [ 
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA
	].
		
	result _ tddGuru run.
	changes := result changes.
	self assert: changes size equals: 1.
	self assert: changes first category equals: #testRun.
	self assert: changes first testSelector equals: #test01EmptyStringIsNotConverted.
	! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50823407!
test21WhenAModelMethodIsAddedBeforeRunningTestsThenIsNotDoingTDD
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object.
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: #test01EmptyStringIsNotConverted in: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass ].
		
	result _ tddGuru run.
		
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru modelMethodAddedBeforeRunningTests: #m1 class: #ModelClass).
	self assert: tddGuru currentState equals: NotDoingTDD.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50821462!
test14WhenOneOfTheTestsPassesTwoErrorsAreReported
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: MoreThanOneTestWritten.
	self assert: result hasNErrors: 2.
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test01EmptyStringIsNotConverted class: #TestClassA).
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02 class: #TestClassA)! !
!OtherTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50822118!
test07RunFromASpecificChange
	| result changes |
	
	self logChangesWhile: [ 
		self newClassNamed: #ExampleClass subclassOf: Object.
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 ^ self error: ''An error''' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA
	].
		
	tddGuru startingFromChange: 2.
	result _ tddGuru run.
	changes := result changes.
	self assert: changes size equals: 3.

	! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50822305!
test07WhenAllTestsPassThenIsInGreen
	| result |
	self newClassNamed: #ModelClass subclassOf: Object.
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: (ModelClass new m2) equals: 2.' in: #TestSomething.
		self runTest: #test02 class: #TestSomething.
		self compileMethod: 'm1 ^ 2' in: #ModelClass.
		self compileMethod: 'm2 ^ 2' in: #ModelClass.
		self runAllTestsOf: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runAllTestsOf: #TestSomething ].

	result _ tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: Green.! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50822385!
test10WhenAModelMethodIsRemovedIsStillInRed
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object. 
	self compileMethod: 'm1 ^ 1.' in: #ModelClass.
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self removeMethodWithSelector: #m1 from: #ModelClass ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Red.
	self assertHasNoErrors: result.! !
!OtherTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50822151!
test09ReRunFromASpecificChange
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #ModelClassA subclassOf: Object.
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA
	].
		
	tddGuru startingFromChange: 2.
	tddGuru run.
	
	self logChangesWhile: [ 
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
	].

	result _ tddGuru rerun.
	self assert: result changes size equals: 4.

	! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50823181!
test11WhenATestWithTheSameNameIsChangedInOtherClassThenIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestSomethingA subclassOf: TestCase.
	self newClassNamed: #TestSomethingB subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestSomethingA.
	self compileMethod: 'test01 self assert: true' in: #TestSomethingB.
	
	tddGuru initialTestClasses: { self classNamed: #TestSomethingA. self classNamed: #TestSomethingB }.
	tddGuru initialState: (WritingAFailingTest currentTest: (UninstalledMethodReference selector: #test01EmptyStringIsNotConverted class: #TestSomethingA)).
	
	self logChangesWhile: [ 	
		self compileMethod: 'test01 self assert: false' in: #TestSomethingB.
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasErrorWithDescription: (TDDGuru testChangedWhileThisTestWasBeingWritten:  #test01EmptyStringIsNotConverted in: #TestSomethingB)! !
!RefactorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:45' prior: 50822722!
test13WhenATestIsRemovedIsNoLongerTakenIntoAccount
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClassA.
	self compileMethod: 'test02 self assert: true' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	
	tddGuru initialState: Refactor new.
	
	self logChangesWhile: [ 
		self removeMethodWithSelector: #test02 from: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Green.! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823057!
test04WhenATestFailsThenIsInRedState
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!GreenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821094!
test11WhenATestFailsAnErrorIsReportedAndTransitionsToRed
	| result |
	
	self newClassNamed: #TestClass subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClass.
	tddGuru initialState: Green new.
	tddGuru initialTestClasses: { self classNamed: #TestClass }.
	
	self logChangesWhile: [ self runTest: #test01EmptyStringIsNotConverted class: #TestClass ].
		
	result _ tddGuru run.
		
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testUnexpectedlyFailedErrorMessage: #test01EmptyStringIsNotConverted class: #TestClass).
	self assert: tddGuru currentState equals: Red.! !
!NotStartedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821970!
test12WhenATestIsChangedThenIsWritingAFailingTest
	| result |
	
	self newClassNamed: #TestSomething subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestSomething.
	
	tddGuru initialTestClasses: { self classNamed: #TestSomething}.
	
	self logChangesWhile: [ self compileMethod: 'test01 self assert: false' in: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: WritingAFailingTest.
	self assert: tddGuru currentState currentTest selector equals: #test01EmptyStringIsNotConverted.! !
!RefactorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822579!
test05WhenATestIsRenamedIsStillRefactoring
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClassA.
	tddGuru initialState: Refactor new.
	tddGuru initialTestClasses: { self classNamed: #TestClassA}.
	
	self logChangesWhile: [  
		self compileMethod: 'test01A self assert: true' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestClassA ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Refactor.! !
!GreenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821074!
test10WhenATestIsRenamedThenIsRefactoring
	| result |
	
	self newClassNamed: #TestClass subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClass.
	tddGuru initialState: Green new.
	tddGuru initialTestClasses: { self classNamed: #TestClass }.
	
	self logChangesWhile: [ 
		self compileMethod: 'test01A self assert: true' in: #TestClass.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestClass ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Refactor.! !
!NotStartedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821990!
test13WhenATestIsRenamedThenIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestSomething subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestSomething.
	
	tddGuru initialTestClasses: { self classNamed: #TestSomething}.
	
	self logChangesWhile: [ 
		self compileMethod: 'test01A self assert: false' in: #TestSomething. 
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestSomething ].
		
	result _ tddGuru run.
		
	self assert: tddGuru currentState equals: NotDoingTDD.
	self assert: result hasErrorWithDescription: (TDDGuru testRenamedBeforeRunningTheTests: #test01EmptyStringIsNotConverted class: #TestSomething)! !
!OtherTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822134!
test08ReRunTheWholeAnalysis
	| result changes |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA
	].
		
	result _ tddGuru run.
	
	self logChangesWhile: [ 
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
	].

	result _ tddGuru rerun.
	changes := result changes.
	self assert: changes size equals: 4.

	! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822240!
test04WhenTheTestFailsIsStillInRed
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ModelClass subclassOf: Object. 
		self compileMethod: 'm1 ^ 2' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822204!
test02WhenAProductionMethodIsAddedIsStillInRed
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ModelClass subclassOf: Object. 
		self compileMethod: 'm1 ^ 1' in: #ModelClass ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822335!
test08WhenATestIsAddedIsNotDoingTDD
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: false.' in: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assert: tddGuru currentState equals: NotDoingTDD.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedErrorMessage: #test02 class: #TestSomething).! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822404!
test11WhenAModelClassIsRemovedIsStillInRed
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object. 
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self removeClass: #ModelClass ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Red.
	self assertHasNoErrors: result.! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823211!
test12WhenADifferentTestIsChangedThenIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestSomethingA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestSomethingA.
	self compileMethod: 'test02 self assert: false' in: #TestSomethingA.
	tddGuru initialState: (WritingAFailingTest currentTest: (UninstalledMethodReference selector: #test02 class: #TestSomethingA)).
	tddGuru initialTestClasses: { self classNamed: #TestSomethingA}.
	
	self logChangesWhile: [ 	
		self compileMethod: 'test01 self assert: true' in: #TestSomethingA.
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testChangedWhileThisTestWasBeingWritten: #test01EmptyStringIsNotConverted in: #TestSomethingA)
	! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823391!
test20WhenAFirstTestIsAddedIsStillWritingAFailingTest
	| result |
	
	
	self logChangesWhile: [ 
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true.' in: #TestClassA. ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assertCurrentStateIs: WritingAFailingTest.
	self assert: tddGuru currentState currentTest selector equals: #test01EmptyStringIsNotConverted.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821486!
test15WhenAllOfTheTestsPassErrorsAreReportedAndGoesToGreen
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self runAllTestsOf: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: Green.
	self assert: result hasNErrors: 3.
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test01EmptyStringIsNotConverted class: #TestClassA).
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test02 class: #TestClassA).
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02 class: #TestClassA)! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822278!
test06WhenTheNewTestPassesButAnotherTestFailsThenIsStillInRed
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ModelClass subclassOf: Object. 
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: (ModelClass new m1) equals: 2.' in: #TestSomething.
		self runTest: #test02 class: #TestSomething.
		self compileMethod: 'm1 ^ 2' in: #ModelClass.
		self runAllTestsOf: #TestSomething ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823344!
test18WhenTheTestPassesAnErrorIsReportedAndGoesToGreen
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething ].
		
	result _ tddGuru run.
		
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test01EmptyStringIsNotConverted class: #TestSomething).
	self assert: tddGuru currentState equals: Green.! !
!GreenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821022!
test07WhenATestPassesNothingHappens
	| result |
	
	self newClassNamed: #TestClass subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClass.
	tddGuru initialState: Green new.
	tddGuru initialTestClasses: { self classNamed: #TestClass }.
	
	self logChangesWhile: [ self runTest: #test01EmptyStringIsNotConverted class: #TestClass ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Green.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821531!
test17WhenAnotherTestIsRenamedIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	
	self logChangesWhile: [
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self compileMethod: 'test03 self assert: true' in: #TestClassA.
		self compileMethod: 'test01bla self assert: true' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test03 class: #TestClassA)! !
!OtherTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822020!
test02ResultKnowsTheChangesThatWereDone
	| result changes |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestClass subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestClass. 
		self runTest: #test01EmptyStringIsNotConverted class: #TestClass.
	].
		
	result _ tddGuru run.
	
	changes := result changes.
	self assert: changes size equals: 3.
	self assert: changes first category equals: #newTestClass.
	self assert: changes second category equals: #newTest.
	self assert: changes third category equals: #testRun.! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822354!
test09WhenATestIsRenamedAndAllTestsPassThenIsInGreen
	| result |
	self newClassNamed: #ModelClass subclassOf: Object.
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: (ModelClass new m2) equals: 2.' in: #TestSomething.
		self runTest: #test02 class: #TestSomething.
		self compileMethod: 'test02A self assert: (ModelClass new m2) equals: 2.' in: #TestSomething.
		self removeMethodWithSelector: #test02 from: #TestSomething.
		self compileMethod: 'm2 ^ 2' in: #ModelClass.
		self runAllTestsOf: #TestSomething ].

	result _ tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: Green.! !
!OtherTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822039!
test03TDDStateForEachChange
	| result firstChange secondChange thirdChange changes |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestClass subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClass
	].
		
	result _ tddGuru run.
		
	changes := result changes.
	firstChange := changes first.
	secondChange := changes second.
	thirdChange := changes third.
	
	self assert: (result stateAfter: firstChange) equals: WritingAFailingTest .
	self assert: (result stateAfter: secondChange) equals: WritingAFailingTest .
	self assert: (result stateAfter: thirdChange) equals: Red .! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822188!
test01WhenAProductionClassIsAddedIsStillInRed
	| result  |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ProductionClass subclassOf: Object ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821225!
test03WhenTheFirstOfTheTestsIsRemovedIsBackToWritingAFailingTest
	| result |

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from:  #TestClassA.
	].

	result := tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: WritingAFailingTest.
	self assert: tddGuru currentState currentTest selector equals: #test02
	! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822221!
test03WhenTheTestPassesThenIsInGreen
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ModelClass subclassOf: Object. 
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Green.! !
!NotDoingTDDTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821691!
test10WhenOneOfTheTestIsNotRunThenIsStillNotDoingTDD
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 ^ self assert: true' in: #TestClassA.
	self compileMethod: 'test02 ^ self assert: true' in: #TestClassA.

	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	tddGuru initialState: NotDoingTDD new.
	
	self logChangesWhile: [ self runTest: #test01EmptyStringIsNotConverted class: #TestClassA ].
	
	tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD ! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822420!
test11WhenATestClassIsAddedIsStillInRed
	| result |
		
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #TestSomethingB subclassOf: TestCase. ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Red.
	self assertHasNoErrors: result.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821245!
test04WhenAnotherTestIsRemovedIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.

	self logChangesWhile: [
		self newClassNamed: #TestClassB subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassB.
		self compileMethod: 'test02 self assert: false' in: #TestClassB.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from:  #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1. 
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother:  #test02 class: #TestClassB).! !
!RefactorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822969!
test23WhenATestClassIsRenamedThoseTestsAreStillTakenIntoAccount
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: ModelClassA new m1 equals: 1' in: #TestClassA.
		self runAllTestsOf: #TestClassA.
		self newClassNamed: #ModelClassA subclassOf: Object.
		self compileMethod: 'm1 ^ 1' in: #ModelClassA.
		self runAllTestsOf: #TestClassA.
		self renameClass: #TestClassA to: #TestClassB.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassB
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Green.
	self assertHasNoErrors: result ! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822259!
test05WhenAProductionMethodIsChangedIsStillInRed
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ModelClass subclassOf: Object. 
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self compileMethod: 'm1 ^ 2' in: #ModelClass ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821442!
test13WhenATestFailsAnErrorIsReportedAndGoesToRed
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: Red.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02 class: #TestClassA)! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821205!
test02WhenTheLastOfTheTestsIsRemovedIsBackToWritingAFailingTest
	| result |

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self removeMethodWithSelector: #test02 from:  #TestClassA.
	].

	result := tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: WritingAFailingTest.
	self assert: tddGuru currentState currentTest selector equals: #test01EmptyStringIsNotConverted
	! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822436!
test12WhenTheTestIsChangedIsStillInRed
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object. 
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test01 self assert: true.' in: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Red.
	self assertHasNoErrors: result.! !
!NotDoingTDDTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821709!
test11WhenATestIsRenamedIsStillNotDoingTDD
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClassA.
	tddGuru initialState: NotDoingTDD new.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	
	self logChangesWhile: [ 
		self compileMethod: 'test01bla self assert: false' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestClassA ].
	
	tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD ! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50822474!
test14WhenATestIsRemovedResultShouldHaveAnErrorAndIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestSomething subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true.' in: #TestSomething.
	tddGuru initialTestClasses: { self classNamed: #TestSomething }.
		
	self logChangesWhile: [ 
		self compileMethod: 'test02 self assert: false.' in: #TestSomething. 
		self runTest: #test02 class: #TestSomething.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasErrorWithDescription: (TDDGuru testRemovedWhileInRed: #test01EmptyStringIsNotConverted class: #TestSomething)! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823362!
test19AnotherTestIsRemovedAnErrorIsReportedAndIsStillWritingAFailingTest
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self newClassNamed: #TestClassB subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true.' in: #TestClassA.
	self compileMethod: 'test01 self assert: true.' in: #TestClassB.
	tddGuru initialTestClasses: { self classNamed: #TestClassA . self classNamed: #TestClassB }.
	
	self logChangesWhile: [ 
		self compileMethod: 'test02 self assert: false.' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestClassB ].
		
	result _ tddGuru run.
		
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru methodRemovedWhileWritingATest: #test01EmptyStringIsNotConverted class: #TestClassB).
	self assert: tddGuru currentState equals: WritingAFailingTest.! !
!NotDoingTDDTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821659!
test08WhenThereIsOneTestAndPassesThenIsInGreen
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA}.
	tddGuru initialState: (NotDoingTDD new).
	
	self logChangesWhile: [ self runTest: #test01EmptyStringIsNotConverted class: #TestClassA ].
	
	tddGuru run.
	
	self assertCurrentStateIs: Green ! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823239!
test13WhenATestWithTheSameNameIsAddedInOtherClassThenIsInMoreThanOneTestWritten
	| result |
	
	self newClassNamed: #TestSomethingA subclassOf: TestCase.
	self newClassNamed: #TestSomethingB subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestSomethingA.
	
	tddGuru initialTestClasses: { self classNamed: #TestSomethingA. self classNamed: #TestSomethingB }.
	tddGuru initialState: (WritingAFailingTest currentTest: (UninstalledMethodReference selector: #test01EmptyStringIsNotConverted class: #TestSomethingA)).
	
	self logChangesWhile: [ 	
		self compileMethod: 'test01 self assert: false' in: #TestSomethingB.
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: MoreThanOneTestWritten .
	self assertHasNoErrors: result.
! !
!GreenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50821053!
test09WhenATestHasAnErrorAnErrorIsReportedAndTransitionsToRed
	| result |
	
	self newClassNamed: #TestClass subclassOf: TestCase.
	self compileMethod: 'test01 self error' in: #TestClass. 
	tddGuru initialState: Green new.
	tddGuru initialTestClasses: { self classNamed: #TestClass }.
	
	self logChangesWhile: [ self runTest: #test01EmptyStringIsNotConverted class: #TestClass ].
		
	result _ tddGuru run.
		
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testUnexpectedlyFailedErrorMessage: #test01EmptyStringIsNotConverted class: #TestClass).
	self assert: tddGuru currentState equals: Red.
	! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:07:46' prior: 50823302!
test16WhenATestIsRenamedThenIsStillWritingAFailingTest
	| result |
	
	self newClassNamed: #TestSomethingA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestSomethingA.
	tddGuru initialTestClasses: { self classNamed: #TestSomethingA }.

	self logChangesWhile: [ 	
		self compileMethod: 'test02 self assert: false' in: #TestSomethingA.
		self compileMethod: 'test01A self assert: true' in: #TestSomethingA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestSomethingA.
		self compileMethod: 'test02 self assert: false' in: #TestSomethingA.
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: WritingAFailingTest.
	self assertHasNoErrors: result.
! !

!methodRemoval: Rot13Test #test01 stamp: 'eb 10/22/2020 19:07:46'!
test01

	self assert: '' equals: '' asRot13.!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18'!
test02CharacersInFirstalfAreConvertedCorrectly
	
	self assert: 'n' equals: 'a' asRot13 .! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821317!
test07WhenAModelClassIsAddedIsNotDoingTDD
	| result |

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self newClassNamed: #ModelClass subclassOf: Object.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1. 
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA).
	! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821359!
test09WhenATestIsAddedIsNotDoingTDD
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self compileMethod: 'test03 self assert: false' in: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA)! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947868!
test08WhenATestIsAddedIsNotDoingTDD
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: false.' in: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assert: tddGuru currentState equals: NotDoingTDD.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedErrorMessage: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomething).! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821271!
test05WhenAMethodIsRemovedIsNotDoingTDD
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object.
	self compileMethod: 'm1 ^ 1' in: #ModelClass.

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self removeMethodWithSelector: #m1 from:  #ModelClass.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1. 
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA).! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50948331!
test13WhenATestFailsAnErrorIsReportedAndGoesToRed
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: Red.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA)! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50948353!
test02WhenTheLastOfTheTestsIsRemovedIsBackToWritingAFailingTest
	| result |

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self removeMethodWithSelector: #test02CharacersInFirstalfAreConvertedCorrectly from:  #TestClassA.
	].

	result := tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: WritingAFailingTest.
	self assert: tddGuru currentState currentTest selector equals: #test01EmptyStringIsNotConverted
	! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947956!
test15WhenAllOfTheTestsPassErrorsAreReportedAndGoesToGreen
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self runAllTestsOf: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: Green.
	self assert: result hasNErrors: 3.
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test01EmptyStringIsNotConverted class: #TestClassA).
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA).
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA)! !
!WritingAFailingTestTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947908!
test12WhenADifferentTestIsChangedThenIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestSomethingA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestSomethingA.
	self compileMethod: 'test02 self assert: false' in: #TestSomethingA.
	tddGuru initialState: (WritingAFailingTest currentTest: (UninstalledMethodReference selector: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomethingA)).
	tddGuru initialTestClasses: { self classNamed: #TestSomethingA}.
	
	self logChangesWhile: [ 	
		self compileMethod: 'test01 self assert: true' in: #TestSomethingA.
	].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testChangedWhileThisTestWasBeingWritten: #test01EmptyStringIsNotConverted in: #TestSomethingA)
	! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821337!
test08WhenAModelMethodIsAddedIsNotDoingTDD
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object.

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self compileMethod: 'm1 ^ 1' in: #ModelClass	
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA)
	! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50948101!
test09WhenATestIsRenamedAndAllTestsPassThenIsInGreen
	| result |
	self newClassNamed: #ModelClass subclassOf: Object.
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: (ModelClass new m2) equals: 2.' in: #TestSomething.
		self runTest: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomething.
		self compileMethod: 'test02A self assert: (ModelClass new m2) equals: 2.' in: #TestSomething.
		self removeMethodWithSelector: #test02CharacersInFirstalfAreConvertedCorrectly from: #TestSomething.
		self compileMethod: 'm2 ^ 2' in: #ModelClass.
		self runAllTestsOf: #TestSomething ].

	result _ tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: Green.! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947551!
test07WhenAllTestsPassThenIsInGreen
	| result |
	self newClassNamed: #ModelClass subclassOf: Object.
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: (ModelClass new m2) equals: 2.' in: #TestSomething.
		self runTest: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomething.
		self compileMethod: 'm1 ^ 2' in: #ModelClass.
		self compileMethod: 'm2 ^ 2' in: #ModelClass.
		self runAllTestsOf: #TestSomething.
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runAllTestsOf: #TestSomething ].

	result _ tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: Green.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50948258!
test04WhenAnotherTestIsRemovedIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.

	self logChangesWhile: [
		self newClassNamed: #TestClassB subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassB.
		self compileMethod: 'test02 self assert: false' in: #TestClassB.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from:  #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1. 
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother:  #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassB).! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50822454!
test13WhenAnotherTestIsChangedIsStillInRed
	| result |
	
	self newClassNamed: #TestSomething subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true.' in: #TestSomething.
	tddGuru initialTestClasses: { self classNamed: #TestSomething }.
		
	self logChangesWhile: [ 
		self compileMethod: 'test02 self assert: false.' in: #TestSomething. 
		self runTest: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomething.
		self compileMethod: 'test01 self assert: true.' in: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: Red.
	self assertHasNoErrors: result.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821379!
test10WhenATestClassIsAddedIsNotDoingTDD
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self newClassNamed: #TestClassB subclassOf: TestCase.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA)! !
!GreenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821115!
test12WhenATestIsRemovedThenIsRefactoring
	| result |
	
	self newClassNamed: #TestClass subclassOf: TestCase.
	self compileMethod: 'test01 self assert: false' in: #TestClass.
	self compileMethod: 'test02 self assert: false' in: #TestClass.
	tddGuru initialState: Green new.
	tddGuru initialTestClasses: { self classNamed: #TestClass }.
	
	self logChangesWhile: [ self removeMethodWithSelector: #test02CharacersInFirstalfAreConvertedCorrectly from: #TestClass ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Refactor.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821294!
test06WhenAModelMethodIsChangedIsNotDoingTDD
	| result |
	
	self newClassNamed: #ModelClass subclassOf: Object.
	self compileMethod: 'm1 ^ 1' in: #ModelClass.

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self compileMethod: 'm1 ^ 2' in: #ModelClass.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1. 
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA).! !
!NotDoingTDDTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821744!
test13WhenATestIsRemovedIsNoLongerTakenIntoAccount
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClassA.
	self compileMethod: 'test02 self assert: false' in: #TestClassA.
	tddGuru initialState: NotDoingTDD new.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	
	self logChangesWhile: [ 
		self removeMethodWithSelector: #test02CharacersInFirstalfAreConvertedCorrectly from: #TestClassA.
		self runAllTestsOf: #TestClassA ].
	
	tddGuru run.
	
	self assertCurrentStateIs: Green ! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821512!
test16WhenOneOfTheTestsIsRenamedIsStillInThisState
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self compileMethod: 'test02bla self assert: true' in: #TestClassA.
		self removeMethodWithSelector: #test02CharacersInFirstalfAreConvertedCorrectly from: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: MoreThanOneTestWritten.
	self assertHasNoErrors: result.! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947983!
test06WhenTheNewTestPassesButAnotherTestFailsThenIsStillInRed
	| result |
	
	self logChangesWhile: [ 
		self newClassNamed: #TestSomething subclassOf: TestCase.
		self compileMethod: 'test01 self assert: (ModelClass new m1) equals: 1.' in: #TestSomething.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self newClassNamed: #ModelClass subclassOf: Object. 
		self compileMethod: 'm1 ^ 1' in: #ModelClass.
		self runTest: #test01EmptyStringIsNotConverted class: #TestSomething.
		self compileMethod: 'test02 self assert: (ModelClass new m1) equals: 2.' in: #TestSomething.
		self runTest: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomething.
		self compileMethod: 'm1 ^ 2' in: #ModelClass.
		self runAllTestsOf: #TestSomething ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Red.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50821184!
test01WhenAClassIsRemovedIsNotDoingTDD
	| result |	
	
	self newClassNamed: #Something subclassOf: Object.

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self removeClass: #Something.
	].

	result := tddGuru run.
	
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA).
	self assertCurrentStateIs: NotDoingTDD.
	! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50948178!
test03WhenTheFirstOfTheTestsIsRemovedIsBackToWritingAFailingTest
	| result |

	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from:  #TestClassA.
	].

	result := tddGuru run.
	
	self assertHasNoErrors: result.
	self assertCurrentStateIs: WritingAFailingTest.
	self assert: tddGuru currentState currentTest selector equals: #test02CharacersInFirstalfAreConvertedCorrectly
	! !
!RefactorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947657!
test13WhenATestIsRemovedIsNoLongerTakenIntoAccount
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClassA.
	self compileMethod: 'test02 self assert: true' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	
	tddGuru initialState: Refactor new.
	
	self logChangesWhile: [ 
		self removeMethodWithSelector: #test02CharacersInFirstalfAreConvertedCorrectly from: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA ].
		
	result _ tddGuru run.
		
	self assertHasNoErrors: result.
	self assert: tddGuru currentState equals: Green.! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50947508!
test14WhenOneOfTheTestsPassesTwoErrorsAreReported
	| result |
	
	self logChangesWhile: [
		self newClassNamed: #TestClassA subclassOf: TestCase.
		self compileMethod: 'test01 self assert: true' in: #TestClassA.
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self runTest: #test01EmptyStringIsNotConverted class: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: MoreThanOneTestWritten.
	self assert: result hasNErrors: 2.
	self assert: result hasErrorWithDescription: (TDDGuru testDidNotFail: #test01EmptyStringIsNotConverted class: #TestClassA).
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestClassA)! !
!RedTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:18' prior: 50948412!
test14WhenATestIsRemovedResultShouldHaveAnErrorAndIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestSomething subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true.' in: #TestSomething.
	tddGuru initialTestClasses: { self classNamed: #TestSomething }.
		
	self logChangesWhile: [ 
		self compileMethod: 'test02 self assert: false.' in: #TestSomething. 
		self runTest: #test02CharacersInFirstalfAreConvertedCorrectly class: #TestSomething.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestSomething. ].
		
	result _ tddGuru run.
		
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasErrorWithDescription: (TDDGuru testRemovedWhileInRed: #test01EmptyStringIsNotConverted class: #TestSomething)! !

!methodRemoval: Rot13Test #test02 stamp: 'eb 10/22/2020 19:08:18'!
test02
	
	self assert: 'n' equals: 'a' asRot13 .!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:41'!
test03CharactersInSecondHalfAreConvertedCorrectly
	
	self assert: 'o' equals: 'b' asRot13 .
! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:41' prior: 50821417!
test12WhenAnotherTestIsChangedIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	self compileMethod: 'test01 self assert: false' in: #TestClassA.
	
	self logChangesWhile: [
		self compileMethod: 'test02 self assert: false' in: #TestClassA.
		self compileMethod: 'test03 self assert: false' in: #TestClassA.
		self compileMethod: 'test01 self assert: false' in: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test03CharactersInSecondHalfAreConvertedCorrectly class: #TestClassA)! !
!MoreThanOneTestWrittenTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:08:41' prior: 50948052!
test17WhenAnotherTestIsRenamedIsNotDoingTDD
	| result |
	
	self newClassNamed: #TestClassA subclassOf: TestCase.
	self compileMethod: 'test01 self assert: true' in: #TestClassA.
	tddGuru initialTestClasses: { self classNamed: #TestClassA }.
	
	self logChangesWhile: [
		self compileMethod: 'test02 self assert: true' in: #TestClassA.
		self compileMethod: 'test03 self assert: true' in: #TestClassA.
		self compileMethod: 'test01bla self assert: true' in: #TestClassA.
		self removeMethodWithSelector: #test01EmptyStringIsNotConverted from: #TestClassA.
	].

	result := tddGuru run.
	
	self assertCurrentStateIs: NotDoingTDD.
	self assert: result hasNErrors: 1.
	self assert: result hasErrorWithDescription: (TDDGuru testAddedWhileWritingAnother: #test03CharactersInSecondHalfAreConvertedCorrectly class: #TestClassA)! !

!methodRemoval: Rot13Test #test03 stamp: 'eb 10/22/2020 19:08:41'!
test03
	
	self assert: 'o' equals: 'b' asRot13 .
!

!methodRemoval: Rot13Test #test04 stamp: 'eb 10/22/2020 19:08:48'!
test04

	self assert: 'n' equals: 'a' asRot13.!

!methodRemoval: Rot13Test #test05 stamp: 'eb 10/22/2020 19:08:49'!
test05

	self assert: 'b' equals: 'o' asRot13.!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:09:02'!
test06WordsGetConvertedCorrectly

	self assert: 'ubyn' equals: 'hola' asRot13.! !

!methodRemoval: Rot13Test #test06 stamp: 'eb 10/22/2020 19:09:02'!
test06

	self assert: 'ubyn' equals: 'hola' asRot13.!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:09:21'!
test07UppercaseCharactersAreConvertedCorrectyle

	self assert: 'UBYN' equals: 'HOLA' asRot13.! !

!methodRemoval: Rot13Test #test07 stamp: 'eb 10/22/2020 19:09:21'!
test07

	self assert: 'UBYN' equals: 'HOLA' asRot13.!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:09:29'!
test07UppercaseCharactersAreConvertedCorrectly

	self assert: 'UBYN' equals: 'HOLA' asRot13.! !

!methodRemoval: Rot13Test #test07UppercaseCharactersAreConvertedCorrectyle stamp: 'eb 10/22/2020 19:09:29'!
test07UppercaseCharactersAreConvertedCorrectyle

	self assert: 'UBYN' equals: 'HOLA' asRot13.!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:12:45'!
test08NonEnglishAlphabeticCharactersAreNotConverted

	self assert: 'U&%N' equals: 'H&%A' asRot13.! !

!methodRemoval: Rot13Test #test08 stamp: 'eb 10/22/2020 19:12:45'!
test08

	self assert: 'U&%N' equals: 'H&%A' asRot13.!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:15:20' prior: 50948566!
test02CharacersInFirstalfAreConvertedCorrectly
	
	self assert: 'n' equals: 'a' asRot13 .
	self assert: 'm' equals: 'z' asRot13 .! !

!testRun: #Rot13Test #test01EmptyStringIsNotConverted stamp: 'eb 10/22/2020 19:17:18'!
PASSED!

!testRun: #Rot13Test #test02CharacersInFirstalfAreConvertedCorrectly stamp: 'eb 10/22/2020 19:17:18'!
PASSED!

!testRun: #Rot13Test #test03CharactersInSecondHalfAreConvertedCorrectly stamp: 'eb 10/22/2020 19:17:18'!
PASSED!

!testRun: #Rot13Test #test06WordsGetConvertedCorrectly stamp: 'eb 10/22/2020 19:17:18'!
PASSED!

!testRun: #Rot13Test #test07UppercaseCharactersAreConvertedCorrectly stamp: 'eb 10/22/2020 19:17:18'!
PASSED!

!testRun: #Rot13Test #test08NonEnglishAlphabeticCharactersAreNotConverted stamp: 'eb 10/22/2020 19:17:18'!
PASSED!

!testRun: #Rot13Test #test09 stamp: 'eb 10/22/2020 19:17:18'!
PASSED!
!Rot13Test methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 19:17:46' prior: 50949294!
test08NonEnglishAlphabeticCharactersAreNotConverted

	self assert: '`{' equals: '`{' asRot13.! !

!testRun: #Rot13Test #test08NonEnglishAlphabeticCharactersAreNotConverted stamp: 'eb 10/22/2020 19:17:47'!
PASSED!

TestCase subclass: #GameOfLife
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLife category: #GameOfLife stamp: 'eb 10/22/2020 20:10:00'!
TestCase subclass: #GameOfLife
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

TestCase subclass: #GameOfLife
	instanceVariableNames: 'grid'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLife category: #GameOfLife stamp: 'eb 10/22/2020 20:12:39'!
TestCase subclass: #GameOfLife
	instanceVariableNames: 'grid'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLife methodsFor: 'no messages' stamp: 'eb 10/22/2020 20:12:47'!
test01
	! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:13:00' overrides: 16927572!
setUp

	grid _ Bag new .
	! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:13:03' prior: 50949369 overrides: 16927572!
setUp

	grid _ Set new .
	! !

!classDefinition: #Cell category: #GameOfLife stamp: 'eb 10/22/2020 20:14:17'!
Object subclass: #Cell
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:14:10' prior: 50949365!
test01
	
	| aCell |
	
	aCell _ Cell new .! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:14:42' prior: 50949385!
test01
	
	| aCell |
	
	aCell _ Cell new .
	
	grid add: aCell .
	
	! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:15:33' prior: 50949390!
test01
	
	| aCell |
	
	aCell _ Cell new .
	
	grid add: aCell .
	
	self assert: aCell state equals: #Died! !

!testRun: #GameOfLife #test01 stamp: 'eb 10/22/2020 20:15:40'!
ERROR!

!testRun: #GameOfLife #test01 stamp: 'eb 10/22/2020 20:15:40'!
ERROR!
!Cell methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:15:54'!
state
	self shouldBeImplemented.! !
!Cell methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:16:20' prior: 50949407!
state
	
	^ #Died! !
!Cell methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:16:20' prior: 50949411!
state
	
	^ #Died.! !

!testRun: #GameOfLife #test01 stamp: 'eb 10/22/2020 20:16:22'!
PASSED!

!classRenamed: #GameOfLife as: #GameOfLifeTest stamp: 'eb 10/22/2020 20:20:44'!
Smalltalk renameClassNamed: #GameOfLife as: #GameOfLifeTest!

Object subclass: #Grid
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #Grid category: #GameOfLife stamp: 'eb 10/22/2020 20:21:30'!
Object subclass: #Grid
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

Object subclass: #GameOfLife
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLife category: #GameOfLife stamp: 'eb 10/22/2020 20:21:58'!
Object subclass: #GameOfLife
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classRemoval: #Grid stamp: 'eb 10/22/2020 20:22:16'!
Object subclass: #Grid
	instanceVariableNames: 'cells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

TestCase subclass: #GameOfLifeTest
	instanceVariableNames: 'gameOfLife'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLifeTest category: #GameOfLife stamp: 'eb 10/22/2020 20:23:00'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: 'gameOfLife'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:23:17' prior: 50949374 overrides: 16927572!
setUp

	gameOfLife _ GameOfLife new .
	! !
!GameOfLife class methodsFor: 'nil' stamp: 'eb 10/22/2020 20:23:54'!
with: aCellCollection
	
	self new initializeWith: aCellCollection .! !
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 20:24:25'!
initializeWith: aCellCollection
	
	cells _ aCellCollection .! !
!Cell class methodsFor: 'nil' stamp: 'eb 10/22/2020 20:26:44'!
withState: aState atPosition: aPosition
	
	self new initializeWithState: aState atPosition: aPosition.! !

Object subclass: #Cell
	instanceVariableNames: 'state position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #Cell category: #GameOfLife stamp: 'eb 10/22/2020 20:27:14'!
Object subclass: #Cell
	instanceVariableNames: 'state position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!Cell methodsFor: 'nil' stamp: 'eb 10/22/2020 20:27:42'!
initializeWithState: aState atPosition: aPosition
	
	state _ aState .
	
	position  _ aPosition  .! !
!Cell methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:27:48' prior: 50949415!
state
	
	^ state.! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:30:41' prior: 50949465 overrides: 16927572!
setUp

	
	! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:31:13' prior: 50949396!
test01
	
	| aCell |
	
	aCell _ Cell new .
	
	gameOfLife _ GameOfLife with: #( aCell )
	
	grid add: aCell .
	
	self assert: aCell state equals: #Died! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:31:21' prior: 50949510!
test01
	
	| aCell |
	
	aCell _ Cell new .
	
	gameOfLife _ GameOfLife with: #( aCell ) .
		
	self assert: aCell state equals: #Died! !
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 20:31:46'!
stateOf: aCell
	
	^ #Died .! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:32:08'!
initializeWithCells: aCellCollection
	
	cells _ aCellCollection .! !

!methodRemoval: GameOfLife #initializeWith: stamp: 'eb 10/22/2020 20:32:11'!
initializeWith: aCellCollection
	
	cells _ aCellCollection .!

!methodRemoval: GameOfLifeTest #setUp stamp: 'eb 10/22/2020 20:32:16'!
setUp

	
	!

TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLifeTest category: #GameOfLife stamp: 'eb 10/22/2020 20:32:23'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:32:31' prior: 50949518!
test01
	
	| gameOfLife aCell |
	
	aCell _ Cell new .
	
	gameOfLife _ GameOfLife with: #( aCell ) .
		
	self assert: aCell state equals: #Died! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:16' prior: 50949553!
test01
	
	| aGameOfLife aCell |
	
	aCell _ Cell new .
	
	aGameOfLife _ GameOfLife with: #( aCell ) .
		
	self assert: (aGameOfLife stateOf: aCell) equals: #Died! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:33:18'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:33:18'!
ERROR!
!SimpleUnit methodsFor: 'measurement creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aNumber

	^SimpleMeasure amount: aNumber unit: self! !
!TestIntervalAwareMagnitude class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aNumber

	^self new initializeWith: aNumber! !
!Collection class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: anObject 
	"Answer an instance of me containing anObject."

	^ self new
		add: anObject;
		yourself! !
!ArrayedCollection class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41' overrides: 50949585!
withCells: anObject 
	"Answer a new instance of me, containing only anObject."

	| newCollection |
	newCollection _ self new: 1.
	newCollection at: 1 put: anObject.
	^newCollection! !
!CompoundUnit methodsFor: 'measurement creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aNumber

	^SimpleMeasure amount: aNumber unit: self! !
!WriteStream class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aCollection 
	"Answer an instance of me on the argument, aCollection, positioned to 
	store objects at the end of aCollection."

	^self basicNew with: aCollection! !
!Robot class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Entero class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	^self new initalizeWith: aValue! !
!GameOfLife class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aCellCollection
	
	self new initializeWith: aCellCollection .! !
!Unit methodsFor: 'measurement creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aNumber

	self subclassResponsibility! !
!ListItemWrapper class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:41'!
withCells: anObject

	^self new setItem: anObject! !
!WriteStream methodsFor: 'private' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aCollection

	super on: aCollection.
	position _ readLimit _ writeLimit _ aCollection size! !
!MeasureConverter class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aGraphPathFinder

	^self new initializeWith: aGraphPathFinder! !
!NullUnit methodsFor: 'measurement creation' stamp: 'eb 10/22/2020 20:33:41' overrides: 50949636!
withCells: aNumber

	^aNumber! !
!VariablesToParametrizeKeywordsDefinitions class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: someDefinitions

	self assertKeywordMustStartWithValidStartOfSelector: someDefinitions first keyword.
	self assertParameterNamesAreNotRepeated: someDefinitions.
	self assertVariableNamesAreNotRepeated: someDefinitions.

	^self new initializeWith: someDefinitions ! !
!StateTransitionEvent class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: aTDDState
	^ self new tddState: aTDDState ! !
!CanNotChangeSelectorWithNotIncludedTypes class methodsFor: 'instance creation' stamp: 'eb 10/22/2020 20:33:41'!
withCells: messageSendsWithInvalidReceiverTypes
 
	^self new initializeWith: messageSendsWithInvalidReceiverTypes! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:41' prior: 50788376!
test08ParameterNamesMustNotBeEqualToANestedBlockTemporal

	| variablesToParametrizeKeywordsDefinitions sourceWithIf definitions |

	sourceWithIf := 'm1
		anInstVar ifNil: [self ifNil: [ | tempVar | tempVar := 1 + 1]].'.
	definitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'self'
			useKeyword: #with
			withParameterName: 'tempVar'}.
	variablesToParametrizeKeywordsDefinitions :=
		VariablesToParametrizeKeywordsDefinitions withCells: definitions.

	self creationFromSource: sourceWithIf withDefinitions: variablesToParametrizeKeywordsDefinitions failsWithMessageText: [
			ReplaceIfNilWithPolymorphismParameters	parameterNameMustNotBeEqualToBlockTemporaryErrorMessage].! !
!Number methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:41' prior: 50733480!
multiplyByUnit: aUnit

	^aUnit withCells: self! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:41' prior: 50772102!
test06NewVariableNameCanNotBeDefinedInSuperclasses

	|  classToRefactorSuperclass classToRefactor  |

	newVariable := 'a'.
	classToRefactorSuperclass := self createClassNamed: #SuperclassWithInstVar instanceVariableNames: newVariable.
	classToRefactor := self createClassNamed: self classToRefactorName subclassOf: classToRefactorSuperclass.
	
	self 
		assertCreation: [AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [NewInstanceVariablePrecondition errorMessageForNewInstanceVariable: newVariable alreadyDefinedInAll: (Array withCells: classToRefactorSuperclass)]
! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50745197!
testToNegativeBy

	| interval number |
	interval := (GregorianMonthOfYear yearNumber:  2004 monthNumber: 12) 
		to: (GregorianMonthOfYear yearNumber:  2004 monthNumber: 01)
		by: (TimeUnits month withCells: -2).
	number := 12.
	interval do: [:aMonthOfYear | 
		self assert: aMonthOfYear monthNumber = number.
		number := number - 2].
	self assert: number = 0! !
!HybridCanvas methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50921635 overrides: 50709297!
drawCurrentAndSubmorphs
	| auxBitBlt hack r |
	super drawCurrentAndSubmorphs.

self flag: #jmvHacks.
	"If we get here, we are drawing with BitBlt, not VectorCanvas.
	Clear morphIds of pixels drawn for currentMorph"
	r _ self boundingRectOfCurrentMorphAfterDraw.
	hack _ Form extent: form extent depth: 32 bits: (vectorCanvas engine instVarNamed: 'morphIds').
	auxBitBlt _ BitBlt toForm: hack.
	auxBitBlt fillBitmap: (Bitmap withCells: 16r00000000).
	auxBitBlt combinationRule: Form over.
	auxBitBlt destRect: r.
	auxBitBlt copyBits! !
!ExtractMethodParametersDetector methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50680614!
nodesThatAddVariablesToScope

	^ (Set withCells: methodNodeToRefactor)
		addAll: self blockNodesEnclosingIntervalToExtract;
		yourself! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50729309!
multiplyMinusInfinity: aMinusInfinity

	^(aMinusInfinity unit * self) withCells: aMinusInfinity amount! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50880472!
test11EnteroAddsFraccionCorrectly
"
	Ahora empieza la diversion!!
"

	self assert: one + oneFifth equals: (Entero withCells: 6) / (Entero withCells: 5)! !
!Morph methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50714958!
privateAddMorph: aMorph atIndex: index

	| oldIndex myWorld itsWorld oldOwner |
	(self canAdd: aMorph) ifFalse: [
		(self confirm: 'The requested morph requires VectorGraphics support. Do you want to install and activate it?')
			ifTrue: [
				Feature require: 'VectorGraphics'.
				MorphicCanvas activeSubclass: (Smalltalk at: #HybridCanvas) ]
			ifFalse: [
				^self error: 'We can''t add requested morph.' ]].
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue:[
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
	] ifFalse:[
		"adding a new morph"
		oldOwner ifNotNil:[
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph invalidateBounds].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array withCells: aMorph).
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil: [aMorph invalidateBounds].
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ].
! !
!DateAndTime methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 16828936!
to: anEnd by: aDuration
	"Answer a Timespan. anEnd conforms to protocol DateAndTime or protocol Timespan"

	self assert: (anEnd is: #DateAndTime).
	self assert: aDuration class == Duration.
	^ (Schedule starting: self ending: anEnd)
		schedule: (Array withCells: aDuration);
		yourself.
! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50732186!
multiplyByUnit: aUnit

	^aUnit withCells: self! !
!RemoteTempVectorNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 16900847!
nodeToInitialize: encoder
	^AssignmentNode new
		variable: self
		value: (encoder supportsClosureOpcodes
					ifTrue: [NewArrayNode new numElements: remoteTemps size]
					ifFalse:
						[MessageNode new
							receiver: (encoder encodeVariable: 'Array')
							selector: #new:
							arguments: (Array withCells: (encoder encodeLiteral: remoteTemps size))
							precedence: 3
							from: encoder])! !
!TypeCheckingIssue methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50807474 overrides: 50807356!
sourceCodeRange
	
	^Array withCells: (methodNode rangeForNode: messageNode ifAbsent: [^#()])! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50788401!
test09ParameterNamesMustNotBeEqualToNestedBlocksArguments

	| variablesToParametrizeKeywordsDefinitions sourceWithIf definitions |

	sourceWithIf := 'm1
		anInstVar ifNil: [self allInstVarNames collect: [:arg | arg asSymbol]].'.
	definitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'self'
			useKeyword: #with
			withParameterName: 'arg'}.
	variablesToParametrizeKeywordsDefinitions :=
		VariablesToParametrizeKeywordsDefinitions withCells: definitions.

	self creationFromSource: sourceWithIf withDefinitions: variablesToParametrizeKeywordsDefinitions failsWithMessageText: [
			ReplaceIfNilWithPolymorphismParameters	parameterNameMustNotBeEqualToBlockTemporaryErrorMessage ].! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50880585!
test30FraccionSubstractsEnteroCorrectly

	| sixFifth |
	
	sixFifth := (Entero withCells: 6) / (Entero withCells: 5).
	
	self assert: sixFifth - one equals: oneFifth! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50721527!
testIntegerDividedByUnit

	| kelvin |
	
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5 / kelvin) = (SimpleMeasure amount: 5 unit: NullUnit new / kelvin).
	self assert: (5 / (kelvin withCells: 1)) = (SimpleMeasure amount: 5 unit: NullUnit new / kelvin).
	self assert: (5 / kelvin) numerator = 5.
	self assert: (5 / kelvin) denominator = (kelvin withCells: 1).
	self assert: (5 / (kelvin withCells: 1)) numerator = 5.
	self assert: (5 / (kelvin withCells: 1)) denominator = (kelvin withCells: 1).
	
! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50721500!
testFloatMultipliedByUnit

	| kelvin |
	
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: 5.5 * kelvin = (kelvin withCells: 5.5).
	self assert: (5.5 * kelvin) numerator = (kelvin withCells: 5.5) numerator.
	self assert: (5.5 * kelvin) denominator = (kelvin withCells: 5.5) denominator! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50745962!
twoYears
	
	^TimeUnits year withCells: 2! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50720680!
testSamePlace

	| path |

	path := finder pathFrom: 1 to: 1.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 1 to: 1)))! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50721486!
testFloatDividedByUnitTwice

	| kelvin meter |
	
	kelvin := BaseUnit named: 'kelvin'.
	meter := BaseUnit named: 'meter'.
	
	self assert: (5.5 / kelvin / meter) = (5.5 / (kelvin * meter withCells: 1)).
	self assert: (5.5 / kelvin / meter ) numerator = 5.5 numerator.
	self assert: (5.5 / kelvin / meter) denominator = (kelvin * meter withCells: 5.5 denominator)! !
!Object methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 16881590!
when: anEventSelector
send: aMessageSelector
to: anObject
with: anArg
 
    self
        when: anEventSelector
        evaluate: (WeakMessageSend
            receiver: anObject
            selector: aMessageSelector
		arguments: (Array withCells: anArg))! !
!ProportionalDerivedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50726368!
testMeasureCreation

	self assert: (centavo withCells: 10) = (SimpleMeasure amount: 10 unit: centavo)! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50721712!
testMeasureCreation

	| meter |
	
	meter := BaseUnit named: 'meter'.
	self assert: (meter withCells: 10) = (SimpleMeasure amount: 10 unit: meter)! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50744306!
oneYear
	
	^TimeUnits year withCells: 1! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 16832161!
quickMethod
	| |
	method isReturnSpecial
		ifTrue: [^ constructor codeBlock:
				(Array withCells: (constTable at: method primitive - 255)) returns: true].
	method isReturnField
		ifTrue: [^ constructor codeBlock:
				(Array withCells: (constructor codeInst: method returnField)) returns: true].
	self error: 'improper short method'! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50747132!
testTimeToEndOfDay

	self assert: TimeOfDay firstTimeOfDay timeToEndOfDay = TimeOfDay twentyFourHours.
	self assert: TimeOfDay lastTimeOfDay timeToEndOfDay = (TimeUnits millisecond withCells: 1)! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 16910463!
explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg provider |
	provider _ self codeProvider.
	(provider respondsTo: #selectedMessageName) ifFalse: [^ nil].
	(msg _ provider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last == $: ifFalse: [^ nil].
	"Name of this method"
	lits _ Array withCells: msg.
	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply _ ', which is the selector of this very method!!'.
			s _ self class plateA]
		ifNil: [ 
			"Selectors called from this method"
			lits _ (provider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole _ lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply _ '.'.
			s _ self class plateB].
		classes _ Smalltalk allClassesImplementing: whole.
		classes size > 12
			ifTrue: [classes _ 'many classes']
			ifFalse: [classes _ 'these classes ' , classes printString].
		^ String streamContents: [:str |
			str
				nextPutAll: string;
				nextPutAll: ' is one part of the message selector ';
				nextPutAll: whole;
				nextPutAll: reply;
				nextPutAll: '  It is defined in ';
				nextPutAll: classes;
				nextPutAll: s]! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50728089!
testMultiplyFloatByMeasure

	self assert: (1.01 * self tenPesos) = ((NullUnit new * self peso) withCells: 1.01*10)

! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50751972!
testDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollection withCells: 1.
	traversedElements := OrderedCollection new.
	self shouldntFail: [ collectionToTraverse do: [ :anElement | traversedElements add: anElement ] separatedBy: [ self fail ] ].

	self assert: collectionToTraverse equals: traversedElements! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:42' prior: 50770771!
testAssertChangesFromToPassesWhenActionChangesConditionFromAndToTheSpecifiedValues

	|aCollection|

	aCollection := OrderedCollection withCells: 1.
	
	self assert: [ aCollection add: 2 ] changes: [ aCollection size ] from: 1 to: 2! !
!GregorianDayOfMonth methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50737058!
to: aGregorianDayOfMonth everyDayNumber: aDayNumber

	^self to: aGregorianDayOfMonth everyDayNumbers: (Array withCells: aDayNumber)! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 16868285!
printWithClosureAnalysisIfNil: aStream indent: level

	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	^self printWithClosureAnalysisKeywords: selector key
		arguments: (Array withCells: arguments first)
		on: aStream indent: level! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 16909037 overrides: 16880407!
printStringBase: b 
	"Return a String representation of this number in base b.
	For SmallIntegers, it is more efficient to print directly in a String,
	rather than using a Stream like super."

	self < 0
		ifTrue: [^ '-'
				, (self negated printStringBase: b)].
	self < b
		ifTrue: [^ String
				withCells: (Character digitValue: self)].
	^ self printStringBase: b nDigits: (self numberOfDigitsInBase: b)! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50742257!
testDaysTo
						
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = self zeroDays.
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 1)) = self thirtyOneDays.
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 3 dayNumber: 1)) = (TimeUnits day withCells: (31+29)).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 366).
	self assert: ((FixedGregorianDate yearNumber: 2003 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 365).

	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2003 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: -365).
	self assert: ((FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1) distanceTo: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: -366).
! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50743912!
testCommonDaysMeasure

	self assert: GregorianDay minusOneDay = (TimeUnits day withCells: -1).
	self assert: GregorianDay zeroDays = (TimeUnits day withCells: 0).
	self assert: GregorianDay oneDay = (TimeUnits day withCells: 1).
	self assert: GregorianDay twoDays = (TimeUnits day withCells: 2).
	self assert: GregorianDay sevenDays = (TimeUnits day withCells: 7).
	self assert: GregorianDay twentyEightDays = (TimeUnits day withCells: 28).
	self assert: GregorianDay twentyNineDays = (TimeUnits day withCells: 29).
	self assert: GregorianDay thirtyDays = (TimeUnits day withCells: 30).
	self assert: GregorianDay thirtyOneDays = (TimeUnits day withCells: 31).
	self assert: GregorianDay threeHundredSixtyDays = (TimeUnits day withCells: 360).
	self assert: GregorianDay threeHundredSixtyFiveDays = (TimeUnits day withCells: 365).
	self assert: GregorianDay threeHundredSixtySixDays = (TimeUnits day withCells: 366)
	! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50778014!
test30CanNotRenameFromBinaryToKeywordOfMoreThanOneParameter

	oldSelector := '&&' asSymbol.
	newSelector := 'abc:def:' asSymbol.
	classToRefactor := self createClassNamed: self classToRefactorName.
	classToRefactor compile: oldSelector asString, ' aParameter'.

	self 
		should: [ RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: #() ]
		raise: Error
		withMessageText: (RenameSelector errorMessageForNewSelector: newSelector isNotOfSameTypeAs: oldSelector)! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50739534!
testIncludedIn

	| set |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (SpecificObjectInclusionRule for: 1);
		addRule: (SpecificObjectInclusionRule for: 2).
		
	self assert: (set includedIn: (0 to: 10)) size = 2.
	self assert: ((set includedIn: (0 to: 10)) asOrderedCollection includesAllOf: (OrderedCollection with: 1 with: 2)).
	self assert: (set includedIn: (1 to: 2)) size = 2.
	self assert: ((set includedIn: (1 to: 2)) asOrderedCollection includesAllOf: (OrderedCollection with: 1 with: 2)).
	self assert: (set includedIn: (2 to: 3)) size = 1.
	self assert: ((set includedIn: (2 to: 3)) asOrderedCollection includesAllOf: (OrderedCollection withCells: 2)).
	self assert: (set includedIn: (3 to: 4)) isEmpty! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50777948!
test28CanRenameFromBinaryToKeywordOfOneParameter

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	oldSelector := '&&' asSymbol.
	newSelector := 'abc:' asSymbol.
	classToRefactor := self createClassNamed: self classToRefactorName.
	classToRefactor compile: oldSelector asString, ' aParameter'.
	classToRefactor compile: referencerToOldSelector asString , ' ^self ' , oldSelector asString,' 1'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	self assert: (classToRefactor includesSelector: newSelector).
	self deny: (classToRefactor includesSelector: oldSelector).
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector). 
! !
!ContextVariablesInspector methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 16825583 overrides: 50691657!
fieldList 
	"Refer to the comment in Inspector|fieldList."

	object
		ifNil: [^ Array withCells: 'thisContext'].
	^fieldList ifNil:[fieldList := (Array with: 'thisContext' with: 'stack top' with: 'all temp vars') , object tempNames]! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50742689!
testNextInNumberOfDays

	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: self tenDays) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 11).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: self thirtyDays) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 31).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: self thirtyOneDays) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 1).

	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: 366)) = 
						(FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1).
	self assert: ((FixedGregorianDate yearNumber: 2003 monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: 365)) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1).
						
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: 0)) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1).
! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50786774!
test28ReplacesIfNotNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNotNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50918222!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 16795327!
categories
	"Answer an Array of categories (names)."
	categoryArray ifNil: [^ nil].
	(categoryArray size = 1 
		and: [categoryArray first = Default & (elementArray size = 0)])
		ifTrue: [^Array withCells: NullCategory].
	^categoryArray! !
!DebuggerMethodMap methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 16830896!
forMethod: aMethod "<CompiledMethod>" methodNode: theMethodNode "<MethodNode>"
	methodReference := WeakArray withCells: aMethod.
	methodNode := theMethodNode.
	self markRecentlyUsed! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50723826!
testMultiplyByInteger

	self assert: (meterOverSecond * 5) = (meterOverSecond withCells: 5).
	self assert: (meterOverSecond * 5) numerator = (meter withCells: 5).
	self assert: (meterOverSecond * 5) denominator = (second withCells: 1).
! !
!RelativeGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50740330!
testHash

	| anotherRelativeDate |

	anotherRelativeDate :=
		RelativeGregorianDate
			timespan: (
				GregorianTimespan
					from: (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01)
					duration: (TimeUnits hour withCells: 72))
			using: timeLineFilter negated.

	self
		assert: relativeDate hash = anotherRelativeDate hash;
		assert: relativeDate hash = absoluteDate hash! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50743276!
testToByMinutesDo

	| interval minutes |
	interval := januaryFirstOf2004 to: januaryThirdOf2004 by: (TimeUnits minute withCells: 1).
	minutes := interval inject: 0 into: [:accumulatedMinutes :aGregorianDateTime | accumulatedMinutes + 1].

	self assert: (TimeUnits minute withCells: minutes - 1) = (TimeUnits hour withCells: 48)! !
!HybridCanvas methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50921699 overrides: 50715713!
drawWorld: aPasteUpMorph rects: allDamage
	"Draw allDamage rects for aPasteUpMorph"
	
	| auxBitBlt hack |
	self flag: #jmvHacks.
	hack _ Form extent: form extent depth: 32 bits: 		((self instVarNamed: 'vectorCanvas') engine instVarNamed: 'morphIds').
	auxBitBlt _ BitBlt toForm: hack.
	auxBitBlt fillBitmap: (Bitmap withCells: 16r00000000).
	auxBitBlt combinationRule: Form over.
	allDamage do: [ :r |
		aPasteUpMorph drawOn: (self newClipRect: r).	
		auxBitBlt destRect: r.
		auxBitBlt copyBits
		].
! !
!IsKindOfManyTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50806600 overrides: 50806552!
buildCastApplierBefore: aPreviousCastingApplier 

	^EffectiveTypeCastApplier 
		casts: (OrderedCollection withCells: self buildTypeCast)
		rejections: OrderedCollection new
		previous: aPreviousCastingApplier! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50881560 overrides: 50881520!
addEntero: anEntero 

	^self class withCells: (value + anEntero integerValue)! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:43' prior: 50788282!
test05CreatesReplaceIfNilWithPolymorphismParameters

	| messageNode methodNode variablesToParametrizeKeywordsDefinitions aClassToRefactor sourceWithIf definitions parameters |

	aClassToRefactor := self createClassNamed: #AClassToRefactor instanceVariableNames: 'anInstVar'.
	sourceWithIf := 'm1 anInstVar ifNil: [self isNil].'.
	aClassToRefactor compile: sourceWithIf.

	methodNode := (aClassToRefactor compiledMethodAt: #m1) methodNode.
	messageNode := methodNode block statements first.

	definitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'self'
			useKeyword: #with
			withParameterName: 'pSelf'}.
	variablesToParametrizeKeywordsDefinitions :=
		VariablesToParametrizeKeywordsDefinitions withCells: definitions.

	parameters :=
		ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: messageNode
			onMethod: methodNode
			useKeywordsDefinitions: variablesToParametrizeKeywordsDefinitions.

	self assert: messageNode equals: parameters messageNode.! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50746317!
testInvalidPreviousANumberOfYears

	| anyUnit |
	
	anyUnit := BaseUnit named: 'Any Unit'.
	
	self should: [ (GregorianYear number: 2004) previous: 1] raise: CanNotConvertMeasureException.
	self should: [ (GregorianYear number: 2004) previous: (anyUnit withCells: 1) ] raise: CanNotConvertMeasureException.
	

	
	
	
	! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50729192!
denominatorOf: aNumber

	^self denominator withCells: aNumber denominator
	
! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50725091!
testMultiplyByMinusInfinity

	self assert: meterBySecond * minusInfinity = (meterBySecond withCells: minusInfinity).
	self assert: minusInfinity * meterBySecond = (meterBySecond withCells: minusInfinity).
	self assert: (meterBySecond * minusInfinity) numerator = (meterBySecond withCells: minusInfinity).
	self assert: (meterBySecond * minusInfinity) denominator = 1! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50746117!
testNumberOfDaysFromBaseDate

	self assert: (GregorianYear number: 1901) numberOfDaysFromBaseDate=(TimeUnits day withCells: 0).
	self assert: (GregorianYear number: 2004) numberOfDaysFromBaseDate=(TimeUnits day withCells: 37620).

! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50772195!
test11FailsWhenNewVariableEqualsArgumentOfABlockInAMethodInClass

	| selector classToRefactor |

	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName.
	selector := #m1.
	classToRefactor compile: selector, ' [ :', newVariable, ' | ] value: 1'.
		
	self 
		assertCreation: [ AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50918259!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !
!ParseNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50663685!
consolidateAsCollection: sourceRanges

	^ sourceRanges isInterval
		ifTrue: [ OrderedCollection withCells: sourceRanges ]
		ifFalse: [ sourceRanges ]! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50742746!
testNextMonth

	| day |
	
	day := FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1.
	
	self assert: (day nextMonth: (TimeUnits month withCells: 1))=(FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 2))=(FixedGregorianDate yearNumber: 2004 monthNumber: 3 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 3))=(FixedGregorianDate yearNumber: 2004 monthNumber: 4 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 4))=(FixedGregorianDate yearNumber: 2004 monthNumber: 5 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 5))=(FixedGregorianDate yearNumber: 2004 monthNumber: 6 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 6))=(FixedGregorianDate yearNumber: 2004 monthNumber: 7 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 7))=(FixedGregorianDate yearNumber: 2004 monthNumber: 8 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 8))=(FixedGregorianDate yearNumber: 2004 monthNumber: 9 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 9))=(FixedGregorianDate yearNumber: 2004 monthNumber: 10 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 10))=(FixedGregorianDate yearNumber: 2004 monthNumber: 11 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 11))=(FixedGregorianDate yearNumber: 2004 monthNumber: 12 dayNumber: 1).
	self assert: (day nextMonth: (TimeUnits month withCells: 12))=(FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1)
! !
!Transcripter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50561855!
black
	Display depth = 1 ifTrue: [^ Bitmap withCells: 16rFFFFFFFF "Works without color support"].
	^ `Color black`! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50728291!
testTruncated

	self assert: (self meter withCells: 1.05) truncated = (self meter withCells: 1).
	self assert: (self centimeter withCells: 1.05) truncated = (self centimeter withCells: 1).
	self assert: ((self peso * self meter ) withCells: 1.05) truncated = ((self peso * self meter) withCells: 1).
	self assert: ((self peso / self meter ) withCells: 1.05) truncated = ((self peso / self meter) withCells: 1)	! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50744302!
oneMonth
	
	^TimeUnits month withCells: 1! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50772214!
test12FailsWhenNewVariableEqualsTemporaryOfABlockInAMethodInClass

	| selector classToRefactor |

	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName.
	selector := #m1.
	classToRefactor compile: selector, ' [ | ', newVariable, ' | ] value'.
		
	self 
		assertCreation: [ AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	
	! !
!StandardFileStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50689675!
readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir _ fullFileName asFileEntry parent.
	files _ dir fileNames.
	fileName _ fullFileName asFileEntry name.
	choices _ fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection _ (PopUpMenu labelArray: choices lines: (Array withCells: 5) )
		startUpWithCaption: fullFileName asFileEntry name, '
does not exist.'.
	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].
	selection < (choices size - 1) ifTrue: [
		newName _ (dir pathName , '/', (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName _ self request: 'Enter a new file name' initialAnswer: fileName.
		"If Cancel was pressed, no file should be opened - Hernan"
		newName isEmpty ifTrue: [ ^nil ]].
	newName = '' ifFalse: [^ FileIOAccessor default privateReadOnlyFile: newName asFileEntry ].
	^ self error: 'Could not open a file'! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 16868091!
printIfOn: aStream indent: level 
	receiver ifNotNil: 
		[ receiver
			printOn: aStream
			indent: level
			precedence: precedence ].
	(arguments last isJust: NodeNil) ifTrue: [ ^ self
			printKeywords: #ifTrue:
			arguments: (Array withCells: arguments first)
			on: aStream
			indent: level ].
	(arguments last isJust: NodeFalse) ifTrue: [ ^ self
			printKeywords: #and:
			arguments: (Array withCells: arguments first)
			on: aStream
			indent: level ].
	(arguments first isJust: NodeNil) ifTrue: [ ^ self
			printKeywords: #ifFalse:
			arguments: (Array withCells: arguments last)
			on: aStream
			indent: level ].
	(arguments first isJust: NodeTrue) ifTrue: [ ^ self
			printKeywords: #or:
			arguments: (Array withCells: arguments last)
			on: aStream
			indent: level ].
	self
		printKeywords: #ifTrue:ifFalse:
		arguments: arguments
		on: aStream
		indent: level! !
!BytecodeEncoder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 16794424!
streamToMethod: aCompiledMethod
	stream := WriteStream withCells: aCompiledMethod.
	stream position: aCompiledMethod initialPC - 1! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50743642!
testNumberOfDaysFromBeginningOfMonth

	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1) numberOfDaysFromBeginningOfMonth = (TimeUnits day withCells: 0).
	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 31) numberOfDaysFromBeginningOfMonth = (TimeUnits day withCells: 30).
	self assert: (GregorianDayOfMonth monthNumber: 2 dayNumber: 29) numberOfDaysFromBeginningOfMonth = (TimeUnits day withCells: 28)! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50728095!
testMultiplyFractionByMeasure

	self assert: ((1/3) * self tenPesos) = ((NullUnit new * self peso) withCells: (1/3)*10)

! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50777445!
test08AllSendersShouldSendOldSelector

	| implementors invalidSenders |
	
	oldSelector := #printString.
	implementors := Array withCells: Object>>oldSelector.
	invalidSenders := Array withCells: Object>>#size.
	
	self 
		assertCreation: [ RenameSelector from: oldSelector to: newSelector implementors: implementors senders: invalidSenders ]
		failsWith: [ RenameSelector errorMessageForInvalidSenders: invalidSenders of: oldSelector ]
! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50789122!
test05FirstKeywordMustNotStartWithAnInvalidStartOfSelector

	| orderedDefinitions |

	orderedDefinitions := {VariableToParametrizeKeywordDefinition
		forVariable: 'variableName'
		useKeyword: '1aKeyword' asSymbol
		withParameterName: 'parameterName'}.

	self
		should: [VariablesToParametrizeKeywordsDefinitions withCells: orderedDefinitions]
		raise: RefactoringError
		withMessageText: [VariablesToParametrizeKeywordsDefinitions firstKeywordMustNoStartWithInvalidStartOfSelectorErrorMessage].! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50731771 overrides: 50730526!
moduloSimpleMeasure: aMeasure

	| numerator denominator |
	
	numerator := aMeasure convertToBaseUnit.
	denominator := self convertToBaseUnit.
	
	^numerator unit / denominator unit 
		withCells: numerator amount // denominator amount! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 16846867!
pixelCompare: aRect with: otherForm at: otherLoc
	"Compare the selected bits of this form (those within aRect) against
	those in a similar rectangle of otherFrom.  Return the sum of the
	absolute value of the differences of the color values of every pixel.
	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,
	in the case of 8-bits or less, this will return the sum of the differing
	bits of the corresponding pixel values (somewhat less useful)"
	"Just use 32 bits..."
	| pixPerWord temp |
	otherForm nativeDepth = 32 ifFalse: [
		^ self pixelCompare: aRect with: (otherForm asFormOfDepth: 32) at: otherLoc ].
	self nativeDepth = 32 ifFalse: [
		^ (self asFormOfDepth: 32) pixelCompare: aRect with: otherForm at: otherLoc ].
	
	pixPerWord _ 32//self depth.
	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue: [
		"If word-aligned, use on-the-fly difference"
		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm
				fillColor: nil rule: 32].
	"Otherwise, combine in a word-sized form and then compute difference"
	temp _ self copy: aRect.
	temp copy: aRect from: otherLoc in: otherForm rule: 21.
	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil
				fillColor: (Bitmap withCells: 0) rule: 32
"  Dumb example prints zero only when you move over the original rectangle...
 | f diff |
f _ Form fromUser.
[ Sensor isAnyButtonPressed ] whileFalse: [
	diff _ f
		pixelCompare: f boundingBox
		with: Display
		at: Sensor mousePoint.
	Display fill: (0@0 extent: 100@20) fillColor: Color white.
	diff printString , '        ' displayAt: 0@0 ]
"! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50725068!
testMultiplyByInfinity

	self assert: meterBySecond * infinity = (meterBySecond withCells: infinity).
	self assert: infinity * meterBySecond = (meterBySecond withCells: infinity).
	self assert: (meterBySecond * infinity) numerator = (meterBySecond withCells: infinity).
	self assert: (meterBySecond * infinity) denominator = 1! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50777862!
test25OldSelectorIsRenamedWhenDefinedInMoreThanOneLiteralArrayMoreThanOnce

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString.
	classToRefactor compile: referencerToOldSelector asString , ' ^#(#' , oldSelector asString, ' #' , oldSelector asString,'), #(#' , oldSelector asString, ' #' , oldSelector asString,')'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector) 
! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50741236!
testNumberOfDaysBetweenTwoDates

	| timeLineFilter rule1 rule2 rule3 |

	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14).
	rule2 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15).
	rule3 := timeLineFilter dateRule: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16).

	timeLineFilter addRules: (OrderedCollection with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter negated numberOfDaysBetween: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 01)
		and: (FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 20)) = (TimeUnits day withCells: 17)! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50883136!
fibonacci

	| one two |
	
	one := self class withCells: 1.
	two := self class withCells: 2.
	
	self isNegative ifTrue: [self error: self class negativeFibonacciErrorDescription ].	
	(self isZero or: [self isOne]) ifTrue: [^one].
	
	^ (self - one) fibonacci + (self - two) fibonacci
		! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 16831684!
jump: dist if: condition

	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock
	  thenJump elseJump condHasValue isIfNil saveStack blockBody blockArgs |
	lastJumpIfPcStack addLast: lastPc.
	stack last == #CascadeFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].
	elsePc := lastPc.
	elseStart := pc + dist.
	end := limit.
	"Check for bfp-jmp to invert condition.
	Don't be fooled by a loop with a null body."
	sign := condition.
	savePc := pc.
	self interpretJump ifNotNil:
		[:elseDist|
		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:
			 [sign := sign not.  elseStart := pc + elseDist]].
	pc := savePc.
	ifExpr := stack removeLast.
	(isIfNil := stack size > 0 and: [stack last == #IfNilFlag]) ifTrue:
		[stack removeLast].
	saveStack := stack.
	stack := OrderedCollection new.
	thenBlock := self blockTo: elseStart.
	condHasValue := hasValue or: [isIfNil].
	"ensure jump is within block (in case thenExpr returns)"
	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].
	"if jump goes back, then it's a loop"
	thenJump < elseStart
		ifTrue:
			["Must be a while loop...
			  thenJump will jump to the beginning of the while expr.  In the case of while's
			  with a block in the condition, the while expr should include more than just
			  the last expression: find all the statements needed by re-decompiling."
			stack := saveStack.
			pc := thenJump.
			blockBody := self statementsTo: elsePc.
			"discard unwanted statements from block"
			blockBody size - 1 timesRepeat: [statements removeLast].
			blockArgs := thenBlock statements = constructor codeEmptyBlock statements
							ifTrue: [#()]
							ifFalse: [{ thenBlock }].
			statements addLast:
				(constructor
					codeMessage: (constructor codeBlock: blockBody returns: false)
					selector: (constructor
								codeSelector: (blockArgs isEmpty
												ifTrue:
													[sign
														ifTrue: [#whileFalse]
														ifFalse: [#whileTrue]]
												ifFalse:
													[sign
														ifTrue: [#whileFalse:]
														ifFalse: [#whileTrue:]])
								code: #macro)
					arguments: blockArgs).
			pc := elseStart.
			self convertToDoLoop]
		ifFalse:
			["Must be a conditional..."
			elseBlock := self blockTo: thenJump.
			elseJump := exit.
			"if elseJump is backwards, it is not part of the elseExpr"
			elseJump < elsePc ifTrue:
				[pc := lastPc].
			cond := isIfNil
						ifTrue:
							[constructor
								codeMessage: ifExpr ifNilReceiver
								selector: (constructor
											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])
											code: #macro)
								arguments: (Array withCells: thenBlock)]
						ifFalse:
							[constructor
								codeMessage: ifExpr
								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)
								arguments:	(sign
												ifTrue: [{elseBlock. thenBlock}]
												ifFalse: [{thenBlock. elseBlock}])].
			stack := saveStack.
			condHasValue
				ifTrue: [stack addLast: cond]
				ifFalse: [statements addLast: cond]].
	lastJumpIfPcStack removeLast.! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50736649!
initializeMinusOneDay

	MinusOneDay := TimeUnits day withCells: -1! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50743114!
testSubtract

	self assert: (januaryFirstOf2004On23Hours59Minutes59Seconds previous: (TimeUnits second withCells: 1)) =  januaryFirstOf2004On23Hours59Minutes58Seconds.
	self assert: (januaryFirstOf2004On23Hours59Minutes59Seconds previous: TimeOfDay twentyFourHours) = december31Of2003On23Hours59Minutes59Seconds.
	self assert: (januaryFirstOf2004 previous: TimeOfDay twentyFourHours) = december31Of2003.
	self assert: (januaryFirstOf2004 previous: (TimeUnits second withCells: -1)) = januaryFirstOf2004On00Hours00Minutes01Seconds.
	self assert: (januaryFirstOf2004 previous: (TimeUnits day withCells: -1)) = januarySecondOf2004.
	self assert: (januaryFirstOf2004On23Hours59Minutes59Seconds previous: TimeOfDay twentyFourHours negated) = januarySecondOf2004On23Hours59Minutes59Seconds! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50743243!
testToBy

	| interval |
	interval := januaryFirstOf2004 to: januarySecondOf2004 by: (TimeUnits hour withCells: 1).
	self assert: interval from = januaryFirstOf2004.
	self assert: interval to = januarySecondOf2004.
	self assert: interval by = (TimeUnits hour withCells: 1)! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50745224!
ceroMonths
	
	^TimeUnits month withCells: 0! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 16834095!
unfold
	| points |
	points := OrderedCollection withCells: x size @ y size.
	^self unfold: points
! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50731568!
abs

	^self unit withCells: amount abs! !
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 50561895!
example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: `Color lightOrange`.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array withCells: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !
!HierarchyBrowser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:44' prior: 16853611 overrides: 16792815!
systemCategorySingleton

	| cls |
	cls _ self selectedClass.
	^ cls ifNil: [Array new]
		ifNotNil: [Array withCells: cls category]! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50724884!
testDivideByInteger

	self assert: (meterBySecond / 5) = (meterBySecond withCells: 1/5).
	self assert: (meterBySecond / 5) numerator = (meterBySecond withCells: 1).
	self assert: (meterBySecond / 5) denominator = 5.
	
! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50746949!
testCreationMinute

	| time |
	
	time := TimeOfDay hours: 1 minutes: 1.
	
	self assert: time hours = (TimeUnits hour withCells: 1).
	self assert: time minutes = (TimeUnits minute withCells: 1).
	self assert: time seconds = (TimeUnits second withCells: 0).
	self assert: time milliseconds = (TimeUnits millisecond withCells: 0)
! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50722711!
testEqualWithDifferentBagSizeButRepresentSameEntity

	self assert: (CompoundMeasure with: self onePeso with: self zeroDollars) =
		(CompoundMeasure measures: (Array withCells: self onePeso))! !
!EqualsTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50806722 overrides: 50806552!
buildCastApplierBefore: aPreviousCastingApplier 
	
	 ^EffectiveTypeCastApplier 
		casts: (OrderedCollection withCells: self buildTypeCast)
		rejections: OrderedCollection new
		previous: aPreviousCastingApplier! !
!SHParserST80 methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50684953!
parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	| continue prevSourcePosition |
	self initializeInstanceVariables.
	sourcePosition _ 1.
	arguments _ Dictionary new.
	temporaries _ Dictionary new.
	blockDepth _ bracketDepth _ braceDepth _ 0.
	blockDepths _ OrderedCollection withCells: blockDepth.
	blockDepthsStartIndexes _ OrderedCollection withCells: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new: 100] ifNotNil: [ ranges reset].
	errorBlock _ [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		continue _ true.
		[ continue ] whileTrue: [
			prevSourcePosition _ sourcePosition.
			self parseStatementList.
			continue _ sourcePosition > prevSourcePosition.
			isAMethod
				ifTrue: [
					"Only if we are parsing a method, consider everything after this point as error."
					currentToken ifNotNil: [ self error ].
					continue _ false]
				ifFalse: [
					sourcePosition > source size ifTrue: [continue _ false]]].
	] ensure: [errorBlock _ nil].
	^true! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50737368!
initializeOneMonth

	OneMonth := TimeUnits month withCells: 1! !
!ActualMessageSendsCollector methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50795573!
analizeMessageSend: aMessageNode
	
	 | receiverTypes incompleteTypeInfoReasons |

	incompleteTypeInfoReasons := Set new.
	receiverTypes := [ aMessageNode receiverOrCascadeReceiver 
		typesIn: toAnalize 
		addingIncompleteTypeInfoTo: incompleteTypeInfoReasons ]
			on: MethodNotAnnotatingTypes 
			do: [ :anError | #() ].			
	
	receiverTypes isEmpty
		ifTrue: [ possibleMessageSends add: aMessageNode->(Array withCells: 'Could not get receiver''s type info') ]
		ifFalse: [ 
			"A method can have sure message sends and possible message sends!! - Hernan"
			(self isSureMessageSendFor: receiverTypes) ifTrue: [ sureMessageSends add: aMessageNode ].
			incompleteTypeInfoReasons notEmpty ifTrue: [ possibleMessageSends add: aMessageNode->incompleteTypeInfoReasons ]]! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50744318!
twoMonths

	^TimeUnits month withCells: 2! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50787418!
creationFromSourceCode: aSourceCodeBody failsWithMessageText: messageTextBlock

	| aClassToRefactor ifMessageNode methodNode replacementParameters definitions |

	aClassToRefactor := self
		createClassNamed: #AClassToRefactor
		instanceVariableNames: self defaultInstVarName.
	aClassToRefactor compile: self methodToRefactorSelector asString, ' ', aSourceCodeBody.
	methodNode := (aClassToRefactor compiledMethodAt: self methodToRefactorSelector) methodNode.
	ifMessageNode := methodNode block statements first.

	definitions :=
		VariablesToParametrizeKeywordsDefinitions
			withCells: {VariableToParametrizeKeywordDefinition
					forVariable: self defaultInstVarName
					useKeyword:  #with
					withParameterName: 'paramName'}.
	replacementParameters :=
		ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: ifMessageNode
			onMethod: methodNode
			useKeywordsDefinitions: definitions.

	self
		should: [
			IntroduceNullObject
				on: self defaultInstVarName
				of: aClassToRefactor
				usingAsConcreteClass: (self createClassNamed: #ConcreteClass)
				usingAsNullClass: (self createClassNamed: #NullClass)
				for: {replacementParameters}]
		raise: RefactoringError
		withMessageText: messageTextBlock.! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50786599!
test21WhenIfNilCheckHasIsNilReplacesIfNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!MultipliedUnit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50729584!
divFrom: aNumber

	^(DividedUnit nullUnit: aNumber unit multipliedUnit: self) withCells: aNumber! !
!Morph methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50715012!
privateAddMorph: aMorph atIndex: index position: aPoint

	| oldIndex myWorld itsWorld oldOwner |
	(self canAdd: aMorph) ifFalse: [
		(self confirm: 'The requested morph requires VectorGraphics support. Do you want to install and activate it?')
			ifTrue: [
				Feature require: 'VectorGraphics'.
				MorphicCanvas activeSubclass: (Smalltalk at: #HybridCanvas) ]
			ifFalse: [
				^self error: 'We can''t add requested morph.' ]].
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue: [
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
		aMorph privatePosition: aPoint.
	] ifFalse: [
		"adding a new morph"
		oldOwner ifNotNil: [
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph redrawNeeded].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array withCells: aMorph).
		aMorph privatePosition: aPoint.
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil: [aMorph redrawNeeded].
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ]! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 16910288!
explainDelimitor: string
	"Is string enclosed in delimitors?"

	| str |
	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"
	(string first = string last) ifTrue:
			[^ self explainChar: (String withCells: string first)]
		ifFalse:
			[(string first = $( and: [string last = $)]) ifTrue:
				[^ self explainChar: (String withCells: string first)].
			(string first = $[ and: [string last = $]]) ifTrue:
				[^ self explainChar: (String withCells: string first)].
			(string first = ${ and: [string last = $}]) ifTrue:
				[^ self explainChar: (String withCells: string first)].
			(string first = $< and: [string last = $>]) ifTrue:
				[^ self explainChar: (String withCells: string first)].
			(string first = $# and: [string last = $)]) ifTrue:
				[^'An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array.'].
			string first = $# ifTrue:
				[^'An instance of class Symbol.'].
			(string first = $$ and: [string size = 2]) ifTrue:
				[^'An instance of class Character.  This one is the character ', (String withCells: string last), '.'].
			(string first = $:) ifTrue:
				[str := string allButFirst.
				(self explainTemp: str) ifNotNil: [
					^'An argument to this block will be bound to the temporary variable ',
						str, '.']]].
	^ nil! !
!CompoundMeasureTest class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50723161 overrides: 16927631!
resources

	^Array withCells: UnitsTestResource! !
!NullObjectHierarchyCreatorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50788046 overrides: 50771397!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50789290 overrides: 50771397!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData ! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50741514!
thirtyOneDays
	
	^TimeUnits day withCells: 31! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50725057!
testMultiplyByFloat

	self assert: (meterBySecond * 5.5) = (meterBySecond withCells: 5.5).
	self assert: (meterBySecond * 5.5) numerator = (meterBySecond withCells: 5.5 numerator).
	self assert: (meterBySecond * 5.5) denominator = 5.5 denominator! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50786975!
test36WhenNoNullBlockIsPresentEmptyPolymorphicMessageIsAddedToTheNullClass

	| sourceWithIf definitions expectedSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifFalse: [self isNil]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedSourceCode := 'with: p1'.
	self assert: expectedSourceCode equals: (self nullClass compiledMethodAt: #withCells:) sourceCode.
	! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50736696!
initializeTwoDays

	TwoDays := TimeUnits day withCells: 2! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50786911!
test33PolymorphicMessageIsAddedToTheNullClass

	| sourceWithIf definitions |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	self assert: (self nullClass selectors includes: #withCells:).! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:45' prior: 50558287!
enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String withCells: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String withCells: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^ true! !
!Color methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50353321!
bitPatternForDepth: depth
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"

	^ Bitmap withCells: (self pixelWordForDepth: depth)! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50739508!
testIncludedFromTo

	| set |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (SpecificObjectInclusionRule for: 1);
		addRule: (SpecificObjectInclusionRule for: 2).
		
	self assert: (set includedFrom: 0 to: 10) size = 2.
	self assert: ((set includedFrom: 0 to: 10) asOrderedCollection includesAllOf: (OrderedCollection with: 1 with: 2)).
	self assert: (set includedFrom: 1 to: 2) size = 2.
	self assert: ((set includedFrom: 1 to: 2) asOrderedCollection includesAllOf: (OrderedCollection with: 1 with: 2)).
	self assert: (set includedFrom: 2 to: 3) size = 1.
	self assert: ((set includedFrom: 2 to: 3) asOrderedCollection includesAllOf: (OrderedCollection withCells: 2)).
	self assert: (set includedFrom: 3 to: 4) isEmpty! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50918232!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50720462!
testTo

	| interval |
	
	interval := (TestIntervalAwareMagnitude withCells: 10) to: (TestIntervalAwareMagnitude withCells: 20).

	self assert: interval from = (TestIntervalAwareMagnitude withCells: 10).
	self assert: interval to = (TestIntervalAwareMagnitude withCells: 20).
	self assert: interval by = (TestIntervalAwareMagnitude withCells: 1)! !
!TrieTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50767340!
testIncludesReturnsFalseForStringsNotIncluded
	
	self deny: ((Trie withCells: 'hello') includes: 'bye')
	! !
!ConversionTableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50723186!
tenDollars
	
	^self dollar withCells: 10! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50772233!
test13FailsWhenNewVariableIsHiddenInAnyMethodOfAnySubclass

	| selector classToRefactor subclass |

	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName.
	subclass := self createClassNamed: #SubclassOfClassToRefactor subclassOf: classToRefactor.
	selector := #m1.
	subclass compile: selector, ' | ', newVariable, ' | '.
		
	self 
		assertCreation: [ AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (subclass>>selector)) ].
	
	! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50721600!
testMultiplyByInfinity

	| kelvin |

	kelvin := BaseUnit named: 'kelvin'.
	self assert: kelvin * infinity = (kelvin withCells: infinity).
	self assert: infinity * kelvin = (kelvin withCells: infinity).
	self assert: (kelvin * infinity) numerator = (kelvin withCells: infinity).
	self assert: (kelvin * infinity) denominator = 1! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50786544!
test19WhenIfNilCheckHasOneKeywordReplacesIfNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!Decompiler methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 16831575!
case: dist
	"statements = keyStmts #CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add #CascadeFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	stack addLast: #CaseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).

	stack last == #CaseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns weirdly I guess)"
			stack removeLast. "get rid of #CaseFlag"
			stmtStream := ReadStream on: (self popTo: stack removeLast).
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == #CascadeFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array withCells: stmtStream next)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50731887 overrides: 50730616!
measures

	^self isNothing
		ifTrue: [#()]
		ifFalse: [Array withCells: self]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50694121!
newMethodCategoryNameIfNone: aNoneBlock

	| labels lines menuIndex newName reject |
	
	labels _ OrderedCollection withCells: 'new...'.
	reject _ Set new.
	reject
		addAll: self selectedClassOrMetaClass organization categories;
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	lines _ OrderedCollection new.
	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |
		cls = Object ifFalse: [
			cats _ cls organization categories reject:
				 [:cat | reject includes: cat].
			cats isEmpty ifFalse: [
				lines add: labels size.
				labels addAll: cats asArray sort.
				reject addAll: cats]]].
	newName _ (labels size = 1 or: [
		menuIndex _ (PopUpMenu labelArray: labels lines: lines)
		startUpWithCaption: 'Add Category'.
		menuIndex = 0 ifTrue: [^ aNoneBlock value].
		menuIndex = 1])
			ifTrue: [
				self request: 'New category name?'
					initialAnswer: 'category-name']
			ifFalse: [
				labels at: menuIndex].
	
	^ newName isEmpty
		ifTrue: aNoneBlock
		ifFalse: [newName asSymbol]! !
!GregorianTimespan methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50747298!
asInterval

	^ArithmeticObjectInterval
		from: from
		to: self to
		by: (duration unit withCells: 1)
		intervalStrategy: DefaultPointInTimeIntervalStrategy new.! !
!WeakMessageSend methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 16944138!
asActionSequence

	^WeakActionSequence withCells: self! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50678080!
computeIdentifierEntriesBeginningWith: aPrefix
	"Use an aux Set to avoid duplicates, but keep the order given."

	| entriesSet lastTitle candidates |
	entriesSet _ Set new.
	lastTitle _ nil.
	
	candidates _ Array streamContents: [ :strm |
		parser namesBeginningWith: aPrefix do: [ :identifier :kindOfIdentifierTitle |
			(entriesSet includes: identifier) ifFalse: [
				kindOfIdentifierTitle = lastTitle ifFalse: [
					strm nextPut: kindOfIdentifierTitle.
					lastTitle _ kindOfIdentifierTitle ].
				entriesSet  add: identifier.
				strm nextPut: identifier ]]].
	entriesSet size = 1 ifTrue: [
		^ Array withCells: entriesSet anyOne ]
		ifFalse: [ ^ candidates ]! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50721560!
testIntegerMultipliedByUnit

	| kelvin |
	
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5 * kelvin) = (kelvin withCells: 5).
	self assert: (5 * kelvin) numerator = (kelvin withCells: 5).
	self assert: (5 * kelvin) denominator = 1.
	self assert: (5 * (kelvin withCells: 1)) numerator = (kelvin withCells: 5).
	self assert: (5 * (kelvin withCells: 1)) denominator = 1.
	
! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50741213!
testNextPositiveDuration

	| timeLineFilter date |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
		
	date := (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01).
	self assert: (timeLineFilter next: (GregorianTimespan from: date duration: (TimeUnits day withCells: 1))) = (date nextDay: GregorianDay saturday).
	self assert: (timeLineFilter next: (GregorianTimespan from: date duration: (TimeUnits day withCells: 2))) =
		((date nextDay: GregorianDay saturday) nextDay: GregorianDay saturday).
	self assert: (timeLineFilter next: (GregorianTimespan from: date duration: (TimeUnits day withCells: 0))) = date! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50561869!
example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: `Color lightBlue`.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array withCells: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50744322!
twoYears
	
	^TimeUnits year withCells: 2! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50738585!
hours: anHour

	^self timeFromMidnight: (TimeUnits hour withCells: anHour)! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:46' prior: 50731813 overrides: 50730560!
remFrom: aNumber

	^aNumber isNothing
		ifTrue: [ InvalidBinaryOperationException signalOperationName: 'rest' leftOperand: aNumber rightOperand: self ]
		ifFalse: [ (unit withCells: (amount rem: aNumber)) / self ]! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50723910!
testMeasureCreation

	self assert: (meterOverSecond withCells: 10) = (SimpleMeasure amount: 10 unit: meterOverSecond)! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50786855!
test31ReplacesIsNilIfTrueIfFalseWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [self isNil] ifFalse: [self isNil]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!Color methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50356690!
mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array withCells: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Color r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50736686!
initializeTwentyEightDays

	TwentyEightDays := TimeUnits day withCells: 28! !
!AutoCompleterSelectorsCollector methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50609279!
addSelectorsOf: aClass upTo: aSuperclassToExclude

	self addSelectorsOfAll: (Array withCells: aClass) upTo: aSuperclassToExclude ! !
!PlusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50726037!
testSameUnitAs

	self assert: (infinity sameUnitAs: 1).
	self deny: (infinity sameUnitAs: ((BaseUnit named: 'peso') withCells: 1))! !
!CharacterSetTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50762360!
testIncludesReturnsFalseForCharacterNotIncluded

	self deny: ((CharacterSet withCells: $a) includes: $b)! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50729276!
divideMinusInfinity: aMinusInfinity

	^((NullUnit new / self) * aMinusInfinity unit) withCells: aMinusInfinity amount! !
!WeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 16943894 overrides: 16865297!
key: aKey
	key := WeakArray withCells: aKey! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50727873!
testDivisionIntegerByMeasure

	self assert: (1 / self tenPesos) = ((NullUnit new / self peso) withCells: 1/10)

! !
!SpecificDayRuleTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50740545!
testIncludes

	| rule includedDate |

	includedDate := FixedGregorianDate yearNumber: 2006 monthNumber: 01 dayNumber: 01.
	rule := SpecificDayRule rule: (Array withCells: includedDate day).

	self
		assert: (rule includes: includedDate);
		deny: (rule includes: includedDate next)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50746925!
testCreationHour

	| time |
	
	time := TimeOfDay hours: 1.
	
	self assert: time hours = (TimeUnits hour withCells: 1).
	self assert: time minutes = (TimeUnits minute withCells: 0).
	self assert: time seconds = (TimeUnits second withCells: 0).
	self assert: time milliseconds = (TimeUnits millisecond withCells: 0)! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50770863!
testAssertIncludesShouldNotFailWhenElementIsInCollection
	
	| collection anElement |
	
	anElement _ 1.
	collection _ Array withCells: anElement.
	
	self 
		shouldnt: [ self assert: collection includes: anElement ] 
		raise: TestResult failure! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50729304!
multiplyInfinity: anInfinity

	^(anInfinity unit * self) withCells: anInfinity amount! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50742210!
testDaysFrom
						
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = self zeroDays.
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = self thirtyOneDays.
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 3 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: (31+29)).
	self assert: ((FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 366).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2003 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 365).

	self assert: ((FixedGregorianDate yearNumber: 2003 monthNumber: 1 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: -365).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) distanceFrom: 
						(FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: -366).
! !
!TestSuite class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50338328!
forNoTestMethod: aCompiledMethod 
	
	| allTestSenders testCaseClassesReferencingClass reducedTestSenders suite |
	
	allTestSenders _ self allTestsSending: aCompiledMethod selector.
	testCaseClassesReferencingClass _ aCompiledMethod methodClass 
		withTestCaseClassDo:  [:aTestCaseClass | Array withCells: aTestCaseClass ]
		ifNone: [ self allTestCaseClassesReferencing: aCompiledMethod methodClass ].
		
	reducedTestSenders _ allTestSenders select: [ :aMethodReference | testCaseClassesReferencingClass includes: aMethodReference actualClass ].
	reducedTestSenders isEmpty 
		ifTrue: [ suite _ self forClass: aCompiledMethod methodClass ]
		ifFalse: [ 
			suite _ self named: 'Tests senders of ', aCompiledMethod selector.
			reducedTestSenders do: [ :aMethodReference | suite addTest: (aMethodReference actualClass selector: aMethodReference selector)]].
	
	^suite! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50777111!
test15FailsWhenNewVariableEqualsTemporaryVariableOfAMethodInClass

	| selector |

	self createClassToRefactor.
	selector := #m1.
	classToRefactor compile: selector, ' | ', newVariable, ' | ', newVariable, ' := 10.'.
	
	self 
		assertCreation: [ RenameInstanceVariable from: oldVariable to: newVariable in: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 16869241!
transformIfNilIfNotNil: encoder
	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we
	 transform the receiver to
		(var := receiver)
	 which is further transformed to
		(var := receiver) == nil ifTrue: .... ifFalse: ...
	 This does not allow the block variable to shadow an existing temp, but it's no different
	 from how to:do: is done."
	| ifNotNilArg |
	ifNotNilArg := arguments at: 2.
	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder maxArgs: 0)
	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:
		[^false].

	ifNotNilArg numberOfArguments = 1 ifTrue:
		[receiver := AssignmentNode new
						variable: ifNotNilArg firstArgument
						value: receiver].

	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
	receiver := MessageNode new
					receiver: receiver
					selector: #==
					arguments: (Array withCells: NodeNil)
					precedence: 2
					from: encoder.
	arguments do: [:arg| arg noteOptimizedIn: self].
	^true! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50786167!
test01BlocksToExtractMustNotContainReferencesToSuper

	| aClassToRefactor sourceWithIf ifMessageNode replacementParameters definitions methodNode |

	aClassToRefactor := self
		createClassNamed: #AClassToRefactor
		instanceVariableNames: self defaultInstVarName.
	sourceWithIf := 'm1 ', self defaultInstVarName, ' ifNil: [ super isNil ]'.
	aClassToRefactor compile: sourceWithIf.
	methodNode := (aClassToRefactor compiledMethodAt: #m1) methodNode.
	ifMessageNode :=  methodNode block statements first.

	definitions :=
		VariablesToParametrizeKeywordsDefinitions
			withCells: {VariableToParametrizeKeywordDefinition forVariable: 'super' useKeyword: #with withParameterName: 'p1'}.
	replacementParameters :=
		ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: ifMessageNode
			onMethod: methodNode
			useKeywordsDefinitions: definitions.

	self
		should: [
			IntroduceNullObject
				on: self defaultInstVarName
				of: aClassToRefactor
				usingAsConcreteClass: (self createClassNamed: #ConcreteClass)
				usingAsNullClass: (self createClassNamed: #NullClass)
				for: {replacementParameters}]
		raise: RefactoringError
		withMessageText: [ IntroduceNullObject messageNodesReferenceSuperErrorMessage: {ifMessageNode}].! !
!Association methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 16780930 overrides: 16881992!
objectForDataStream: refStrm
	| dp |
	"I am about to be written on an object file.  If I am a known global, write a proxy that will hook up with the same resource in the destination system."

	^ (Smalltalk associationAt: key ifAbsent: nil) == self 
		ifTrue: [dp _ DiskProxy global: #Smalltalk selector: #associationOrUndeclaredAt: 
							args: (Array withCells: key).
			refStrm replace: self with: dp.
			dp]
		ifFalse: [self]! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50724994!
testIntegerDividedByUnit

	self assert: (5 / meterBySecond) = (5 / (meterBySecond withCells: 1)).
	self assert: (5 / meterBySecond) numerator = 5.
	self assert: (5 / meterBySecond) denominator = (meterBySecond withCells: 1).
	
! !
!PlusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50726030!
testSameDomainAs

	self assert: (infinity sameDomainAs: 1).
	self deny: (infinity sameDomainAs: ((BaseUnit named: 'peso') withCells: 1))! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:47' prior: 50880671 overrides: 16927572!
setUp

	zero := Entero withCells: 0.
	one := Entero withCells: 1.
	two := Entero withCells: 2.
	three:= Entero withCells: 3.
	four := Entero withCells: 4.
	five := Entero withCells: 5.
	eight := Entero withCells: 8.
	negativeOne := Entero withCells: -1.
	negativeTwo := Entero withCells: -2.
	
	oneHalf := one / two.
	oneFifth := one / five.
	twoFifth := two / five.
	twoTwentyfifth := two / (Entero withCells: 25).
	fiveHalfs := five / two.
	! !
!Character methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 16800602 overrides: 16881101!
asString
	^ String withCells: self! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50729319!
multiplySimpleMeasure: aMeasure

	^(aMeasure unit * self) withCells: aMeasure amount! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50738652!
initializeOneSecond

	oneSecond := TimeUnits second withCells: 1! !
!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50343933!
splitNewMorphList: list depth: d
	| middle c prev next out |
	d <= 0 ifTrue: [ ^ Array withCells: list ].
	middle := list size // 2 + 1.
	c := (list at: middle) name first: 3.
	prev := middle - 1.
	[
	prev > 0 and: [ ((list at: prev) name first: 3) = c ]] whileTrue: [ prev := prev - 1 ].
	next := middle + 1.
	[
	next <= list size and: [ ((list at: next) name first: 3) = c ]] whileTrue: [ next := next + 1 ].
	"Choose the better cluster"
	middle := middle - prev < (next - middle)
		ifTrue: [ prev + 1 ]
		ifFalse: [ next ].
	middle = 1 ifTrue: [ middle := next ].
	middle >= list size ifTrue: [ middle := prev + 1 ].
	(middle = 1 or: [ middle >= list size ]) ifTrue: [ ^ Array withCells: list ].
	out := WriteStream on: Array new.
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: 1
					to: middle - 1)
			depth: d - 1).
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: middle
					to: list size)
			depth: d - 1).
	^ out contents.! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50720487!
testToByDo

	| number |
	
	number := 10.	
	((TestIntervalAwareMagnitude withCells: 10) 
		to: (TestIntervalAwareMagnitude withCells: 20) 
		by: (TestIntervalAwareMagnitude withCells: 2))
		do: [ :aTestMagnitude |
			self assert: aTestMagnitude number = number.
			number := number + 2 ].
	
	self assert: number = 22! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50720662!
testPathToNeighborPlace

	| path |

	path := finder pathFrom: 1 to: 2.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 1 to: 2))).

	path := finder pathFrom: 1 to: 5.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 1 to: 5))).

	path := finder pathFrom: 2 to: 3.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 2 to: 3))).
	
	path := finder pathFrom: 3 to: 4.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 3 to: 4)))! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50728101!
testMultiplyIntegerByMeasure

	self assert: (3 * self tenPesos) = ((NullUnit new * self peso) withCells: 3*10)

! !
!RemoveInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50775765!
test02CanNotRemoveInstanceVariableWithReferences

	| variableToRemove classToRefactor selector |
	
	variableToRemove := 'a'.
	classToRefactor := self createClassNamed: #ClassWithInstVar instanceVariableNames: variableToRemove.
	selector := #m1.
	classToRefactor compile: selector,' ^', variableToRemove.
	
	self 
		assertCreation: [ RemoveInstanceVariable named: variableToRemove from: classToRefactor ]
		failsWith: [ RemoveInstanceVariable errorMessageForInstanceVariable: variableToRemove isReferencedInAll: (Array withCells: classToRefactor>>selector) ].
		
	
	! !
!CodePackageListWindow methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50607315!
addRequirement
	"Ask user for a FeatureRequirement based on loaded packages"
	
	| current currentName packageNames reqiredNames selectionNames choices selection cuisBaseName req selectedName |
	current _ model selection.
	current ifNil: [ ^self ].

	packageNames := model packages collect: [ :pak | pak packageName ].
	currentName := current packageName.
	reqiredNames := current requires collect: [ :r | r name ].
	selectionNames := packageNames select: [ :name |
		((name = currentName) or: [reqiredNames includes: name]) not ].
	cuisBaseName := Feature baseSystemFeature name.
	choices := OrderedCollection withCells: #CANCEL.
	(reqiredNames includes: cuisBaseName)
		ifFalse: [ choices add: cuisBaseName ].		
	choices addAll: selectionNames.
	choices size = 1 ifTrue: [
		^ PopUpMenu inform: 'All loaded packages are already required, as is Cuis base system' ].
	selection := PopUpMenu
		withCaption: 'Choose package to require' 
		chooseFrom: choices.
	selection <= 1
		ifTrue: [ ^ self ]  "1 -> Cance, 0 -> Clicked outside the menu"
		ifFalse: [
			selectedName := choices at: selection.
			req := (selectedName = cuisBaseName)
				ifTrue: [ Feature baseSystemFeature requirementOfMe ]
				ifFalse: [ (CodePackage installedPackages at: selectedName) requirementOfMe].
			current featureSpec requires: req.
			current hasUnsavedChanges: true.
			self changed: #requirement ]! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50737372!
initializeSixMonths

	SixMonths := TimeUnits month withCells: 6! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50746881!
testLessThan

	self assert: (TimeOfDay hours: 0) < (TimeOfDay timeFromMidnight: (TimeUnits millisecond withCells: 1)).
	self deny: (TimeOfDay timeFromMidnight: (TimeUnits millisecond withCells: 1)) < (TimeOfDay hours: 0)! !
!DayOfMonthRuleTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50739298!
testIncludes

	| rule includedDate |

	includedDate := FixedGregorianDate yearNumber: 2006 monthNumber: 01 dayNumber: 01.
	rule := DayOfMonthRule rule: (Array withCells: includedDate dayOfMonth).

	self
		assert: (rule includes: includedDate);
		deny: (rule includes: includedDate next)! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50743657!
testNumberOfDaysFromJanuaryFirst

	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1) numberOfDaysFromJanuaryFirst = (TimeUnits day withCells: 0).
	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 31) numberOfDaysFromJanuaryFirst = (TimeUnits day withCells: 30).
	self assert: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31) numberOfDaysFromJanuaryFirst = (TimeUnits day withCells: 365)! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50777431!
test07AllImplementorsMustImplementOldSelector

	| invalidImplementors |
	
	invalidImplementors := Array withCells: Object>>#printString.
	
	self 
		assertCreation: [ RenameSelector from: oldSelector to: newSelector implementors: invalidImplementors senders: #() ]
		failsWith: [ RenameSelector errorMessageForInvalidImplementors: invalidImplementors ]
! !
!Behavior methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50336655!
allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollection withCells: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50743740!
testPreviousANumberOfDays

	self assert: ((GregorianDayOfMonth monthNumber: 12 dayNumber: 31) previous: (TimeUnits day withCells: 7)) = (GregorianDayOfMonth monthNumber: 12 dayNumber: 24).
	self assert: ((GregorianDayOfMonth monthNumber: 2 dayNumber: 29) previous: (TimeUnits day withCells: 7)) = (GregorianDayOfMonth monthNumber: 2 dayNumber: 22).

	self assert: ((GregorianDayOfMonth monthNumber: 1 dayNumber: 1) previous: (TimeUnits day withCells: -1)) = (GregorianDayOfMonth monthNumber: 1 dayNumber: 2).
	self assert: ((GregorianDayOfMonth monthNumber: 1 dayNumber: 1) previous: (TimeUnits day withCells: -32)) = (GregorianDayOfMonth monthNumber: 2 dayNumber: 2)! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50736681!
initializeThreeHundredSixtySixDays

	ThreeHundredSixtySixDays := TimeUnits day withCells: 366! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 16917586!
asPathTokens

	^self beginsWithWindowsDriveName
		ifTrue: [
			(OrderedCollection withCells: (self copyFrom: 1 to: 2)), 
				((self copyFrom: 3 to: self size) findTokens: String pathSeparators) ]
		ifFalse: [
			self findTokens: String pathSeparators ]! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50721545!
testIntegerDividedByUnitTwice

	| kelvin meter |
	
	kelvin := BaseUnit named: 'kelvin'.
	meter := BaseUnit named: 'meter'.
	
	self assert: (5 / kelvin / meter) = (SimpleMeasure amount: 5 unit: NullUnit new / (kelvin * meter)).
	self assert: (5 / kelvin / meter) numerator = 5.
	self assert: (5 / kelvin / meter) denominator = (kelvin * meter withCells: 1).
	
! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50745227!
elevenMonths

	^TimeUnits month withCells: 11! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:48' prior: 50722834!
testIsCompoundMeasurement

	self assert: ((self peso withCells: 10.01) + (self dollar withCells: 20.5)) isCompoundMeasure! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50786516!
test18WhenThereAreVariablesToParametrizeReplacesIfNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50738595!
hours: anHour minutes: aMinute seconds: aSecond

	^self timeFromMidnight: 
		((TimeUnits hour withCells: anHour) +
		(TimeUnits minute withCells: aMinute) +
		(TimeUnits second withCells: aSecond))! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50788316!
test06ReplaceIfNilWithPolymorphismParametersOnBlocksWithBooleanConstants

	| messageNode methodNode variablesToParametrizeKeywordsDefinitions aClassToRefactor sourceWithIf definitions parameters |

	aClassToRefactor := self createClassNamed: #AClassToRefactor instanceVariableNames: 'anInstVar'.
	sourceWithIf := 'm1 anInstVar ifNil: [self or: [true]].'.
	aClassToRefactor compile: sourceWithIf.

	methodNode := (aClassToRefactor compiledMethodAt: #m1) methodNode.
	messageNode := methodNode block statements first.

	definitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'self'
			useKeyword: #with
			withParameterName: 'pSelf'}.
	variablesToParametrizeKeywordsDefinitions :=
		VariablesToParametrizeKeywordsDefinitions withCells: definitions.

	parameters :=
		ReplaceIfNilWithPolymorphismParameters
			forIfNilMessageSending: messageNode
			onMethod: methodNode
			useKeywordsDefinitions: variablesToParametrizeKeywordsDefinitions.

	self assert: messageNode equals: parameters messageNode.! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 16910376!
explainInst: string 
	"Is string an instance variable of this class?"
	| classes cls provider |
	provider _ self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass) ifTrue: [
		cls _ provider selectedClassOrMetaClass].
	cls ifNil: [^ nil].	  "no class known"
	classes _ (Array withCells: cls)
				, cls allSuperclasses.
	classes _ classes detect: [:each | (each instVarNames
			detect: [:name | name = string] ifNone: nil)
			notNil] ifNone: [^nil].
	classes _ classes printString.
	^ String streamContents: [:str |
		str
			nextPutAll: string;
			nextPutAll: ' is an instance variable of the receiver; defined in class ';
			nextPutAll: classes, '\' withNewLines;
			nextPutAll: 'Smalltalk browseAllAccessesTo: ''';
			nextPutAll: string;
			nextPutAll: ''' from: ';
			nextPutAll: classes;
			nextPut: $.]! !
!Browser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 16792178!
messageCategoryList
	"Answer the selected category of messages."
	^selectedClassName
		ifNil: [ #() ]
		ifNotNil: [ (Array withCells: ClassOrganizer allCategory), self rawMessageCategoryList ]! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50880870!
greatestCommonDivisorWith: anEntero 
	
	^self class withCells: (value gcd: anEntero integerValue)! !
!MinusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50724689!
testEqualsMeasure

	| measure |

	measure := (BaseUnit named: 'peso') withCells: 5.
	self assert: (minusInfinity equalsSimpleMeasure: minusInfinity).
	self deny: (minusInfinity equalsSimpleMeasure: measure)! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50722720!
testEqualWithDifferentBagSizeIsNothing

	self assert: (CompoundMeasure with: self zeroPesos with: self zeroDollars) =
		(CompoundMeasure measures: (Array withCells: self zeroPesos))! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50721010!
testNotEmpty

	| graph |

	graph := Graph edges: #() nodes: (Set withCells: 'a').

	self
		assert: graph notEmpty;
		deny: graph isEmpty.

	graph := Graph edges: (Array withCells: (Edge from: 'a' to: 'b')).

	self
		assert: graph notEmpty;
		deny: graph isEmpty! !
!CircularReadStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50728919!
next

	^self next: (unit withCells: 1)! !
!GregorianDate methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50735890!
to: aGregorianDate everyDay: aGregorianDay 
	
	^self to: aGregorianDate every: (Array withCells: aGregorianDay)! !
!String class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 16917918!
tab
	"Answer a string containing a single tab character."

	^ self withCells: Character tab
! !
!String class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 16917886!
lfString
	"Answer a string containing a single Lf character."

	^ self withCells: Character lf! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50668809!
addCategory: catString before: nextCategory
	"Add a new category named heading.
	If default category exists and is empty, remove it.
	If nextCategory is nil, then add the new one at the end,
	otherwise, insert it before nextCategory."
	| index newCategory |
	newCategory _ catString .
	(categoryArray indexOf: newCategory) > 0
		ifTrue: [^self].	"heading already exists, so done"
	index _ categoryArray indexOf: nextCategory
		ifAbsent: [categoryArray size + 1].
	categoryArray _ categoryArray
		copyReplaceFrom: index
		to: index-1
		with: (Array withCells: newCategory).
	categoryStops _ categoryStops
		copyReplaceFrom: index
		to: index-1
		with: (Array withCells: (index = 1
				ifTrue: [0]
				ifFalse: [categoryStops at: index-1])).
	"remove empty default category"
	(newCategory ~= Default
			and: [(self listAtCategoryNamed: Default) isEmpty])
		ifTrue: [self removeCategory: Default]! !
!TextComposer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 16930621!
rectanglesAt: y
	(y+1) > extentForComposing y ifTrue: [^ Array new].
	^ Array withCells: (0 @ y corner: extentForComposing x @ (y+1))! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50720523!
testToYourself

	| magnitude |
	
	magnitude := TestIntervalAwareMagnitude withCells: 10.
	self assert: magnitude toYourself from = magnitude.
	self assert: magnitude toYourself to = magnitude.
	
	
	! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50723714!
testFloatMultipliedByUnitTwice

	| kelvin |
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5.5 * kelvin * meterOverSecond) = (kelvin * meterOverSecond withCells: 5.5).
	self assert: (5.5 * kelvin * meterOverSecond) numerator = (kelvin * meter withCells: 5.5 numerator).
	self assert: (5.5 * kelvin * meterOverSecond) denominator = (second withCells: 5.5 denominator)! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50723993!
tenPesos

	^peso withCells: 10! !
!GregorianYear methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50738208!
calculateNumberOfDaysFromBaseDate
	
	| myNumber numberOfDays |
	
	myNumber := self number.
	numberOfDays := myNumber > 1900 
		ifTrue: [
			(myNumber - 1901) * 365 + ((myNumber - 1901) quo: 4) -
			((myNumber - 1901) quo: 100) + ((myNumber - 1601) quo: 400) ]
		ifFalse: [
			(myNumber - 1901) * 365 + ((myNumber - 1900) quo: 4) -
			((myNumber - 1900) quo: 100) + ((myNumber - 2000) quo: 400) ].
		
	^TimeUnits day withCells: numberOfDays! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50722545!
testIsFraction

	self deny: ((self peso withCells: 10.01) + (self dollar withCells: 20.5)) isFraction! !
!MeasureConverterTest class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:49' prior: 50724288 overrides: 16927631!
resources

	^Array withCells: UnitsTestResource! !
!NegatedTimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50739886!
testNextNegativeDuration

	| timeLineFilter date |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
			
	date := (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 31).
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day withCells: -1))) = date previous.
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day withCells: -2))) = (date previous: GregorianDay twoDays)! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50741510!
thirtyDays
	
	^TimeUnits day withCells: 30! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50789141!
test06ParameterNamesMustNotBeRepeated

	| orderedDefinitionsWithRepeatedParameterNames |

	orderedDefinitionsWithRepeatedParameterNames := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'variableName1'
			useKeyword: #with
			withParameterName: 'parameterName'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'variableName2'
			useKeyword: #with
			withParameterName: 'parameterName'}.

	self
		should: [VariablesToParametrizeKeywordsDefinitions withCells: orderedDefinitionsWithRepeatedParameterNames]
		raise: RefactoringError
		withMessageText: [VariablesToParametrizeKeywordsDefinitions parameterNamesMustNotBeRepeatedErrorMessage].! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50724141!
testTruncated

	| formula |
	
	formula := DummyEvaluation of: (peso withCells: 1.3).
	self assert: formula truncated = (peso withCells: 1)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50747035!
testZeroHours

	self assert: TimeOfDay zeroHours = (TimeUnits hour withCells: 0)! !
!OrderedCollectionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50751837!
testStreamContentsWorksAsExpected

	| contents |
	
	contents := OrderedCollection streamContents: [ :stream | stream nextPut: 1 ].
	
	self assert: (OrderedCollection withCells: 1) equals: contents! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50786997!
test37WhenNoConcreteBlockIsPresentEmptyPolymorphicMessageIsAddedToTheConcreteClass

	| sourceWithIf definitions expectedSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [self isNil]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedSourceCode := 'with: p1'.
	self assert: expectedSourceCode equals: (self concreteClass compiledMethodAt: #withCells:) sourceCode.
	! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50918184!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!Morph methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 16874249!
ownerChain
	"Answer a list of objects representing the receiver and all of its owners.   The first element is the receiver, and the last one is typically the world in which the receiver resides"

	| c next |
	c := OrderedCollection withCells: self.
	next := self.
	[(next := next owner) notNil] whileTrue: [c add: next].
	^c asArray! !
!GregorianMonth methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50737129 overrides: 50735677!
distanceTo: aGregorianMonth 
	| numberOfMonths |
	numberOfMonths := aGregorianMonth number - self number 
				+ self amountOfMonthsPerYear rem: self amountOfMonthsPerYear.
	^TimeUnits month withCells: numberOfMonths! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50738589!
hours: anHour minutes: aMinute

	^self timeFromMidnight: 
		((TimeUnits hour withCells: anHour) +
		(TimeUnits minute withCells: aMinute))! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50357859!
offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel _ self selection.
	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index _ (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array withCells: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute _ TextColor color: (Color perform: (colors at: index)) ]
		ifFalse: [
			index _ index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute _ self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	^ true.! !
!GraphPathFinder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50733223!
findEdgesFrom: source to: target

	| convergingEdges matchingEdge |

	convergingEdges := graph edgesConvergingTo: target.
	matchingEdge := convergingEdges detect: [ :anEdge | anEdge goesFrom: source to: target ] ifNone: [ nil ].
		
	^matchingEdge isNil 
		ifTrue: [ self findEdgesFrom: source toAnyEdgeOf: convergingEdges ]
		ifFalse: [ OrderedCollection withCells: matchingEdge ].
				

! !
!IsKindOfTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50806767 overrides: 50806558!
buildRejectApplierBefore: aPreviousCastingApplier

	^EffectiveTypeCastApplier 
		casts: OrderedCollection new
		rejections: (OrderedCollection withCells: self buildTypeReject)
		previous: aPreviousCastingApplier
	! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50594725!
withRangesOf: nodeAtRange including: aPosition do: aBlock

	| currentNodeRange ranges |

	currentNodeRange := nodeAtRange value.
	ranges := currentNodeRange isInterval ifTrue: [ Array withCells: currentNodeRange ] ifFalse: [ currentNodeRange ].

	ranges do: [ :aRange | (aRange includes: aPosition) ifTrue: [ aBlock value: aRange ]].

	! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50745234!
twelveMonths
	
	^TimeUnits month withCells: 12! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50720426!
testNotInclusiveBetweenAnd

	self assert: ((TestIntervalAwareMagnitude withCells: 1) notInclusiveBetween: (TestIntervalAwareMagnitude withCells: 0) and: (TestIntervalAwareMagnitude withCells: 1)).
	self assert: ((TestIntervalAwareMagnitude withCells: 1) notInclusiveBetween: (TestIntervalAwareMagnitude withCells: 0) and: (TestIntervalAwareMagnitude withCells: 2)).
	self deny: ((TestIntervalAwareMagnitude withCells: 1) notInclusiveBetween: (TestIntervalAwareMagnitude withCells: 1) and: (TestIntervalAwareMagnitude withCells: 1))! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 16923188!
internalizeChangeLog    
		"
		Smalltalk internalizeChangeLog
		"
	"Bring the changes file into a memory-resident filestream, for faster access and freedom from external file system.  1/31/96 sw"

	| reply aFile |
	reply _ self confirm:  'CAUTION -- do not undertake this lightly!!
If you have backed up your system and
are prepared to face the consequences of
the requested internalization of sources,
hit Yes.  If you have any doubts, hit No
to back out with no harm done.'.

	(reply ==  true) ifFalse: [
		^ self inform: 'Okay - abandoned'].

	(aFile _ SourceFiles second) ifNil: [
		^ self halt: 'Cannot locate Changes file so cannot proceed.'].
	SourceFiles at: 2 put: (ReadWriteStream withCells: aFile contentsOfEntireFile).

	self inform: 'Okay, changes file internalized'! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50720510!
testToReverse

	| coll number |
	
	coll := ((TestIntervalAwareMagnitude withCells: 10) 
		to: (TestIntervalAwareMagnitude withCells: 20) 
		by: (TestIntervalAwareMagnitude withCells: 3)) reverse.
	number := 19.
	coll do: [ :each |
		self assert: each number = number.
		number := number - 3 ].
	
	self assert: number = 7! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50778033!
test31CanNotRenameFromKeywordOfOneParameterToBinary

	oldSelector := 'abc:def:' asSymbol.
	newSelector := '&&' asSymbol.
	classToRefactor := self createClassNamed: self classToRefactorName.
	classToRefactor compile: 'abc: p1 def: p2'.

	self 
		should: [ RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: #() ]
		raise: Error
		withMessageText: (RenameSelector errorMessageForNewSelector: newSelector isNotOfSameTypeAs: oldSelector)! !
!EqualsTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50806733 overrides: 50806558!
buildRejectApplierBefore: aPreviousCastingApplier
	
	 ^EffectiveTypeCastApplier 
		casts: OrderedCollection new
		rejections: (OrderedCollection withCells: self buildTypeReject)
		previous: aPreviousCastingApplier! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50784263!
test27MethodObjectClassInstanceCreationMessageSelectorConsistsOfTheChosenKeywords

	| refactor methodObjectClass keywordToParametrizedVariable variablesToParametrizeToInstanceVariables |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'.} asDictionary.
	keywordToParametrizedVariable := {self keyword: #with varName: 'self' paramName: 'aParamName'}.

	refactor := ExtractToMethodObject
				from: self compiledMethodReferencingSelf
				toMethodObjectClassNamed: self methodObjectClassName
				subclassing: self methodObjectSuperclass
				onCategory: self classCategoryOfTestData
				withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
				withInstanceCreationMessageFrom: keywordToParametrizedVariable
				evaluatedWith: self defaultEvaluationSelector.

	refactor apply.

	methodObjectClass := Smalltalk classNamed: self methodObjectClassName.
	self assert: (methodObjectClass class includesSelector: #withCells:).! !
!Color methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:50' prior: 50353334!
bitPatternForGrayForm
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"
	"Details: The pattern for the most recently requested depth is cached."

	^Bitmap withCells: (self pixelWordFor: 8 filledWith: (self luminance * 255) rounded)! !
!ConversionTableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50723174!
oneDollar
	
	^self dollar withCells: 1! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50747122!
testTimeTo

	self assert: (TimeOfDay firstTimeOfDay distanceTo: TimeOfDay lastTimeOfDay) = (TimeOfDay twentyFourHours - (TimeUnits millisecond withCells: 1)).
	self assert: (TimeOfDay lastTimeOfDay distanceTo: TimeOfDay firstTimeOfDay) = (TimeUnits millisecond withCells: 1)! !
!TranslucentColor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50356538 overrides: 50951670!
bitPatternForDepth: depth
	"Return an appropriate bit pattern. This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."

	self isTransparent ifTrue: [
		^ Bitmap withCells: 0].
	^ super bitPatternForDepth: depth! !
!CodeWindow methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50700746!
openSingleMessageBrowser
	| msgName mr |
	"Create and schedule a message list browser populated only by the currently selected message"

	(msgName _ model selectedMessageName) ifNil: [^ self].

	mr _ MethodReference
		class: model selectedClassOrMetaClass
		selector: msgName.

	Smalltalk
		browseMessageList: (Array withCells: mr)
		name: mr stringVersion
		autoSelect: nil! !
!FileList methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 16842599!
initialDirectoryList

	| dirList |
	dirList _ DirectoryEntry roots collect: [ :each |
		FileDirectoryWrapper with: each name: (each name ifNil: ['/']) model: self].
	dirList isEmpty ifTrue: [
		dirList _ Array withCells: (FileDirectoryWrapper 
			with: directory
			name: directory localName 
			model: self)].
	^dirList! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 16869276!
transformIfNotNilIfNil: encoder
	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we
	 transform the receiver to
		(var := receiver)
	 which is further transformed to
		(var := receiver) == nil ifTrue: .... ifFalse: ...
	 This does not allow the block variable to shadow an existing temp, but it's no different
	 from how to:do: is done."
	| ifNotNilArg |
	ifNotNilArg := arguments at: 1.
	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)
	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder maxArgs: 0]) ifFalse:
		[^false].

	ifNotNilArg numberOfArguments = 1 ifTrue:
		[receiver := AssignmentNode new
						variable: ifNotNilArg firstArgument
						value: receiver].

	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
	receiver := MessageNode new
					receiver: receiver
					selector: #==
					arguments: (Array withCells: NodeNil)
					precedence: 2
					from: encoder.
	arguments swap: 1 with: 2.
	arguments do: [:arg| arg noteOptimizedIn: self].
	^true! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 16790016!
arguments: argNodes statements: statementsCollection returns: returnBool from: encoder
	"Compile."
	arguments _ argNodes.
	statements _ statementsCollection size > 0
		ifTrue: [ statementsCollection ]
		ifFalse: [ Array withCells: NodeNil ].
	optimized _ false.
	returns _ returnBool! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50743072!
testAdd

	self assert: (januaryFirstOf2004On23Hours59Minutes59Seconds next: (TimeUnits second withCells: 1)) = januarySecondOf2004.
	self assert: (januaryFirstOf2004On23Hours59Minutes59Seconds next: (TimeUnits second withCells: 2)) = januarySecondOf2004On00Hours00Minutes01Seconds.
	self assert: (januaryFirstOf2004 next: TimeOfDay twentyFourHours) = januarySecondOf2004.
	self assert: (januaryFirstOf2004 next: (TimeUnits second withCells: -1)) = december31Of2003On23Hours59Minutes59Seconds.
	self assert: (januaryFirstOf2004On23Hours59Minutes59Seconds next: TimeOfDay twentyFourHours negated) = december31Of2003On23Hours59Minutes59Seconds! !
!SimpleMeasureTest class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50728305 overrides: 16927631!
resources

	^Array withCells: UnitsTestResource! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50949561!
test01
	
	| aGameOfLife aCell |
	
	aCell _ Cell new .
	
	aGameOfLife _ GameOfLife withCells: #( aCell ) .
		
	self assert: (aGameOfLife stateOf: aCell) equals: #Died! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50738580!
fromTime: aTime

	^self timeFromMidnight: (TimeUnits millisecond withCells: aTime asMilliseconds)! !
!SmalltalkEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 16910169!
explainClass: symbol 
	"Is symbol a class variable or a pool variable?"
	| provider class reply classes |
	provider _ self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass)
		ifFalse: [^ nil].
	(class _ provider selectedClassOrMetaClass) ifNil: [^ nil].
	"no class is selected"
	(class isKindOf: Metaclass)
		ifTrue: [class _ class soleInstance].
	classes _ (Array withCells: class)
				, class allSuperclasses.
	"class variables"
	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]
					ifNone: nil)
					notNil]
				ifNone: nil.
	reply ifNotNil: [
		^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a class variable, defined in class ';
				nextPutAll: reply printString, '\' withNewLines;
				nextPutAll: 'Smalltalk browseAllCallsOn: (';
				nextPutAll: reply printString;
				nextPutAll: ' classPool associationAt: #';
				nextPutAll: symbol;
				nextPutAll: ').']].
	"pool variables"
	classes do: [:each | (each sharedPools
			detect: [:pool | (pool includesKey: symbol)
					and: 
						[reply _ pool.
						true]]
			ifNone: nil)
			notNil].
	reply
		ifNil: [(Undeclared includesKey: symbol)
				ifTrue: [
					^ String streamContents: [:str |
						str
							nextPutAll: symbol;
							nextPutAll: ' is an undeclared variable.';
							nextPutAll: 'Smalltalk browseAllCallsOn: (Undeclared associationAt: #';
							nextPutAll: symbol;
							nextPutAll: ').']]]
		ifNotNil: 
			[classes _ WriteStream on: Array new.
			Smalltalk
				allBehaviorsDo: [:each | (each sharedPools
						detect: 
							[:pool | 
							pool == reply]
						ifNone: nil)
						notNil ifTrue: [classes nextPut: each]].
			"Perhaps not print whole list of classes if too long. (unlikely)"
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a pool variable from the pool ';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asString;
					nextPutAll: ', which is used by the following classes ';
					nextPutAll: classes contents printString , '\' withNewLines;
					nextPutAll: 'Smalltalk browseAllCallsOn: (';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asString;
					nextPutAll: ' bindingOf: #';
					nextPutAll: symbol;
					nextPutAll: ').']].
	^ nil! !
!PopUpMenu methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50629212!
startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skip: -1])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines _ allLabels size.
	lineArray ifNil: [lineArray _ Array new].
	nLinesPer _ segmentHeight // Preferences standardMenuFont lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines _ (Array withCells: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50777487!
test11NewImplementorsKeepMethodCategory
	
	| rename oldSelectorCategory |
	
	oldSelectorCategory := 'oldSelectorCategory'.
	self createClassToRefactor.
	classToRefactor organization classify: oldSelector under: oldSelectorCategory.
		
	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>senderOfOldSelector).
	rename apply.
	
	self assert: oldSelectorCategory equals: (classToRefactor organization categoryOfElement: newSelector)
! !
!ReturnTypeInfoTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50800426!
assertReturnTypeOf: aSelector is: aType

	self assertReturnTypeOf: aSelector are: (Array withCells: aType)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50747012!
testLastTimeOfDay

	self assert: TimeOfDay lastTimeOfDay = (TimeOfDay timeFromMidnight: (
		(TimeUnits hour withCells: 23) + 
		(TimeUnits minute withCells: 59) + 
		(TimeUnits second withCells: 59) + 
		(TimeUnits millisecond withCells: 999)))! !
!RunArray methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 16901335 overrides: 16906162!
copyFrom: start to: stop
	| newRuns run1 run2 offset1 offset2 answer | 
	stop < start ifTrue: [
		answer _ RunArray new.
		answer canJoinMessage: canJoinMessage.
		^answer ].
	self at: start setRunOffsetAndValue: [ :r :o :value1 |
		run1 _ r.
		offset1 _ o. 
		value1 ].
	self at: stop setRunOffsetAndValue: [ :r :o :value2 |
		run2 _ r.
		offset2 _ o.
		value2].
	run1 = run2
		ifTrue: [
			newRuns _ Array withCells: offset2 - offset1 + 1]
		ifFalse: [
			newRuns _ runs copyFrom: run1 to: run2.
			newRuns at: 1 put: (newRuns at: 1) - offset1.
			newRuns at: newRuns size put: offset2 + 1 ].
	answer _ RunArray runs: newRuns values: (values copyFrom: run1 to: run2).
	answer canJoinMessage: canJoinMessage.
	^answer! !
!ConversionTableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50723182!
onePeso

	^self peso withCells: 1! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50746306!
testInvalidNextANumberOfYears

	| anyUnit |
	
	anyUnit := BaseUnit named: 'Any Unit'.
	
	self should: [ (GregorianYear number: 2004) next: 1] raise: CanNotConvertMeasureException.
	self should: [ (GregorianYear number: 2004) next: (anyUnit withCells: 1) ] raise: CanNotConvertMeasureException.
	! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50558565!
xTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by x-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice countBlt copyBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: 1@height.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: 1 @ slice height
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap withCells: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: width-1) collect: [ :x |
		copyBlt sourceOrigin: x@0; copyBits.
		countBlt copyBits]! !
!ClassBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 16803468!
silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName
	"Move the instvar from srcClass to dstClass.
	Do not perform any checks."
	| srcVars dstVars dstIndex newClass copyOfSrcClass copyOfDstClass |
	copyOfSrcClass _ srcClass copy.
	copyOfDstClass _ dstClass copy.
	
	srcVars _ srcClass instVarNames copyWithout: instVarName.
	srcClass == dstClass
		ifTrue:[dstVars _ srcVars]
		ifFalse:[dstVars _ dstClass instVarNames].
	dstIndex _ dstVars indexOf: prevInstVarName.
	dstVars _ (dstVars copyFrom: 1 to: dstIndex),
				(Array withCells: instVarName),
				(dstVars copyFrom: dstIndex+1 to: dstVars size).
	instVarMap at: srcClass name put: srcVars.
	instVarMap at: dstClass name put: dstVars.
	(srcClass inheritsFrom: dstClass) ifTrue:[
		newClass _ self reshapeClass: dstClass toSuper: dstClass superclass.
		self recompile: false from: dstClass to: newClass mutate: true.
	] ifFalse:[
		(dstClass inheritsFrom: srcClass) ifTrue:[
			newClass _ self reshapeClass: srcClass toSuper: srcClass superclass.
			self recompile: false from: srcClass to: newClass mutate: true.
		] ifFalse:[ "Disjunct hierarchies"
			srcClass == dstClass ifFalse:[
				newClass _ self reshapeClass: dstClass toSuper: dstClass superclass.
				self recompile: false from: dstClass to: newClass mutate: true.
			].
			newClass _ self reshapeClass: srcClass toSuper: srcClass superclass.
			self recompile: false from: srcClass to: newClass mutate: true.
		].
	].
	self doneCompiling: srcClass.
	self doneCompiling: dstClass.
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfSrcClass to: srcClass.
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfDstClass to: dstClass.! !
!DynamicallyCodeCreationTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50771397!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData ! !
!ChangeEvent methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50826266!
minutesAsString: timeDifference
	| inMinutes |
	
	timeDifference > (TimeUnits minute withCells: 1) 
		ifTrue: [ inMinutes := ((timeDifference convertTo: TimeUnits minute) floor) amount. ]
		ifFalse: [ inMinutes := 0 ].
		
	^ String streamContents: [ :aStream | inMinutes printOn: aStream integerDigits: 2 fractionDigits: 0 ]! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50745497!
testNumberOfMonthsPerYear

	self assert: GregorianMonth numberOfMonthsPerYear = (TimeUnits month withCells: 12)! !
!CharacterSetTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:51' prior: 50762372!
testIncludesReturnsTrueForCharacterIncluded

	self assert: ((CharacterSet withCells: $a) includes: $a)! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50777548!
test14RenamesSymbolsEqualToOldSelector

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString.
	classToRefactor compile: referencerToOldSelector asString , ' #' , oldSelector asString, ' size'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector) 
! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50732553!
multiplyByUnit: aUnit

	^aUnit withCells: self! !
!Float64Array class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 16846385 overrides: 16883149!
initialize
	"
	Float64Array initialize
	"
	LastSaveOrder _ self withCells: 1.0! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50742867!
testPreviousInNumberOfDays

	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 11) previous: self tenDays) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 31) previous: self thirtyDays) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 1) previous: self thirtyOneDays) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1).

	self assert: ((FixedGregorianDate yearNumber: 2005 monthNumber: 1 dayNumber: 1) previous: (TimeUnits day withCells: 366)) = 
						(FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) previous: (TimeUnits day withCells: 365)) = 
						(FixedGregorianDate yearNumber: 2003 monthNumber: 1 dayNumber: 1).
						
! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50784228!
test26MethodObjectClassInstanceCreationMessageReceivesTheSameNumberOfArgumentsAsVariablesToParametrizeInMethodToExtract

	| refactor methodObjectClass keywordToParametrizedVariable variablesToParametrizeToInstanceVariables |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'.} asDictionary.
	keywordToParametrizedVariable := {self keyword: #with varName: 'self' paramName: 'aParamName'}.

	refactor := ExtractToMethodObject
				from: self compiledMethodReferencingSelf
				toMethodObjectClassNamed: self methodObjectClassName
				subclassing: self methodObjectSuperclass
				onCategory: self classCategoryOfTestData
				withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
				withInstanceCreationMessageFrom: keywordToParametrizedVariable
				evaluatedWith: self defaultEvaluationSelector.

	refactor apply.

	methodObjectClass := Smalltalk classNamed: self methodObjectClassName.
	self assert: (methodObjectClass class selectors anySatisfy: [:aSelector | aSelector = #withCells:]).! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50736700!
initializeZeroDays

	ZeroDays := TimeUnits day withCells: 0! !
!CharacterSetTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50762366!
testIncludesReturnsFalseForObjectsThatAreNotCharacters

	self deny: ((CharacterSet withCells: $a) includes: 1)! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50772157!
test09FailsWhenNewVariableEqualsTemporaryVariableOfAMethodInClass

	| selector classToRefactor |

	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName.
	selector := #m1.
	classToRefactor compile: selector, ' | ', newVariable, ' | ', newVariable, ' := 10.'.
	
	self 
		assertCreation: [ AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50741951!
testNumberOfDaysFromBeginningOfMonth

	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) numberOfDaysFromBeginningOfMonth = (TimeUnits day withCells: 0).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 31) numberOfDaysFromBeginningOfMonth = (TimeUnits day withCells: 30).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 29) numberOfDaysFromBeginningOfMonth = (TimeUnits day withCells: 28).
	
	
	
! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50737385!
initializeTwoMonth

	TwoMonths := TimeUnits month withCells: 2! !
!RunArray class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 16901513!
new: size withAll: value 
	"Answer a new instance of me, whose every element is equal to the
	argument, value."

	size = 0 ifTrue: [^self new].
	^self runs: (Array withCells: size) values: (Array withCells: value)! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50724969!
testFloatMultipliedByUnit

	self assert: (5.5 * meterBySecond) = (meterBySecond withCells: 5.5).
	self assert: (5.5 * meterBySecond) numerator = (meterBySecond withCells: 5.5 numerator).
	self assert: (5.5 * meterBySecond) denominator = 5.5 denominator! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50744186!
testPreviousInANumberOfDays

	self assert: (GregorianDay monday previous: GregorianDay oneDay)=GregorianDay sunday.
	self assert: (GregorianDay monday previous: GregorianDay twoDays)=GregorianDay saturday.
	self assert: (GregorianDay monday previous: (TimeUnits day withCells: 6))=GregorianDay tuesday.
	self assert: (GregorianDay monday previous: GregorianDay sevenDays)=GregorianDay monday.
	self assert: (GregorianDay sunday previous: (TimeUnits day withCells: 6))=GregorianDay monday.
	self assert: (GregorianDay sunday previous: (TimeUnits day withCells: 7))=GregorianDay sunday.
	self assert: (GregorianDay sunday previous: (TimeUnits day withCells: 14))=GregorianDay sunday.
	self assert: (GregorianDay saturday previous: (TimeUnits day withCells: 6))=GregorianDay sunday.
	self assert: (GregorianDay saturday previous: (TimeUnits day withCells: 7))=GregorianDay saturday.
	self assert: (GregorianDay saturday previous: (TimeUnits day withCells: 14))=GregorianDay saturday.
! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50575357!
isAnyPixel: pv
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv.
	Based on #yTallyPixelValue:orNot:
	Form lena isAnyPixel: 0
	Form lena isAnyPixel: 100
	"
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap withCells: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	(0 to: height-1) do: [ :y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits > 0 ifTrue: [ ^ true ]].
	^ false! !
!BMPReadWriter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 16781827!
readIndexedBmpFile: colors
	"Read uncompressed pixel data of depth d from the given BMP stream, where d is 1, 4, 8, or 16"
	| form bytesPerRow pixelData pixelLine startIndex map bitBlt mask |
	colors 
		ifNil:[form := Form extent: biWidth@biHeight depth: biBitCount]
		ifNotNil:[form := ColorForm extent: biWidth@biHeight nativeDepthFrom: biBitCount.
				form colors: colors].
	bytesPerRow := (((biBitCount* biWidth) + 31) // 32) * 4.
	pixelData := ByteArray new: bytesPerRow * biHeight.
	biHeight to: 1 by: -1 do: [:y |
		pixelLine := stream next: bytesPerRow.
		startIndex := ((y - 1) * bytesPerRow) + 1.
		pixelData 
			replaceFrom: startIndex 
			to: startIndex + bytesPerRow - 1 
			with: pixelLine 
			startingAt: 1].
	form copyFromByteArray: pixelData.
	biBitCount = 16 ifTrue:[
		map := ColorMap shifts: #(8 -8 0 0) masks: #(16rFF 16rFF00 0 0).
		mask := 16r80008000.
	].
	biBitCount = 32 ifTrue:[
		map := ColorMap shifts: #(24 8 -8 -24) masks: #(16rFF 16rFF00 16rFF0000 16rFF000000).
		mask := 16rFF000000.
	].
	map ifNotNil:[
		bitBlt := BitBlt toForm: form.
		bitBlt sourceForm: form.
		bitBlt colorMap: map.
		bitBlt combinationRule: Form over.
		bitBlt copyBits.
	].
	mask ifNotNil:[
		bitBlt := BitBlt toForm: form.
		bitBlt combinationRule: 7 "bitOr:with:".
		bitBlt fillBitmap: (Bitmap withCells: mask).
		bitBlt copyBits.
	].
	^ form
! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50729226!
numeratorOf: aNumber

	^self numerator withCells: aNumber numerator! !
!GregorianYear methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50738253 overrides: 50735677!
distanceTo: aGregorianYear 
	
	| difference |
	difference := aGregorianYear number - self number.
	self number < 0 
		ifTrue: [aGregorianYear number > 0 ifTrue: [difference := difference - 1]]
		ifFalse: [aGregorianYear number < 0 ifTrue: [difference := difference + 1]].
	^TimeUnits year withCells: difference! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50720832!
testCreateGraphWithUnconnectedNodes

	| nodes graph edge |

	nodes := Set with: 'a' with: 'b' with: 'c'.
	edge := Edge from: 'a' to: 'b'.

	graph := Graph edges: (Set withCells: edge) nodes: nodes.

	self
		assert: graph nodes size = nodes size;
		assert: (graph nodes includesAllOf: nodes);
		assert: (graph edges allSatisfy: [:each | each = edge]);
		assert: (graph nodesWithoutConvergingEdges includes: 'a');
		assert: (graph nodesWithoutConvergingEdges includes: 'c');
		assert: (graph nodesWithoutStartingEdges includes: 'c')! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 16868317!
printWithClosureAnalysisIfOn: aStream indent: level

	receiver ifNotNil:
		[receiver printWithClosureAnalysisOn: aStream indent: level + 1 precedence: precedence].
	(arguments last isJust: NodeNil) ifTrue:
		[^self printWithClosureAnalysisKeywords: #ifTrue: arguments: (Array withCells: arguments first)
					on: aStream indent: level].
	(arguments last isJust: NodeFalse) ifTrue:
		[^self printWithClosureAnalysisKeywords: #and: arguments: (Array withCells: arguments first)
					on: aStream indent: level].
	(arguments first isJust: NodeNil) ifTrue:
		[^self printWithClosureAnalysisKeywords: #ifFalse: arguments: (Array withCells: arguments last)
					on: aStream indent: level].
	(arguments first isJust: NodeTrue) ifTrue:
		[^self printWithClosureAnalysisKeywords: #or: arguments: (Array withCells: arguments last)
					on: aStream indent: level].
	self printWithClosureAnalysisKeywords: #ifTrue:ifFalse: arguments: arguments
					on: aStream indent: level! !
!SpecificDayRuleTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50740534!
testAccessing

	| rule decoratedRule |

	decoratedRule := Array withCells: GregorianDay friday.
	rule := SpecificDayRule rule: decoratedRule.

	self assert: rule decoratedRule = decoratedRule.
	self assert: rule printString = decoratedRule printString! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 16798004!
noteClassStructure: aClass
	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."

	| clsName |
	aClass ifNil: [^ self].
	structures ifNil: [structures _ Dictionary new.
				superclasses _ Dictionary new].
	clsName _ (aClass name asLowercase beginsWith: 'anobsolete') 
		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]
		ifFalse: [aClass name].
	(structures includesKey: clsName) ifFalse: [
		structures at: clsName put: 
			((Array withCells: aClass classVersion), (aClass allInstVarNames)).
		superclasses at: clsName put: aClass superclass name].
	"up the superclass chain"
	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].
! !
!SafelyRemoveClassTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50778559!
test06WarnIfClassToRemoveHasSubclasses

	| classToRemove classToRemoveSubclass | 
	
	classToRemove := self createClassNamed: self classToRemoveName.
	classToRemoveSubclass := self createClassNamed: 'ClassToRemoveSubclass' asSymbol subclassOf: classToRemove.
	
	self 
		assertCreation: [ SafelyRemoveClass of: classToRemove ]
		warnsWith: [ SafelyRemoveClass warningMessageFor: classToRemove hasSubclasses: (Array withCells: classToRemoveSubclass) ]! !
!DenotativeObjectDebugger methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50814532 overrides: 50689447!
askForCategoryIn: aClass default: aString

	| categories index category |
	
	categories := OrderedCollection withCells: 'new ...'. 
	categories addAll: (aClass allMethodCategoriesIntegratedThrough: aClass).	
	index := PopUpMenu withCaption: 'Please provide a good category for the new method!!'
						chooseFrom: categories.
	index = 0 ifTrue: [^ aString].
	category := index = 1 ifTrue: [FillInTheBlankMorph request: 'Enter category name:']
						ifFalse: [categories at: index].
	^ category isEmpty ifTrue: [aString] ifFalse: [category]! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50720443!
testNotInclusiveBetweenAndNotInclusive

	self assert: ((TestIntervalAwareMagnitude withCells: 1) notInclusiveBetween: (TestIntervalAwareMagnitude withCells: 0) andNotInclusive: (TestIntervalAwareMagnitude withCells: 2)).
	self deny: ((TestIntervalAwareMagnitude withCells: 1) notInclusiveBetween: (TestIntervalAwareMagnitude withCells: 1) andNotInclusive: (TestIntervalAwareMagnitude withCells: 2)).
	self deny: ((TestIntervalAwareMagnitude withCells: 1) notInclusiveBetween: (TestIntervalAwareMagnitude withCells: 0) andNotInclusive: (TestIntervalAwareMagnitude withCells: 1))! !
!TypeCheckingError methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50807417 overrides: 50807356!
sourceCodeRange
	
	^Array withCells: (methodNode rangeForNode: messageNode ifAbsent: [^#()])! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50743707!
testNextANumberOfDays

	self assert: ((GregorianDayOfMonth monthNumber: 12 dayNumber: 31) next: (TimeUnits day withCells: 7)) = (GregorianDayOfMonth monthNumber: 1 dayNumber: 7).
	self assert: ((GregorianDayOfMonth monthNumber: 2 dayNumber: 29) next: (TimeUnits day withCells: 7)) = (GregorianDayOfMonth monthNumber: 3 dayNumber: 7).

	self assert: ((GregorianDayOfMonth monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: -1)) = (GregorianDayOfMonth monthNumber: 12 dayNumber: 31).
	self assert: ((GregorianDayOfMonth monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: -32)) = (GregorianDayOfMonth monthNumber: 11 dayNumber: 30)! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:52' prior: 50737376!
initializeThreeMonths

	ThreeMonths := TimeUnits month withCells: 3! !
!GregorianYear class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50738373!
initializeZeroYears

	ZeroYears := TimeUnits year withCells: 0! !
!MeasureConverterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50724276!
testSameDomainConversion

	| cents |
	
	cents := ProportionalDerivedUnit baseUnit: self peso conversionFactor: 1/100 named: 'cent'.
	
	self assert: (moneyConverter convert: self onePeso to: self peso) = self onePeso.
	self assert: (moneyConverter convert: self onePeso to: cents) = (cents withCells: 100)! !
!MinusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50724725!
testSameUnitAs

	self assert: (minusInfinity sameUnitAs: 1).
	self deny: (minusInfinity sameUnitAs: ((BaseUnit named: 'peso') withCells: 1))! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50742901!
testPreviousInWeeks

	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) previous: (TimeUnits week withCells: 1)) = 
						((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) previous: (TimeUnits day withCells: 7)).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) previous: (TimeUnits week withCells: 2)) = 
						((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) previous: (TimeUnits day withCells: 14)).
						
! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50747088!
testToNegativeByDo

	| interval time |
	
	interval := (TimeOfDay hours: 23 minutes: 30) to: TimeOfDay firstTimeOfDay by: (TimeUnits minute withCells: -30).
	time := (TimeUnits hour withCells: 23) + (TimeUnits minute withCells: 30).
	interval do: [ :aTimeOfDay |
		self assert: aTimeOfDay = (TimeOfDay timeFromMidnight: time).
		time := time - (TimeUnits minute withCells: 30) ].
	
	self assert: time = (TimeUnits minute withCells: -30)! !
!ScannerTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50766543!
testLiteralSymbols

	self assert: ('*+-/\~=<>&@%,|' allSatisfy: [:char | Scanner isLiteralSymbol: (String withCells: char) asSymbol])
		description: 'single letter binary symbols can be printed without string quotes'.
		
	self assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | Scanner isLiteralSymbol: str asSymbol])
		description: 'valid ascii selector symbols can be printed without string quotes'.
		
	((32 to: 94), (96 to: 126) collect: [:ascii | Character numericValue: ascii]) ,
	#(':x:yourself' '::' 'x:yourself' '123' 'x0:x1:x2:' 'x.y.z' '1abc' 'a1b0c2' ' x' 'x ' '+x-y' '||' '-' '++' '+' '+/-' '-/+' '<|>' '#x' '()' '[]' '{}' '')
		do: [:str |
			self assert: (Compiler evaluate: str asSymbol printString) = str asSymbol
				description: 'in all case, a Symbol must be printed in an interpretable fashion']! !
!Rectangle methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 16898839!
rectanglesAt: y
	(y+1) > self bottom ifTrue: [^ Array new].
	^ Array withCells: (origin x @ y corner: corner x @ (y+1))! !
!PlusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50725993!
testEqualsCompoundMeasure

	| measureBag |

	measureBag := ((BaseUnit named: 'peso') withCells: 5) + ((BaseUnit named: 'dollar') withCells: 5).
	self assert: (infinity equalsCompoundMeasure: infinity).
	self deny: (infinity equalsCompoundMeasure: measureBag)! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50736662!
initializeThirtyDays

	ThirtyDays := TimeUnits day withCells: 30! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50777507!
test12RenamesRecursiveMethodsWhenNotInSenders

	| rename senderMethod |
	
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString , ' self ' , oldSelector asString.
		
	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: #().
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: newSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector)
! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50744310!
thirteenMonths

	^TimeUnits month withCells: 13! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50783691!
test06AllVariablesToParametrizeMustHaveACorrespondingMethodObjectInstanceVariableName

	| namesForParametrizedMissingSelf keywordToParametrizedVariable variablesToParametrizeWithoutInstVarName |

	namesForParametrizedMissingSelf := #() asDictionary.
	keywordToParametrizedVariable := { self keyword: #with varName: 'self' paramName: 'aParameterName'. }.
	variablesToParametrizeWithoutInstVarName := Set withCells: 'self'.

	self
		creationWithExtractedVariablesToInstanceVariables: namesForParametrizedMissingSelf
		withInstanceCreationMessageFrom: keywordToParametrizedVariable
		failsWithMessageText: [ ExtractToMethodObject
			variablesToParametrizedDoNotHaveInstanceVariableNamesErrorMessage: variablesToParametrizeWithoutInstVarName].! !
!IfNilChecksFinderTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50785940 overrides: 50953830!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData ! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50880592!
test31SubstractingFraccionesCanReturnAnEntero

	| threeHalfs |
	
	threeHalfs := (Entero withCells: 3) / (Entero withCells: 2).
	
	self assert: threeHalfs - oneHalf equals: one.! !
!VariableToParametrizeKeywordDefinitionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50788784 overrides: 50953830!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData ! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50737348!
initializeFourMonth

	FourMonths := TimeUnits month withCells: 4! !
!WordArray class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 16945304!
bobsTest
	| wa s1 s2 wa2 answer rawData |
"
WordArray bobsTest
"
	answer _ OrderedCollection new.
	wa _ WordArray with: 16r01020304 with: 16r05060708.
	{false. true} do: [ :pad |
		0 to: 3 do: [ :skip |
			s1 _ ReadWriteStream on: ByteArray new.

			s1 next: skip put: 0.		"start at varying positions"
			wa writeOn: s1.
			pad ifTrue: [s1 next: 4-skip put: 0].	"force length to be multiple of 4"

			rawData _ s1 contents.
			s2 _ ReadWriteStream withCells: rawData.
			s2 reset.
			s2 skip: skip.			"get to beginning of object"
			wa2 _ WordArray newFromStream: s2.
			answer add: {
				rawData size. 
				skip. 
				wa2 = wa. 
				wa2 asArray collect: [ :each | each printStringBase: 16]
			}
		].
	].
	^answer explore! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50724855!
testDivideByFloat

	self assert: (meterBySecond / 5.5) = (meterBySecond withCells: 1/5.5).
	self assert: (meterBySecond / 5.5) numerator = (meterBySecond withCells: (1/5.5) numerator).
	self assert: (meterBySecond / 5.5) denominator = (1/5.5) denominator! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50724954!
testFloatDividedByUnitTwice

	| kelvin |
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5.5 / kelvin / meterBySecond) = (5.5 / (kelvin * meterBySecond withCells: 1)).
	self assert: (5.5 / kelvin / meterBySecond) numerator = 5.5 numerator.
	self assert: (5.5 / kelvin / meterBySecond) denominator = (kelvin * meterBySecond withCells: 5.5 denominator)! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50725081!
testMultiplyByInteger

	self assert: (meterBySecond * 5) = (meterBySecond withCells: 5).
	self assert: (meterBySecond * 5) numerator = (meterBySecond withCells: 5).
	self assert: (meterBySecond * 5) denominator = 1.
! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50741969!
testNumberOfDaysFromJanuaryFirst

	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) numberOfDaysFromJanuaryFirst = (TimeUnits day withCells: 0).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 31) numberOfDaysFromJanuaryFirst = (TimeUnits day withCells: 30).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 12 dayNumber: 31) numberOfDaysFromJanuaryFirst = (TimeUnits day withCells: 365).
	
	
	
! !
!Metaclass methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 16870958 overrides: 16784040!
allInstances
	thisClass class == self ifTrue:[^Array withCells: thisClass].
	^super allInstances! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50742003!
testNumberOfDaysToEndOfYear

	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) numberOfDaysToEndOfYear = (TimeUnits day withCells: 365).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 12 dayNumber: 31) numberOfDaysToEndOfYear = (TimeUnits day withCells: 0).
	
	
	
! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50721379!
testDivideByInfinity

	| kelvin |

	kelvin := BaseUnit named: 'kelvin'.
	self assert: kelvin / infinity = (kelvin withCells: 1 / infinity).
	self assert: (kelvin / infinity) numerator = 0.
	self assert: (kelvin / infinity) denominator = 1.
	self
		should: [infinity / kelvin]
		raise: IndeterminateOperationException
		withExceptionDo: [:anException |
			self assert:
				anException description =
					'The Division operation is indeterminate between Infinity and kelvin']! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50777182!
test19FailsWhenNewVariableIsHiddenInAnyMethodOfAnySubclass

	| selector subclass |

	self createClassToRefactor.
	subclass := self createClassNamed: #SubclassOfClassToRefactor subclassOf: classToRefactor.
	selector := #m1.
	subclass compile: selector, ' | ', newVariable, ' | '.
	
	self 
		assertCreation: [ RenameInstanceVariable from: oldVariable to: newVariable in: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (subclass>>selector)) ].
	! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50720474!
testToBy

	| interval |
	
	interval := (TestIntervalAwareMagnitude withCells: 10) to: (TestIntervalAwareMagnitude withCells: 20) by: (TestIntervalAwareMagnitude withCells: 5).

	self assert: interval from = (TestIntervalAwareMagnitude withCells: 10).
	self assert: interval to = (TestIntervalAwareMagnitude withCells: 20).
	self assert: interval by = (TestIntervalAwareMagnitude withCells: 5)! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50741518!
twoDays
	
	^TimeUnits day withCells: 2! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 16923215!
internalizeSources
		"
		Smalltalk internalizeSources
		"
	"Bring the sources and changes files into memory-resident filestreams, for faster access and freedom from file-system interface.  1/29/96 sw"

	| reply aFile |
	reply _ self confirm:  'CAUTION -- do not undertake this lightly!!
If you have backed up your system and
are prepared to face the consequences of
the requested internalization of sources,
hit Yes.  If you have any doubts, hit No
to back out with no harm done.'.

	(reply ==  true) ifFalse: [
		^ self inform: 'Okay - abandoned'].

	(aFile _ SourceFiles first) ifNil: [
		^ self halt: 'Cannot locate Sources file so cannot proceed.'].
	SourceFiles at: 1 put: (ReadWriteStream withCells: aFile contentsOfEntireFile).

	(aFile _ SourceFiles last) ifNil: [
		^ self halt: 'Cannot locate Changes so cannot proceed.'].
	SourceFiles at: 2 put: (ReadWriteStream withCells: aFile contentsOfEntireFile).

	self inform: 'Okay, sources internalized'! !
!Browser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 16792815!
systemCategorySingleton

	^ selectedSystemCategory
		ifNil: [#()]
		ifNotNil: [Array withCells: selectedSystemCategory]! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 50736657!
initializeSevenDays

	SevenDays := TimeUnits day withCells: self amountOfDaysPerWeek! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:53' prior: 16869097!
toDoFromWhileWithInit: initStmt
	"Return nil, or a to:do: expression equivalent to this whileTrue:"
	| variable increment limit toDoBlock body test |
	(selector key == #whileTrue:
	 and: [initStmt isAssignmentNode
	 and: [initStmt variable isTemp]]) ifFalse:
		[^nil].
	body := arguments last statements.
	variable := initStmt variable.
	increment := body last toDoIncrement: variable.
	(increment == nil
	 or: [receiver statements size ~= 1]) ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test chould really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])
		ifTrue: [^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: (Array withCells: variable).
	variable scope: -1.
	variable beBlockArg.
	^MessageNode new
		receiver: initStmt value
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: (Array with: limit with: increment with: toDoBlock)
		precedence: precedence! !
!Preference methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 16892733!
name: aName defaultValue: aValue helpString: aString categoryList: aList changeInformee: informee changeSelector:  aChangeSelector
	"Initialize the preference from the given values.  There is an extra tolerence here for the symbols #true, #false, and #nil, which are interpreted, when appropriate, as meaning true, false, and nil"

	name _ aName asSymbol.
	defaultValue _ aValue.
	defaultValue = #true ifTrue: [ defaultValue _ true ].
	defaultValue = #false ifTrue: [ defaultValue _ false ].
	value _ defaultValue.
	helpString _ aString.
	categoryList _ (aList ifNil: [OrderedCollection withCells: #unclassified]) collect:
		[:elem | elem asSymbol].

	changeInformee _ (informee == nil or: [informee == #nil])
						ifTrue: [nil]
						ifFalse:	[(informee isSymbol)
							ifTrue: [
								Smalltalk at: informee]
							ifFalse: [
								informee]].
	changeSelector  _ aChangeSelector! !
!ConversionTableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50723178!
oneHundredCents

	^self cents withCells: 100! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50746973!
testInvalidCreation

	self 
		should: [ TimeOfDay timeFromMidnight: (TimeUnits hour withCells: 24) ] 
		raise: InvalidTimeOfDayException
		withExceptionDo: [:anException |
			self assert: anException time = (TimeUnits hour withCells: 24).
			self assert: anException description = 'The time 24 hours is invalid for one day' ].
		
	self 
		should: [ TimeOfDay timeFromMidnight: (TimeUnits millisecond withCells: -1) ] 
		raise: InvalidTimeOfDayException
		withExceptionDo: [:anException |
			self assert: anException time = (TimeUnits millisecond withCells: -1).
			self assert: anException description = 'The time -1 millisecond is invalid for one day' ]! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50744160!
testNextInANumberOfDays

	self assert: (GregorianDay monday next: GregorianDay oneDay)=GregorianDay tuesday.
	self assert: (GregorianDay monday next: GregorianDay twoDays)=GregorianDay wednesday.
	self assert: (GregorianDay monday next: (TimeUnits day withCells: 6))=GregorianDay sunday.
	self assert: (GregorianDay monday next: GregorianDay sevenDays)=GregorianDay monday.
	self assert: (GregorianDay monday next: (TimeUnits day withCells: 14))=GregorianDay monday.
	self assert: (GregorianDay sunday next: (TimeUnits day withCells: 21))=GregorianDay sunday.
! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50731879!
floor
	
	^unit withCells: amount floor! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50738665!
initializeTwentyFourHours

	twentyFourHours := TimeUnits hour withCells: 24! !
!Transcripter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50561862!
white
	Display depth = 1 ifTrue: [^ Bitmap withCells: 0 "Works without color support"].
	^ `Color white`! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50723702!
testFloatMultipliedByUnit

	self assert: (5.5 * meterOverSecond) = (meterOverSecond withCells: 5.5).
	self assert: (5.5 * meterOverSecond) numerator = (meter withCells: 5.5 numerator).
	self assert: (5.5 * meterOverSecond) denominator = (second withCells: 5.5 denominator)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50747113!
testTimeFromMidnight

	self assert: TimeOfDay firstTimeOfDay timeFromMidnight = (TimeUnits hour withCells: 0).
	self assert: TimeOfDay lastTimeOfDay timeFromMidnight = (TimeOfDay twentyFourHours - (TimeUnits millisecond withCells: 1))! !
!String class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 16917892!
newLineString
	"Answer a string containing a single newLine (i.e. Lf) character."

	^ self withCells: Character newLineCharacter! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 16795624!
removeCategory: cat 
	"Remove the category named, cat. Create an error notificiation if the 
	category has any elements in it."

	| index lastStop |
	index _ categoryArray indexOf: cat ifAbsent: [^self].
	lastStop _ 
		index = 1
			ifTrue: [0]
			ifFalse: [categoryStops at: index - 1].
	(categoryStops at: index) - lastStop > 0 
		ifTrue: [^self error: 'cannot remove non-empty category'].
	categoryArray _ categoryArray copyReplaceFrom: index to: index with: Array new.
	categoryStops _ categoryStops copyReplaceFrom: index to: index with: Array new.
	categoryArray size = 0
		ifTrue:
			[categoryArray _ Array withCells: Default.
			categoryStops _ Array withCells: 0]
! !
!ReferencesExplorer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 16900242 overrides: 16883201!
getList

	| wrapper |
	wrapper _ ReferencesExplorerWrapper
		with: self finder rootNode object
		name: self rootObject identityHash asString
		model: self finder rootNode.
	wrapper finderSkipsClasses: self finder skipClasses.
	^Array withCells: wrapper! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50729271!
divideInfinity: anInfinity

	^((NullUnit new / self) * anInfinity unit) withCells: anInfinity amount! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50720389!
testHash

	self assert: (TestIntervalAwareMagnitude withCells: 10) hash = (TestIntervalAwareMagnitude withCells: 10) hash! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50723802!
testMultiplyByFloat

	self assert: (meterOverSecond * 5) = (meterOverSecond withCells: 5).
	self assert: (meterOverSecond * 5) numerator = (meter withCells: 5).
	self assert: (meterOverSecond * 5) denominator = (second withCells: 1).
! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50744218!
testSinceSunday

	| currentDay |
	
	currentDay := GregorianDay sunday.
	(GregorianDay zeroDays to: (TimeUnits day withCells:6)) do: [:aNumberOfDays |
		self assert: (GregorianDay sinceSunday: aNumberOfDays)=currentDay.
		currentDay := currentDay next ]! !
!BlockNode class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 16790078!
withJust: aNode
	^ self new statements: (Array withCells: aNode) returns: false! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50787396!
replacementParametersFrom: aSourceCode usingAsClassToRefactor: aClass

	| messageNode methodNode definitions |

	aClass compile: 'm1 ', aSourceCode.
	methodNode := (aClass compiledMethodAt: #m1) methodNode.
	messageNode := methodNode block statements first.
	definitions :=
		VariablesToParametrizeKeywordsDefinitions
			withCells: {VariableToParametrizeKeywordDefinition
				forVariable: self defaultInstVarName
				useKeyword: #with
				withParameterName: 'paramName'}.

	^ReplaceIfNilWithPolymorphismParameters
		forIfNilMessageSending: messageNode
		onMethod: methodNode
		useKeywordsDefinitions: definitions.! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 16795677!
removeEmptyCategories
	"Remove empty categories."

	| categoryIndex currentStop keptCategories keptStops |
	keptCategories _ WriteStream on: (Array new: 16).
	keptStops _ WriteStream on: (Array new: 16).
	currentStop _ categoryIndex _ 0.
	[(categoryIndex _ categoryIndex + 1) <= categoryArray size]
		whileTrue: 
			[(categoryStops at: categoryIndex) > currentStop
				ifTrue: 
					[keptCategories nextPut: (categoryArray at: categoryIndex).
					keptStops nextPut: (currentStop _ categoryStops at: categoryIndex)]].
	categoryArray _ keptCategories contents.
	categoryStops _ keptStops contents.
	categoryArray size = 0
		ifTrue:
			[categoryArray _ Array withCells: Default.
			categoryStops _ Array withCells: 0]

	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50746913!
testCreation

	| time |
	
	time := TimeOfDay timeFromMidnight: (TimeUnits hour withCells: 0).
	
	self assert: time hours = (TimeUnits hour withCells: 0).
	self assert: time minutes = (TimeUnits minute withCells: 0).
	self assert: time seconds = (TimeUnits second withCells: 0).
	self assert: time milliseconds = (TimeUnits millisecond withCells: 0)
! !
!GregorianMonth methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50737137!
relativeMonthsTo: aGregorianMonth 
	
	^TimeUnits month withCells: (aGregorianMonth number - self number)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:54' prior: 50746961!
testCreationSecond

	| time |
	
	time := TimeOfDay hours: 1 minutes: 1 seconds: 1.
	
	self assert: time hours = (TimeUnits hour withCells: 1).
	self assert: time minutes = (TimeUnits minute withCells: 1).
	self assert: time seconds = (TimeUnits second withCells: 1).
	self assert: time milliseconds = (TimeUnits millisecond withCells: 0)
! !
!CircularReadStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50728928!
previous

	^self previous: (unit withCells: 1)! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50777919!
test27DoesNotRenameLiteralsThatBeginsWithOldSelectorAndEndWithColonInsideLiteralArray

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString.
	classToRefactor compile: referencerToOldSelector asString , ' ^#(#' , oldSelector asString, ' #' , oldSelector asString,':)'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector). 
	self assert: (senderMethod sendsOrRefersTo: (oldSelector,':') asSymbol) 
! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50785519!
test59MethodObjectInstanceCreationMessageParameterNamesMustNotContainInvalidCharacters

	| keywordsDefinitions variablesToParametrizeToInstanceVariables aParameterName |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'} asDictionary.
	aParameterName := 'a(Parameter!!Name'.
	keywordsDefinitions := {self keyword: #with varName: 'self' paramName: aParameterName.}.

	self
		creationFrom: self compiledMethodReferencingSelf
		withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
		withInstanceCreationMessageFrom: keywordsDefinitions
		failsWithMessageText: [
			ExtractToMethodObject invalidParameterNamesErrorMessage: (Array withCells: aParameterName) ].! !
!Rectangle methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 16898665!
areasOutside: aRectangle
	"Answer an Array of Rectangles comprising the parts of the receiver not 
	intersecting aRectangle."

	| areas |
	"Make sure the intersection is non-empty"
     (self intersects: aRectangle)
		ifFalse: [^Array withCells: self].
	areas := OrderedCollection new.
	self areasOutside: aRectangle do: [ :r |  areas add: r ].
	^areas! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50745958!
thirteenMonths
	
	^TimeUnits month withCells: 13! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50721648!
testMultiplyByNumber

	| kelvin |
	
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: kelvin * 5 = (kelvin withCells: 5).
	
	self assert: (kelvin * 5) numerator = (kelvin withCells: 5).
	self assert: (kelvin * 1) denominator = 1.
	
	self assert: kelvin * 5.5 = (kelvin withCells: 5.5).
	self assert: (kelvin * 5.5) numerator = (kelvin withCells: 5.5) numerator.
	self assert: (kelvin * 5.5) denominator = (kelvin withCells: 5.5) denominator! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50744298!
elevenMonths

	^TimeUnits month withCells: 11! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50723758!
testIntegerMultipliedByUnit

	self assert: (5 * meterOverSecond) = (meterOverSecond withCells: 5).
	self assert: (5 * meterOverSecond) numerator = (meter withCells: 5).
	self assert: (5 * meterOverSecond) denominator = (second withCells: 1).
! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50743289!
testToNegativeByDo

	| interval date hours |
	interval := januarySecondOf2004On23Hours to: januaryFirstOf2004On03Hours by: (TimeUnits hour withCells: -2).
	date := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 02.
	hours := 23.
	interval do: [:aGregorianDateTime |
		self assert: aGregorianDateTime date = date.
		self assert: aGregorianDateTime timeOfDay = (TimeOfDay hours: hours).
		hours := hours - 2.
		hours = -1 
			ifTrue: [
				date := date previous.
				hours := 23]].
	self assert: date = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01).
	self assert: hours = 1! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50772123!
test07NewVariableNameCanNotBeDefinedInAnySubclass

	| classToRefactor classToRefactorSubclass |
	
	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName.
	classToRefactorSubclass := self createClassNamed: #SubclassWithInstVar subclassOf: classToRefactor instanceVariableNames: newVariable.
	
	self 
		assertCreation: [AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [NewInstanceVariablePrecondition errorMessageForNewInstanceVariable: newVariable alreadyDefinedInAll: (Array withCells: classToRefactorSubclass)]
	
		! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50786930!
test34PolymorphicMessageIsAddedToTheNullClassWithChosenParameterNames

	| sourceWithIf definitions |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	self assert: 'p1' equals: (self nullClass compiledMethodAt: #withCells:) methodNode arguments first name.! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50723685!
testFloatDividedByUnitTwice

	| secondOverMeter kelvin |
	secondOverMeter := meterOverSecond reciprocal.
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5.5 / kelvin / meterOverSecond) = (secondOverMeter * (NullUnit new / kelvin) withCells: 5.5).
	self assert: (5.5 / kelvin / meterOverSecond) numerator = (second withCells: 5.5 numerator).
	self assert: (5.5 / kelvin / meterOverSecond) denominator = (kelvin * meter withCells: 5.5 denominator)! !
!TTFontDescription methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50926992!
formGlyphForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"
	| utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset xtraSpaceForAntiAliasingAndRounding horizontalStrokesAtPixelCenter form canvas advanceWidth boundsBottom boundsLeft boundsRight boundsTop i |

	i _ contourDataIndexesByUtf8 at: byte1 + 1.
	utf8ByteArray _ ByteArray withCells: byte1.
	byte2OrNil notNil ifTrue: [
		i _ contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		utf8ByteArray _ ByteArray with: byte1 with: byte2OrNil.
		byte3OrNil notNil ifTrue: [
			i _ contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			utf8ByteArray _ ByteArray with: byte1 with: byte2OrNil with: byte3OrNil.
			byte4OrNil notNil ifTrue: [
				i _ contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1.
				utf8ByteArray _ ByteArray with: byte1 with: byte2OrNil with: byte3OrNil with: byte4OrNil ]]].

	advanceWidth _ contourDataForUtf8 at: i. i _ i + 1.
	boundsLeft _ contourDataForUtf8 at: i. i _ i + 1.
	boundsRight _ contourDataForUtf8 at: i. i _ i + 1.
	boundsTop _ contourDataForUtf8 at: i. i _ i + 1.
	boundsBottom _ contourDataForUtf8 at: i. i _ i + 1.

	horizontalStrokesAtPixelCenter _ 0.5.
	xtraSpaceForAntiAliasingAndRounding _ 3.
	toPixelsScale _ pixelSize * 1.0 / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed"
	leftPixelOffset _ (boundsLeft * toPixelsScale - xtraSpaceForAntiAliasingAndRounding) floor.
	formWidth _ (boundsRight - boundsLeft) * toPixelsScale + (xtraSpaceForAntiAliasingAndRounding*2).

	"Usually positive. Needed pixels above the baseline"
	topPixelOffset _ (boundsBottom * toPixelsScale + xtraSpaceForAntiAliasingAndRounding) ceiling.
	formHeight _ (boundsBottom - boundsTop) * toPixelsScale + (xtraSpaceForAntiAliasingAndRounding*2).
	
	form _ Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
	canvas _ VectorCanvas onForm: form.
	canvas doSubPixelAntiAliasing.
	canvas 
		engine
			displayUtf8: utf8ByteArray
			at: leftPixelOffset negated@(topPixelOffset - horizontalStrokesAtPixelCenter)
			trueTypeFont: self
			color: Color black
			scaleX: 1.0 * pixelSize
			scaleY: -1.0 * pixelSize.
	^FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale)! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 16868209!
printToDoOn: aStream indent: level

	| limitNode |
	self printReceiver: receiver on: aStream indent: level.

	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])
		ifTrue: [limitNode := arguments first]
		ifFalse: [limitNode := arguments last value].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printKeywords: selector key
					arguments: (Array withCells: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50720410!
testMin

	self assert: ((TestIntervalAwareMagnitude withCells: 10) min: (TestIntervalAwareMagnitude withCells: 11)) = (TestIntervalAwareMagnitude withCells: 10).
	self assert: ((TestIntervalAwareMagnitude withCells: 10) min: (TestIntervalAwareMagnitude withCells: 9)) = (TestIntervalAwareMagnitude withCells: 9).
	self assert: ((TestIntervalAwareMagnitude withCells: 10) min: (TestIntervalAwareMagnitude withCells: 10)) = (TestIntervalAwareMagnitude withCells: 10)! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 16911422!
verifyStructure
	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "


	| newClass newList oldList converting |

	self flag: #bobconv.	

	converting _ OrderedCollection new.
	structures keysDo: [:nm "an old className (symbol)" |
		"For missing classes, there needs to be a method in SmartRefStream like 
			#rectangleoc2 that returns the new class."
		newClass _ self mapClass: nm.	   "does (renamed at: nm put: newClass name)"
		newClass class == String ifTrue: [^ newClass].  "error, fileIn needed"
		newList _ (Array withCells: newClass classVersion), (newClass allInstVarNames).
		oldList _ structures at: nm.
		newList = oldList 
			ifTrue: [steady add: newClass]  "read it in as written"
			ifFalse: [converting add: newClass name]
	].
	false & converting isEmpty not ifTrue: ["debug" 
			self inform: 'These classes are being converted from existing methods:\' withNewLines,
				converting asArray printString].
! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50786883!
test32ReplacesIsNilIfFalseIfTrueWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifFalse: [self isNil] ifTrue: [self isNil]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!WeakRegistry methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 16944305!
finalizeValues
	"Some of our elements may have gone away. Look for those and activate the associated executors."
	| finiObjects |
	finiObjects _ nil.
	"First collect the objects."
	self protected:[
		valueDictionary associationsDo:[:assoc|
			assoc key ifNil: [
				finiObjects 
					ifNil: [ finiObjects := OrderedCollection withCells: assoc value]
					ifNotNil: [ finiObjects add: assoc value]]
		].
		finiObjects ifNotNil: [ valueDictionary finalizeValues: finiObjects asArray].
	].
	"Then do the finalization"
	finiObjects ifNotNil: [
		finiObjects do:[:each| each finalize]]! !
!DayOfMonthRuleTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50739286!
testAccessing

	| rule decoratedRule |

	decoratedRule := Array withCells: (GregorianDayOfMonth monthNumber: 01 dayNumber: 01).
	rule := DayOfMonthRule rule: decoratedRule.

	self assert: rule decoratedRule = decoratedRule.
	self assert: rule printString = decoratedRule printString! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50737389!
initializeZeroMonths

	ZeroMonths := TimeUnits month withCells: 0! !
!MinusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50724678!
testEqualsCompoundMeasure

	| measureBag |

	measureBag := ((BaseUnit named: 'peso') withCells: 5) + ((BaseUnit named: 'dollar') withCells: 5).
	self assert: (minusInfinity equalsCompoundMeasure: minusInfinity).
	self deny: (minusInfinity equalsCompoundMeasure: measureBag)! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:55' prior: 50743554!
testDaysFrom

	self assert: ((GregorianDayOfMonth monthNumber: 12 dayNumber: 31)
		distanceFrom: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31)) = (TimeUnits day withCells: 0).
	self assert: ((GregorianDayOfMonth monthNumber: 12 dayNumber: 31)
		distanceFrom: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 365)! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50789270!
test13WhenVariablesToParametrizeBuildsMessageHeader

	| definitions orderedDefinitions |

	orderedDefinitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'v1'
			useKeyword: #k1
			withParameterName: 'p1'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'v2'
			useKeyword: #k2
			withParameterName: 'p2'}.

	definitions := VariablesToParametrizeKeywordsDefinitions
		withCells: orderedDefinitions.

	self assert: 'k1: p1 k2: p2' equals: definitions messageHeader.! !
!FileSystemEntry methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 16843909!
parents
	| ord par |
	par := self parent.
	ord := OrderedCollection withCells: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord! !
!GregorianMonth class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50737380!
initializeTwelveMonths

	TwelveMonths := TimeUnits month withCells: self amountOfMonthsPerYear! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50746109!
testNumberOfDays

	self assert: (GregorianYear number: 2004) numberOfDays=(TimeUnits day withCells: 366).
	self assert: (GregorianYear number: 2003) numberOfDays=(TimeUnits day withCells: 365).

	! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50777526!
test13RenamesRecursiveMethodsWhenInSenders

	| rename senderMethod implementorsAndSenders |
	
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString , ' self ' , oldSelector asString.
	implementorsAndSenders := Array withCells: classToRefactor>>oldSelector.
	
	rename := RenameSelector from: oldSelector to: newSelector implementors: implementorsAndSenders senders: implementorsAndSenders.
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: newSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector)
! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50777890!
test26DoesNotRenameLiteralsThatBeginsWithOldSelectorInsideLiteralArray

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString.
	classToRefactor compile: referencerToOldSelector asString , ' ^#(#' , oldSelector asString, ' #' , oldSelector asString,'1)'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector). 
	self assert: (senderMethod sendsOrRefersTo: (oldSelector,'1') asSymbol) 
! !
!Encoder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 16837716!
init: aClass context: aContext notifying: req
	requestor := req.
	class := aClass.
	nTemps := 0.
	supered := false.
	self initScopeAndLiteralTables.
	"No Tweak Fields in Cuis"
	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |
		scopeTable
			at: variable
			put: (offset >= 0
					ifTrue: [InstanceVariableNode new
								name: variable index: offset]
					ifFalse: [MaybeContextInstanceVariableNode new
								name: variable index: offset negated])].
	aContext ifNotNil: [
		| homeNode |
		homeNode := self bindTemp: self doItInContextName.
		"0th temp = aContext passed as arg"
		aContext tempNames withIndexDo: [ :variable :index |
			variable ~= self doItInContextName ifTrue: [
				scopeTable
					at: variable
					put: (MessageAsTempNode new
						receiver: homeNode
						selector: #namedTempAt:
						arguments: (Array withCells: (self encodeLiteral: index))
						precedence: 3
						from: self)]]].
	sourceRanges := Dictionary new: 32.
	globalSourceRanges := OrderedCollection new: 32! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50880610!
test34SubstractingAHigherValueToANumberReturnsANegativeNumber

	| negativeThreeHalfs |
	
	negativeThreeHalfs := (Entero withCells: -3) / (Entero withCells: 2).	

	self assert: one - fiveHalfs equals: negativeThreeHalfs.! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 16911025!
instVarInfo: anObject
	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "

	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."

	| dummy refs cls newSupers |
	structures _ Dictionary new.
	superclasses _ Dictionary new.
	dummy _ ReferenceStream on: (DummyStream on: nil).
		"Write to a fake Stream, not a file"
	"Collect all objects"
	dummy rootObject: anObject.	"inform him about the root"
	dummy nextPut: anObject.
	refs _ dummy references.
	objCount _ refs size.		"for progress bar"
		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"
	refs keysDo: [:each | 
		cls _ each class.
		"cls isObsolete ifTrue: [self error: 'Trying to write ', cls name]."
		(cls class ~~ Metaclass) & (cls isObsolete not) ifTrue: [
			structures at: cls name put: false]].
	"Save work by only computing inst vars once for each class"
	newSupers _ Set new.
	structures at: #Point put: false.	"writeRectangle: does not put out class pointer"
	structures at: #Rectangle put: false.
	structures at: #LargePositiveInteger put: false.	"used in slow case of WordArray"
	structures keysDo: [:nm | 
		cls _ (nm endsWith: ' class') 
			ifFalse: [Smalltalk at: nm]
			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].
		cls allSuperclasses do: [:aSuper |
			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].
			"Don't modify structures during iteration"
	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"
	structures keysDo: [:nm | "Nothing added to classes during loop"
		cls _ (nm endsWith: ' class') 
			ifFalse: [Smalltalk at: nm]
			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].
		structures at: nm put: 
			((Array withCells: cls classVersion), (cls allInstVarNames)).
		superclasses at: nm ifAbsent: [
				superclasses at: nm put: cls superclass name]].
	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50689447!
askForCategoryIn: aClass default: aDefaultCategory

	| categories index category classCategories |
	
	categories := OrderedCollection withCells: 'new ...'. 
	
	aClass isMeta ifTrue: [ categories add: Categorizer instanceCreation ].
	classCategories := aClass allMethodCategoriesIntegratedThrough: Object.
	aClass isMeta ifTrue: [ classCategories remove: Categorizer instanceCreation ifAbsent: []].
	
	categories addAll: classCategories.	
	index := PopUpMenu 
		withCaption: 'Please provide a good category for the new method!!'
		chooseFrom: categories.
	index = 0 ifTrue: [^ aDefaultCategory].
	category := index = 1 
		ifTrue: [self request: 'Enter category name:' initialAnswer: '']
		ifFalse: [categories at: index].
		
	^ category isEmpty ifTrue: [aDefaultCategory] ifFalse: [category]! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50720372!
testBetweenAndNotInclusive

	self assert: ((TestIntervalAwareMagnitude withCells: 1) between: (TestIntervalAwareMagnitude withCells: 0) andNotInclusive: (TestIntervalAwareMagnitude withCells: 2)).
	self assert: ((TestIntervalAwareMagnitude withCells: 1) between: (TestIntervalAwareMagnitude withCells: 1) andNotInclusive: (TestIntervalAwareMagnitude withCells: 2)).
	self deny: ((TestIntervalAwareMagnitude withCells: 1) between: (TestIntervalAwareMagnitude withCells: 0) andNotInclusive: (TestIntervalAwareMagnitude withCells: 1))! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50745389!
testCommonMonthsMeasure

	self assert: GregorianMonth zeroMonths = (TimeUnits month withCells: 0).
	self assert: GregorianMonth twoMonths = (TimeUnits month withCells: 2).
	self assert: GregorianMonth threeMonths = (TimeUnits month withCells: 3).
	self assert: GregorianMonth fourMonths = (TimeUnits month withCells: 4).
	self assert: GregorianMonth sixMonths = (TimeUnits month withCells: 6).
	self assert: GregorianMonth twelveMonths = (TimeUnits month withCells: 12)! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50561337!
maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array withCells: `0 @ 0`].
	points := OrderedCollection new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^ points! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50747021!
testOneMillisecond

	self assert: TimeOfDay oneMillisecond = (TimeUnits millisecond withCells: 1)! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50736666!
initializeThirtyOneDays

	ThirtyOneDays := TimeUnits day withCells: 31! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50746996!
testNow

	| now nowInTwoSeconds |
	
	now := TimeOfDay now.
	(Delay forSeconds: 1) wait.
	nowInTwoSeconds := TimeOfDay now.
	
	self assert: now < nowInTwoSeconds.
	self assert: ((now distanceTo: nowInTwoSeconds) - (TimeUnits second withCells: 1)) abs <= (TimeUnits millisecond withCells: 10)! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50777381!
test03OtherMessagesSendsAreNotRenamed

	|  rename senderMethod selectorToKeep |

	selectorToKeep := #toKeep.
	self createClassToRefactor.
	classToRefactor compile: senderOfOldSelector asString , ' self ' , oldSelector asString , '. self ' , selectorToKeep asString.
	
	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>senderOfOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: senderOfOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector).
	self assert: (senderMethod sendsOrRefersTo: selectorToKeep) 
! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50777779!
test21NewSelectorCanNotBeImplementedOnAnyClassImplementingOldSelector

	| implementors |
	
	oldSelector := #printString.
	newSelector := #size.
	implementors := Array withCells: Object>>oldSelector.
	
	self 
		assertCreation: [ RenameSelector from: oldSelector to: newSelector implementors: implementors senders: #() ]
		failsWith: [ RenameSelector errorMessageForNewSelector: newSelector implementedInAll: (Array withCells: Object) ]
! !
!Message class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 16867476!
selector: aSymbol argument: anObject 
	"Answer an instance of me whose selector is aSymbol and single 
	argument is anObject."

	^self new setSelector: aSymbol arguments: (Array withCells: anObject)! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50744314!
twelveMonths
	
	^TimeUnits month withCells: 12! !
!TheWorldMenu methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50651395!
newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.
	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollection withCells: eaSubclass) ]]].
	catDict keys sort do: [ :categ | | morphsInCat |
		morphsInCat _ (catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ].
		morphsInCat size > self pvtMaxItemsPerCategorySubMenu
			ifTrue: [
				menu
					add: categ
					subMenu:
						(self pvtNewMenuForSplitLists:
							(self
								splitNewMorphList: morphsInCat
								depth: self pvtCategorySplitListDepth )) ]
			ifFalse: [ | subMenu |
				subMenu _ MenuMorph new.
				morphsInCat do: [ :cl |
					subMenu
						add: cl name
						target: self
						action: #newMorphOfClass:event:
						argument: cl ].
				menu
					add: categ
					subMenu: subMenu ]].
	self doPopUp: menu.! !
!CompoundMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:56' prior: 50722827!
testTruncated

	self assert: ((self peso withCells: 10.01) + (self dollar withCells: 20.5)) truncated = (self tenPesos + self twentyDollars)! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50743255!
testToByDo

	| interval date hours |
	interval := januaryFirstOf2004 to: januarySecondOf2004On23Hours59Minutes59Seconds by: (TimeUnits hour withCells: 1).
	date := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01.
	hours := 0.
	interval do: [:aGregorianDateTime | 
		self assert: aGregorianDateTime date = date.
		self assert: aGregorianDateTime timeOfDay = (TimeOfDay hours: hours).
		hours := hours + 1.
		hours = 24 
			ifTrue: [
				date := date next.
				hours := 0]].
	self assert: date = (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 03).
	self assert: hours = 0! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50786667!
test24PolymorphicMessageIsAddedToTheConcreteClassReplacingParametrizedVariables

	| sourceWithIf definitions expectedSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedSourceCode := 'with: p1', String newLineString, String tab, 'p1 isNil'.
	self assert: expectedSourceCode equals: (self concreteClass compiledMethodAt: #withCells:) sourceCode.
	! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50918162!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot withCells: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!MorphicCanvas methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50583174!
initializeWith: aForm origin: aPoint
	self initialize.
	self setForm: aForm.

	"We currently set up these only on initialization.
	This is safe (wrt walkbacks during world redraw) because a new instance is created
	each time the world is redrawn. See #drawInvalidAreasWorld:submorphs:
	Maybe this cleanup should be in an aux method that can be called each time on an existing instance..."
	currentTransformation _ MorphicTranslation withTranslation: aPoint.
	cti _ 1.
	transformations
		ifNil: [ transformations _ OrderedCollection withCells: currentTransformation ]
		ifNotNil: [ transformations at: cti put: currentTransformation ].
	drawingMorphStack
		ifNil: [ drawingMorphStack _ OrderedCollection withCells: nil ]
		ifNotNil: [ drawingMorphStack at: cti put: nil ].! !
!CircularReadStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50728857!
distanceFrom: anObject toObjectPosition: aToObjectPosition

	| fromObjectPosition steps |

	fromObjectPosition := collection indexOf: anObject.
	steps := aToObjectPosition >= fromObjectPosition 
		ifTrue: [aToObjectPosition - fromObjectPosition]
		ifFalse: [collection size - fromObjectPosition + aToObjectPosition].
	^unit withCells: steps! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50732023 overrides: 50730700!
to: stop

	 ^self to: stop by: (unit withCells: 1)! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50724105!
testIsCompoundMeasure

	self deny: formulaOfTenPesos isCompoundMeasure.
	self assert: (DummyEvaluation of: (peso withCells: 1) + (dollar withCells: 1)) isCompoundMeasure! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50786951!
test35PolymorphicMessageIsAddedToTheNullClassReplacingParametrizedVariables

	| sourceWithIf definitions expectedSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedSourceCode := 'with: p1', String newLineString, String tab, 'p1 isNil'.
	self assert: expectedSourceCode equals: (self nullClass compiledMethodAt: #withCells:) sourceCode.
	! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50745211!
testToReverse

	| coll number |
	coll := ((GregorianMonthOfYear yearNumber:  2004 monthNumber: 01) 
		to: (GregorianMonthOfYear yearNumber:  2004 monthNumber: 12)
		by: (TimeUnits month withCells: 2)) reverse.
	number := 11.
	coll do: [:aMonthOfYear | 
		self assert: aMonthOfYear monthNumber = number.
		number := number - 2].
	self assert: number = -1! !
!TrieTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50767334!
testIncludesReturnsFalseForObjectsThatAreNotString
	
	self deny: ((Trie withCells: 'hello') includes: 1)
	! !
!CodeProvider methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50694080!
categoryFromUserWithPrompt: aPrompt for: aClass
	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"

	|  labels myCategories reject lines newName menuIndex |
	labels _ OrderedCollection withCells: 'new...'.
	labels addAll: (myCategories _ aClass organization categories asArray copy sort:
		[ :a :b | a asLowercase < b asLowercase ]).
	reject _ myCategories asSet.
	reject
		add: ClassOrganizer nullCategory;
		add: ClassOrganizer default.
	lines _ OrderedCollection with: 1 with: (myCategories size + 1).

	aClass allSuperclasses do: [ :cls | | cats |
			cats _ cls organization categories reject: [ :cat | reject includes: cat].
			cats isEmpty ifFalse: [
				lines add: labels size.
				labels addAll: (cats asArray sort: [ :a :b | a asLowercase < b asLowercase]).
				reject addAll: cats]].

	(labels size = 1 or: [
		menuIndex _ (PopUpMenu labelArray: labels lines: lines)
		startUpWithCaption: aPrompt.
		menuIndex = 0 ifTrue: [^ nil].
		menuIndex = 1])
			ifTrue:[
				newName _ self request: 'New category name?' initialAnswer: 'category-name'.
				newName isEmpty ifTrue: [ ^nil ]]
			ifFalse: [ newName _ labels at: menuIndex ].
	^ newName ifNotNil: [ newName asSymbol ]! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50741986!
testNumberOfDaysToEndOfMonth

	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) numberOfDaysToEndOfMonth = (TimeUnits day withCells: 30).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 31) numberOfDaysToEndOfMonth = (TimeUnits day withCells: 0).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 2 dayNumber: 28) numberOfDaysToEndOfMonth = (TimeUnits day withCells: 1).
	
	
	
! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50678146!
computeMessageEntriesWithBinaryMessageForClass: aClass 

	selectorsClasses := Array withCells: aClass.
	
	entries := self unaryAndBinarySelectorsOf: aClass beginningWith: prefix.
		! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50744914!
testNextANumberOfMonths

	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: self oneMonth) =
		(GregorianMonthOfYear februaryOf: (GregorianYear number: 2004)).
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: self elevenMonths) =
		(GregorianMonthOfYear decemberOf: (GregorianYear number: 2004)).
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: self twelveMonths) =
		(GregorianMonthOfYear januaryOf: (GregorianYear number: 2005)).
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: self thirteenMonths) =
		(GregorianMonthOfYear februaryOf: (GregorianYear number: 2005)).
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: self ceroMonths) =
		(GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)).
	
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: self oneYear) =
		(GregorianMonthOfYear januaryOf: (GregorianYear number: 2005)).
	self assert: ((GregorianMonthOfYear aprilOf: (GregorianYear number: 2004)) next: self oneYear) =
		(GregorianMonthOfYear aprilOf: (GregorianYear number: 2005)).
	
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: (TimeUnits month withCells: 0.5)) =
		(GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)).
	self assert: ((GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) next: (TimeUnits month withCells: 1.5)) =
		(GregorianMonthOfYear februaryOf: (GregorianYear number: 2004))! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50776963!
test07NewVariableNameCanNotBeDefinedInSuperclasses

	|  classToRefactorSuperclass  |

	classToRefactorSuperclass := self createClassNamed: #SuperclassWithInstVar instanceVariableNames: newVariable.
	classToRefactor := self createClassNamed: self classToRefactorName subclassOf: classToRefactorSuperclass instanceVariableNames: oldVariable.
	
	self assertRenameCreationFailsWith: [NewInstanceVariablePrecondition errorMessageForNewInstanceVariable: newVariable alreadyDefinedInAll: (Array withCells: classToRefactorSuperclass)]
	
	
! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50777795!
test22WarnsWhenOverridesSuperclassImplementation

	| implementors |
	
	oldSelector := #negated.
	newSelector := #size.
	implementors := Array withCells: Number>>oldSelector.
	
	self 
		assertCreation: [ RenameSelector from: oldSelector to: newSelector implementors: implementors senders: #() ]
		warnsWith: [ RenameSelector warningMessageForImplementationOf: newSelector in: Number willOverrideImplementationIn: Object ]
! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50335824 overrides: 50335818!
unStream: aByteArray

	^(self on: ((RWBinaryOrTextStream withCells: aByteArray) reset; binary)) next! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50747030!
testTwentyFourHours

	self assert: TimeOfDay twentyFourHours= (TimeUnits hour withCells: 24)! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50736691!
initializeTwentyNineDays

	TwentyNineDays := TimeUnits day withCells: 29! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50747026!
testOneSecond

	self assert: TimeOfDay oneSecond = (TimeUnits second withCells: 1)! !
!Number methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50733390!
divideByUnit: aUnit

	^aUnit withCells: 1 / self! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50772177!
test10FailsWhenNewVariableEqualsArgumentOfAMethodInClass

	| selector classToRefactor |

	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName.
	selector := #m1:.
	classToRefactor compile: selector, newVariable.
	
	self 
		assertCreation: [ AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50777836!
test24OldSelectorIsRenamedWhenDefinedInLiteralArrayMoreThanOnce

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString.
	classToRefactor compile: referencerToOldSelector asString , ' ^#(#' , oldSelector asString, ' #' , oldSelector asString,')'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector) 
! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:57' prior: 50918247!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50689710!
writeClassRenameMethod: sel was: oldName fromInstVars: oldList 
	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "

	| tell choice newName answ code oldVer newList newVer instSel |
	self flag: #bobconv.
	tell := 'Reading an instance of ' , oldName 
				, '.
Which modern class should it translate to?'.
	answ := (PopUpMenu 
				labels: 'Let me type the name now
Let me think about it
Let me find a conversion file on the disk') 
					startUpWithCaption: tell.
	answ = 1 
		ifTrue: [
			tell := 'Name of the modern class {1} should translate to:' format: {oldName}.
			choice := self request: tell initialAnswer: ''.	"class name"
			choice size = 0 
				ifTrue: [answ := 'conversion method needed']
				ifFalse: 
					[newName := choice.
					answ := Smalltalk at: newName asSymbol
								ifAbsent: ['conversion method needed'].
					answ class == String 
						ifFalse: [renamed at: oldName asSymbol put: answ name]]].
	answ = 3 | (answ = 0) 
		ifTrue: [
			byteStream close.
			^'conversion method needed'].
	answ = 2 ifTrue: [answ := 'conversion method needed'].
	answ = 'conversion method needed' 
		ifTrue: [
			byteStream close.
			newName := 'PutNewClassHere'].
	answ class == String 
		ifFalse: 
			[oldVer := self versionSymbol: (structures at: oldName).
			newList := (Array withCells: answ classVersion) , answ allInstVarNames.
			newVer := self versionSymbol: newList.
			instSel := 'convert' , oldVer , ':' , newVer , ':'].
	code := WriteStream on: (String new: 500).
	code
		nextPutAll: sel;
		newLine.
	answ class == String 
		ifFalse: [
			code
				newLine;
				tab;
				nextPutAll: 'reshaped at: #' , oldName , ' put: #' , instSel , '.'.
			code
				newLine;
				tab;
				tab;
				nextPutAll: '"Be sure to define that conversion method in class ' 
							, answ name , '"'].
	code
		newLine;
		tab;
		nextPutAll: '^ ' , newName.	"Return new class"
	self class compile: code contents classified: 'conversion'.
	newName = 'PutNewClassHere' 
		ifTrue: [
			self 
				inform: 'Please complete the following method and 
then read-in the object file again.'.
			Smalltalk browseAllImplementorsOf: sel asSymbol].
	self flag: #violateBasicLayerPrinciples.
	"SmartRefStream should not refer to UI!!!!!!!!!! (sd)"

	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  
	If this is true for class Foo, define classVersion in Foo class.  
	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."
	^answ! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50721474!
testFloatDividedByUnit

	| kelvin |
	
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5.5 / kelvin) = (5.5 / (kelvin withCells: 1)).
	self assert: (5.5 / kelvin) numerator = 5.5 numerator.
	self assert: (5.5 / kelvin) denominator = (kelvin withCells: 5.5 denominator)! !
!WeakKeyAssociation methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 16943898 overrides: 16780903!
key: aKey value: anObject
	key := WeakArray withCells: aKey.
	value := anObject.! !
!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 16912012!
cleanUpCategories
	| list valid removed newList newVers |
	"Look for all conversion methods that can't be used any longer.  Delete them."
	" SmartRefStream cleanUpCategories "

	"Two part selectors that begin with convert and end with a digit."
	"convertasossfe0: varDict asossfeu0: smartRefStrm"
	list _ Symbol selectorsContaining: 'convert'.
	list _ list select: [:symb | (symb beginsWith: 'convert') & (symb allButLast last isDigit)
				ifTrue: [(symb numArgs = 2)]
				ifFalse: [false]].
	valid _ 0.  removed _ 0.
	list do: [:symb |
		(Smalltalk allClassesImplementing: symb) do: [:newClass |
			newList _ (Array withCells: newClass classVersion), (newClass allInstVarNames).
			newVers _ self new versionSymbol: newList.
			(symb endsWith: (':',newVers,':')) 
				ifFalse: [
					"method is useless because can't convert to current shape"
					newClass removeSelector: symb.	"get rid of it"
					removed _ removed + 1]
				ifTrue: [valid _ valid + 1]]].
	Transcript
		newLine;
		show: 'Removed: ';
		print: removed; 
		show: '		Kept: ';
		print: valid;
		show: ' '! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50736676!
initializeThreeHundredSixtyFiveDays

	ThreeHundredSixtyFiveDays := TimeUnits day withCells: 365! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50727867!
testDivisionFractionByMeasure

	self assert: ((1/3) / self tenPesos) = ((NullUnit new / self peso) withCells: (1/3)/10)

! !
!CanNotChangeSelectorWithNotIncludedTypes class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50795467!
signalWith: messageSendsWithInvalidReceiverTypes 
	
	(self withCells: messageSendsWithInvalidReceiverTypes) signal! !
!Morph methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 16874795!
addAlarm: aSelector with: arg1 after: delayTime
	"Add an alarm (that is an action to be executed once) with the given set of parameters"
	^self addAlarm: aSelector withArguments: (Array withCells: arg1) after: delayTime! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50786692!
test25ReplacesIfNilIfNotNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNil: [ self isNil ] ifNotNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50732513!
divideByUnit: aUnit

	^aUnit withCells: 1 / self! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50747103!
testTimeFrom

	self assert: (TimeOfDay firstTimeOfDay distanceFrom: TimeOfDay lastTimeOfDay) = (TimeUnits millisecond withCells: 1).
	self assert: (TimeOfDay lastTimeOfDay distanceFrom: TimeOfDay firstTimeOfDay) = (TimeOfDay twentyFourHours - (TimeUnits millisecond withCells: 1))! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50732364 overrides: 50730700!
to: stop

	^self to: stop by: (self unit withCells: 1)! !
!ConversionTableTest class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50723491 overrides: 16927631!
resources

	^Array withCells: UnitsTestResource! !
!MessageKeywordsAndParametersModel methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50791946!
definitions

	^selectorModel
		ifNotNil: [VariablesToParametrizeKeywordsDefinitions withSelector: selectorModel actualContents string asSymbol]
		ifNil: [VariablesToParametrizeKeywordsDefinitions withCells: (models collect: [:model |
			VariableToParametrizeKeywordDefinition
				forVariable: (model at: #variableName)
				useKeyword: (model at: #keyword) actualContents string
				withParameterName: (model at: #parameterName) actualContents string])]! !
!Text class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 16929861!
string: aString attribute: aTextAttribute
	"Answer an instance of me whose characters are aString."

	^self string: aString attributes: (Array withCells: aTextAttribute)! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50883744 overrides: 50881544!
divideByFraccion: aFraccion

	| numerator denominator |
	numerator := aFraccion numerator .
	denominator := (self class withCells: (value * (aFraccion denominator integerValue))) .
	^ numerator/ denominator.! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50881902 overrides: 50881549!
subtractEntero: anEntero 

	^ self class withCells: (anEntero integerValue - value).! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50742728!
testNextInWeeks

	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: (TimeUnits week withCells: 1)) = 
						((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: 7)).
	self assert: ((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: (TimeUnits week withCells: 2)) = 
						((FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) next: (TimeUnits day withCells: 14)).
						
! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50743366!
testTimeTo

	self assert: (januaryFirstOf2004 distanceTo: januaryFirstOf2004On00Hours00Minutes01Seconds) = (TimeUnits second withCells: 1).
	self assert: (januaryFirstOf2004 distanceTo: januarySecondOf2004On23Hours) = ((TimeUnits day withCells: 1) + (TimeUnits hour withCells: 23)).
	self  assert: (januaryFirstOf2004 distanceTo: januarySecondOf2004) = (TimeUnits day withCells: 1).
	self assert: (januaryFirstOf2004 distanceTo: januaryThirdOf2004) = (TimeUnits day withCells: 2).
	self assert: (januaryFirstOf2004On00Hours00Minutes01Seconds distanceTo: januaryFirstOf2004) = (TimeUnits second withCells: -1).
	self assert: (januarySecondOf2004 distanceTo: januaryFirstOf2004) = (TimeUnits day withCells: -1).
	self assert: (januaryThirdOf2004 distanceTo: januaryFirstOf2004) = (TimeUnits day withCells: -2)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50747045!
testReverse

	| collection hour |
	
	collection := (TimeOfDay firstTimeOfDay to: TimeOfDay lastTimeOfDay by: (TimeUnits hour withCells: 2)) reverse.
	hour := 22.
	collection do: [ :aTimeOfDay |
		self assert: aTimeOfDay = (TimeOfDay hours: hour).
		hour := hour - 2 ].
	
	self assert: hour = -2! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:58' prior: 50738669!
initializeZeroHours

	zeroHours := TimeUnits hour withCells: 0! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50745952!
sixMonths

	^TimeUnits month withCells: 6! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50746831!
testAdd

	| time |
	
	time := TimeOfDay firstTimeOfDay.

	self assert: (time next: (TimeUnits hour withCells: 1)) timeFromMidnight = (TimeUnits hour withCells: 1).
	self assert: (time next: (TimeUnits minute withCells: 1)) timeFromMidnight = (TimeUnits minute withCells: 1).
	self assert: (time next: (TimeUnits second withCells: 1)) timeFromMidnight = (TimeUnits second withCells: 1).
	self assert: (time next: (TimeUnits millisecond withCells: 1)) timeFromMidnight = (TimeUnits millisecond withCells: 1)! !
!Unit methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50729291!
divideSimpleMeasure: aMeasure

	^((NullUnit new / self) * aMeasure unit) withCells: aMeasure amount! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50558594!
yTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap withCells: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: height-1) collect: [ :y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits]! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50777981!
test29CanRenameFromKeywordOfOneParameterToBinary

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	oldSelector := 'abc:' asSymbol.
	newSelector := '&&' asSymbol.
	classToRefactor := self createClassNamed: self classToRefactorName.
	classToRefactor compile: oldSelector asString, ' aParameter'.
	classToRefactor compile: referencerToOldSelector asString , ' ^self ' , oldSelector asString,' 1'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	self assert: (classToRefactor includesSelector: newSelector).
	self deny: (classToRefactor includesSelector: oldSelector).
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector). 
! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50723812!
testMultiplyByInfinity

	self assert: meterOverSecond * infinity = (meterOverSecond withCells: infinity).
	self assert: infinity * meterOverSecond = (meterOverSecond withCells: infinity).
	self assert: (meterOverSecond * infinity) numerator = (meter withCells: infinity).
	self assert: (meterOverSecond * infinity) denominator = (second withCells: 1)! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50743045!
testAccessing

	self assert: (GregorianDateTime date: self januaryFirst2004 timeOfDay: (TimeUnits hour withCells: 0)) date = self januaryFirst2004.
	self assert: (GregorianDateTime date: self januaryFirst2004 timeOfDay: (TimeUnits hour withCells: 0)) timeOfDay = (TimeUnits hour withCells: 0).
	self assert: (GregorianDateTime date: self januaryFirst2004 timeOfDay: (TimeUnits hour withCells: 0)) dayNumber = 1.! !
!Refactoring class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50684145!
allowedToRefactorClassCompilers

	AllowedToRefactorClassCompilers ifNil: [
		AllowedToRefactorClassCompilers := Set withCells: Compiler ].

	^AllowedToRefactorClassCompilers! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50931116 overrides: 16927572!
setUp

	trailer _ Trailer with: 20 and: 100.
	robot _ Robot withCells: trailer.	
	cashier _ Cashier new.! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50738648!
initializeOneMillisecond

	oneMillisecond := TimeUnits millisecond withCells: 1! !
!ChangeSet methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 16798263!
askRenames: renamed addTo: msgSet using: smart
	| list |
	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."

	list _ OrderedCollection new.
	renamed do: [ :cls | | rec |
		rec _ changeRecords at: cls name.
		rec priorName ifNotNil: [
			| ans |
			ans _ PopUpMenu withCaption: 'You renamed class ', rec priorName, 
				' to be ', rec thisName,
				'.\Could an instance of ', rec priorName, 
				' be in a project on someone''s disk?'
			chooseFrom: #('Yes, write code to convert those instances'
				'No, no instances are in projects').
			ans = 1 ifTrue: [
				| oldStruct newStruct  |
				oldStruct _ structures at: rec priorName ifAbsent: nil.
				newStruct _ (Array withCells: cls classVersion), (cls allInstVarNames).
				oldStruct ifNotNil: [
					smart writeConversionMethodIn: cls fromInstVars: oldStruct 
							to: newStruct renamedFrom: rec priorName.
					smart writeClassRename: cls name was: rec priorName.
					list add: cls name, ' convertToCurrentVersion:refStream:']]
			ifFalse: [structures removeKey: rec priorName ifAbsent: nil]]].
	list isEmpty ifTrue: [^ msgSet].
	msgSet messageList ifNil: [msgSet initializeMessageList: list]
		ifNotNil: [list do: [:item | msgSet addMethodReference: item]].
	^ msgSet! !
!CompiledMethod methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 16819973!
symbolicLinesDo: aBlock
	"Evaluate aBlock with each of the lines in the symbolic output."

	| aStream pc firstLine |
	aStream := ReadWriteStream on: (String new: 64).
	self isQuick ifTrue:
		[self longPrintOn: aStream.
		 aBlock value: 0 value: aStream contents.
		 ^self].

	self primitive ~= 0 ifTrue:
		[self printPrimitiveOn: aStream.
		 aBlock value: 1 value: aStream contents.
		 aStream resetContents].

	pc := self initialPC.
	(InstructionPrinter on: self)
		indent: 0;
		printPC: false; "explorer provides pc anyway"
		printInstructionsOn: aStream
		do:	[:printer :scanner :stream| | line index |
			line := stream contents allButLast.
			firstLine _ line lines first.
			firstLine size < line size ifTrue: [
				line _ firstLine, '...'' (continues)'].
			(index := line indexOf: $>) > 0 ifTrue:
				[[(line at: index + 1) isSeparator] whileTrue: [index := index + 1].
				 line := ((line copyFrom: 1 to: index) copyReplaceAll: (String withCells: Character tab) with: (String new: 8 withAll: Character space)),
						(line copyFrom: index + 1 to: line size)].
			aBlock value: pc value: line.
			pc := scanner pc.
			stream resetContents]! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50668840!
classify: element under: heading suppressIfDefault: aBoolean
	"Store the argument, element, in the category named heading.   If aBoolean is true, then invoke special logic such that the classification is NOT done if the new heading is the Default and the element already had a non-Default classification -- useful for filein"

	| catName catIndex elemIndex realHeading |
	((heading = NullCategory) or: [heading == nil])
		ifTrue: [realHeading _ Default]
		ifFalse: [realHeading _ heading ].
	(catName _ self categoryOfElement: element) = realHeading
		ifTrue: [^ self].  "done if already under that category"

	catName ifNotNil: [
		(aBoolean and: [realHeading = Default])
				ifTrue: [^ self].	  "return if non-Default category already assigned in memory"
		self removeElement: element].	"remove if in another category"

	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].

	catIndex _ categoryArray indexOf: realHeading.
	elemIndex _ 
		catIndex > 1
			ifTrue: [categoryStops at: catIndex - 1]
			ifFalse: [0].
	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 
		and: [element >= (elementArray at: elemIndex)]] whileTrue.

	"elemIndex is now the index for inserting the element. Do the insertion before it."
	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1
						with: (Array withCells: element).

	"add one to stops for this and later categories"
	catIndex to: categoryArray size do: 
		[:i | categoryStops at: i put: (categoryStops at: i) + 1].

	(self listAtCategoryNamed: Default) size = 0 ifTrue: [self removeCategory: Default]! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 16848080!
makeAllPixelsAlpha: a
	"Fix the alpha channel if the receiver is 32bit
	Set alpha values to 255 for all pixels.
	Note: assumes that a pixel with 0 is meant to be black, not transparent (As Squeak / Cuis usually handles rgb=0 for bpp<=16).
	See #fixAlpha"
	| bitBlt |
	self depth = 32 ifFalse: [ ^self ].
	bitBlt := BitBlt toForm: self.
	bitBlt combinationRule: 1.
	bitBlt fillBitmap: (Bitmap withCells: (16r00FFFFFF)).
	bitBlt copyBits.
	bitBlt combinationRule: 7.
	bitBlt fillBitmap: (Bitmap withCells: (a bitShift: 24)).
	bitBlt copyBits! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 16807141!
classesThatImplementAllOf: selectorSet
	"Return an array of any classes that implement all the messages in selectorSet."

	| found remaining |
	found _ OrderedCollection new.
	selectorSet do:
		[:sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].
	found isEmpty
		ifTrue: [^ self subclasses inject: Array new
						into: [:subsThatDo :sub |
							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]
		ifFalse: [remaining _ selectorSet copyWithoutAll: found.
				remaining isEmpty ifTrue: [^ Array withCells: self].
				^ self subclasses inject: Array new
						into: [:subsThatDo :sub |
							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50786627!
test22PolymorphicMessageIsAddedToTheConcreteClass

	| sourceWithIf definitions |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	self assert: (self concreteClass selectors includes: #withCells:).! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50789240!
test11WhenVariablesToParametrizeBuildsMessageSending

	| definitions orderedDefinitions |

	orderedDefinitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'v1'
			useKeyword: #k1
			withParameterName: 'p1'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'v2'
			useKeyword: #k2
			withParameterName: 'p2'}.

	definitions := VariablesToParametrizeKeywordsDefinitions
		withCells: orderedDefinitions.

	self assert: 'k1: v1 k2: v2' equals: definitions messageSending.! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50918173!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50744076!
testDaysTo

	self assert: (GregorianDay monday distanceTo: GregorianDay monday) = GregorianDay zeroDays.
	self assert: (GregorianDay monday distanceTo: GregorianDay tuesday) = GregorianDay oneDay.
	self assert: (GregorianDay monday distanceTo: GregorianDay wednesday) = GregorianDay twoDays.
	self assert: (GregorianDay monday distanceTo: GregorianDay thursday) = (TimeUnits day withCells: 3).
	self assert: (GregorianDay monday distanceTo: GregorianDay friday) = (TimeUnits day withCells: 4).
	self assert: (GregorianDay monday distanceTo: GregorianDay saturday) = (TimeUnits day withCells: 5).
	self assert: (GregorianDay monday distanceTo: GregorianDay sunday) = (TimeUnits day withCells: 6).
! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50786828!
test30ReplacesIsNilIfFalseWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50723990!
tenDollars
	
	^dollar withCells: 10! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:33:59' prior: 50741934!
testNumberOfDaysFromBaseDate

	self assert: (FixedGregorianDate yearNumber: 1901 monthNumber: 1 dayNumber: 1) numberOfDaysFromBaseDate = (TimeUnits day withCells: 0).
	self assert: (FixedGregorianDate yearNumber: 1901 monthNumber: 12 dayNumber: 31) numberOfDaysFromBaseDate = (TimeUnits day withCells: 364).
	self assert: (FixedGregorianDate yearNumber: 2004 monthNumber: 1 dayNumber: 1) numberOfDaysFromBaseDate = (TimeUnits day withCells: 37620).
	
! !
!IsKindOfManyTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50806611 overrides: 50806558!
buildRejectApplierBefore: aPreviousCastingApplier

	^EffectiveTypeCastApplier 
		casts: OrderedCollection new
		rejections: (OrderedCollection withCells: self buildTypeReject)
		previous: aPreviousCastingApplier! !
!PlusInfinity methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50732731 overrides: 50730700!
to: stop

	^self to: stop by: (self unit withCells: 1)! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50738639!
initializeLastTimeOfDay

	lastTimeOfDay :=
		self timeFromMidnight: (self twentyFourHours - (TimeUnits millisecond withCells: 1))! !
!Scanner methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50603199!
xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := WriteStream on: (String new: 200).
    self step.
    [hereChar == $"]
        whileFalse:
            [(hereChar == stopChar and: [source atEnd])
                ifTrue: [^self offEnd: 'Unmatched comment quote'].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection withCells: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!TimeOfDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50738603!
hours: anHour minutes: aMinute seconds: aSecond milliseconds: aMillisecond

	^self timeFromMidnight: 
		((TimeUnits hour withCells: anHour) +
		(TimeUnits minute withCells: aMinute) +
		(TimeUnits second withCells: aSecond) +
		(TimeUnits millisecond withCells: aMillisecond))
		! !
!SmartRefStream methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 16911503!
conversionMethodsFor: classList
	| oldStruct newStruct list |
	"Each of these needs a conversion method.  Hard part is the comment in it.  Return a MessageSet."

	list _ OrderedCollection new.
	classList do: [:cls |
		oldStruct _ structures at: cls name ifAbsent: [#()].
		newStruct _ (Array withCells: cls classVersion), (cls allInstVarNames).
		self writeConversionMethodIn: cls fromInstVars: oldStruct to: newStruct 
				renamedFrom: nil.
		list add: cls name, ' convertToCurrentVersion:refStream:'.
		].

	^ MessageSet new initializeMessageList: list.! !
!WeightExplorer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 16944805 overrides: 50954992!
getList

	| wrapper |
	wrapper _ WeightExplorerWrapper
		with: self finder rootNode object
		name: self rootObject identityHash asString
		model: self finder rootNode.
	wrapper finderSkipsClasses: self finder skipClasses.
	^Array withCells: wrapper! !
!Browser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50660746!
explainSpecial: string 
	"Answer a string explaining the code pane selection if it is displaying 
	one of the special edit functions."

	| classes whole lits reply |
	self isEditingClass
		ifTrue: 
			["Selector parts in class definition"
			string last == $: ifFalse: [^nil].
			lits _ Array withCells:
				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.
			(whole _ lits detect: [:each | (each keywords
					detect: [:frag | frag = string] ifNone: nil) notNil]
						ifNone: nil) notNil
				ifTrue: [reply _ '"' , string , ' is one part of the message selector ' , whole , '.']
				ifFalse: [^nil].
			classes _ Smalltalk allClassesImplementing: whole.
			classes _ 'these classes ' , classes printString.
			^reply , '  It is defined in ' , classes , '."
Smalltalk browseAllImplementorsOf: #' , whole].

	editSelection == #hierarchy
		ifTrue: 
			["Instance variables in subclasses"
			classes _ self selectedClassOrMetaClass allSubclasses.
			classes _ classes detect: [:each | (each instVarNames
						detect: [:name | name = string] ifNone: nil) notNil]
					ifNone: [^nil].
			classes _ classes printString.
			^'"is an instance variable in class ' , classes , '."
' , classes , ' browseAllAccessesTo: ''' , string , '''.'].
	editSelection == #editSystemCategories ifTrue: [^nil].
	editSelection == #editMessageCategories ifTrue: [^nil].
	^nil! !
!SmalltalkCompleter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50678156!
computeMessageEntriesWithoutBinaryMessageForClass: aClass

	selectorsClasses := Array withCells: aClass.
	
	entries := self selectorsOf: aClass beginningWith: prefix.! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50723576!
testDivideByFloat

	self assert: (meterOverSecond / 5.5) = (meterOverSecond withCells: 1/5.5).
	self assert: (meterOverSecond / 5.5) numerator = (meter withCells: (1/5.5) numerator).
	self assert: (meterOverSecond / 5.5) denominator = (second withCells: (1/5.5) denominator)! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50723671!
testFloatDividedByUnit

	| secondOverMeter |
	secondOverMeter := meterOverSecond reciprocal.
	
	self assert: (5.5 / meterOverSecond) = (secondOverMeter withCells: 5.5).
	self assert: (5.5 / meterOverSecond) numerator = (second withCells: 5.5 numerator).
	self assert: (5.5 / meterOverSecond) denominator = (meter withCells: 5.5 denominator)! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50723742!
testIntegerDividedByUnitTwice

	| secondOverMeter kelvin |
	secondOverMeter := meterOverSecond reciprocal.
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5 / kelvin / meterOverSecond) = (secondOverMeter * (NullUnit new / kelvin) withCells: 5).
	self assert: (5 / kelvin / meterOverSecond) numerator = (second withCells: 5).
	self assert: (5 / kelvin / meterOverSecond) denominator = (kelvin * meter withCells: 1).
	
! !
!GregorianTimespanTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50745920!
testTo

	self assert: (GregorianTimespan from: januaryFirstOf2004 duration: GregorianDay oneDay) to
		= (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 02).
	self assert: (GregorianTimespan from: (GregorianDayOfMonth monthNumber: 01 dayNumber: 01) duration: GregorianDay oneDay) to
		= (GregorianDayOfMonth monthNumber: 01 dayNumber: 02).
	self assert: (GregorianTimespan from: (TimeOfDay hours: 1) duration: (TimeUnits hour withCells: 10)) to = (TimeOfDay hours: 11).
	self assert: (GregorianTimespan from: GregorianMonth january duration: (TimeUnits month withCells: 10)) to = GregorianMonth november.
	self assert: (GregorianTimespan from: GregorianDay sunday duration: GregorianDay twoDays) to = GregorianDay tuesday.
	self assert: (GregorianTimespan from: (GregorianYear number: 2004) duration: (TimeUnits year withCells: 10)) to = (GregorianYear number: 2014)! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50880479!
test12FraccionAddsEnteroCorrectly

	self assert: oneFifth + one equals: (Entero withCells: 6) / (Entero withCells: 5)! !
!Parser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50597438!
messagePart: level repeat: repeat

	| start receiver selector args precedence words keywordStart |
	
	[receiver := parseNode.
	(hereType == #keyword and: [level >= 3])
		ifTrue: 
			[start := self startOfNextToken.
			selector := WriteStream on: (String new: 32).
			args := OrderedCollection new.
			words := OrderedCollection new.
			[hereType == #keyword]
				whileTrue: 
					[keywordStart := self startOfNextToken + requestorOffset.
					selector nextPutAll: self advance.
					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 2 repeat: true.
					args addLast: parseNode].
			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])
				ifFalse: [ selector := self correctSelector: selector contents
										wordIntervals: words
										exprInterval: (start to: self endOfLastToken)
										ifAbort: [ ^ self fail ] ].
			precedence := 3]
		ifFalse: [
			
			level >= 2 ifTrue: [self transformVerticalBarAndUpArrowIntoABinarySelector].
			((hereType == #binary )
				and: [level >= 2])
				ifTrue: 
					[start := self startOfNextToken.
					selector := self advance asSymbol.
					words := OrderedCollection withCells: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
					self primaryExpression ifFalse: [^self expected: 'Argument'].
					self messagePart: 1 repeat: true.
					args := Array withCells: parseNode.
					precedence := 2]
				ifFalse: [hereType == #word
						ifTrue: 
							[start := self startOfNextToken.
							selector := self advance.
							args := #().
							words := OrderedCollection withCells: (start  + requestorOffset to: self endOfLastToken + requestorOffset).
							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])
								ifFalse: [ selector := self correctSelector: selector
													wordIntervals: words
													exprInterval: (start to: self endOfLastToken)
													ifAbort: [ ^ self fail ] ].
							precedence := 1]
						ifFalse: [^args notNil]]].

	parseNode := MessageNode new
				receiver: receiver
				selector: selector
				arguments: args
				precedence: precedence
				from: encoder
				sourceRange: (start to: self endOfLastToken)
				keywordsRanges: words.
	repeat]
		whileTrue: [].
	^true! !
!ReplaceIfNilWithPolymorphismParameters class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50792366!
sourceOfMessageNode: aMessageNode

	| stream |

	stream := RWBinaryOrTextStream withCells: Array new.
	aMessageNode printOn: stream indent: 0.

	^stream contents asString.! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50777811!
test23OldSelectorIsRenamedWhenDefinedInLiteralArray

	| rename senderMethod referencerToOldSelector |
	
	referencerToOldSelector := #m1.
	self createClassToRefactor.
	classToRefactor compile: oldSelector asString.
	classToRefactor compile: referencerToOldSelector asString , ' ^#(#' , oldSelector asString, ')'.

	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>referencerToOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: referencerToOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector) 
! !
!String class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 16917814!
crString
	"Answer a string containing a single carriage return character."

	^ self withCells: Character cr! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:00' prior: 50741347!
testRulesThatIncludeADate

	| timeLineFilter rule1 rule2 rule3 september14Of2005 september15Of2005 september16Of2005 |

	september14Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 14.
	september15Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 15.
	september16Of2005 := FixedGregorianDate yearNumber: 2005 monthNumber: 09 dayNumber: 16.
	timeLineFilter := TimeLineFilter new.
	rule1 := timeLineFilter dateRule: september14Of2005.
	rule2 := timeLineFilter dateRule: september15Of2005.
	rule3 := timeLineFilter dateRule: september16Of2005.

	timeLineFilter addRules: (OrderedCollection with: rule1 with: rule2 with: rule3).

	self assert: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollection withCells: rule1).
	self deny: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollection withCells: rule1).
	self deny: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollection withCells: rule1).
	
	self deny: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollection withCells: rule2).
	self assert: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollection withCells: rule2).
	self deny: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollection withCells: rule2).
	
	self deny: (timeLineFilter rulesThatInclude: september14Of2005) = (OrderedCollection withCells: rule3).
	self deny: (timeLineFilter rulesThatInclude: september15Of2005) = (OrderedCollection withCells: rule3).
	self assert: (timeLineFilter rulesThatInclude: september16Of2005) = (OrderedCollection withCells: rule3)! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50746131!
testDistanceTo

	self assert:
		((GregorianYear createYear: 2005) absoluteDistanceTo: (GregorianYear number: 2008)) =
			(TimeUnits year withCells: 3)! !
!VariableNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50810374 overrides: 50810339!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	"This is other possible implementation... the problem is that self can be referenced in a method that
	is being executed in a subclass, so self in that context is the subclass no the class where the method
	is defined. 
	If I use the below implementation, the Float>>#storeOn:base: version RNG 10/12/2018 05:43:39
	passes the typecheck. If the above implementation is used, that version does not passes the type check
	because 'self infinite' returns type will be True and not Boolean.
	On the other hand, with the below implementation, if in ProtoObject I type 'self initialize ' and ask for the
	autocompleter, it will look for selectors in all subclasses of ProtoObject, while with the above implementation
	it does not.
	In a statically typed language, self would 'statically' reference only to instances of the class where the method
	is defined, in dynamically typed languages self it would be valid to send a message to self defined in a subclass
	because self could be referencing an instance of a subclass. So the behavior of self when analized statically is 
	different, although sending a message to self not defined in the method's class hierarchy is not really a good
	practice.
	This is something to continue thinking about. Maybe both strategies are valid and contextual to what we are
	doing, if typechecking or autocompete, etc - Hernan "
	
	self isSelfPseudoVariable ifTrue: [ ^{aCompiledMethod methodClass} ].
	"self isSelfPseudoVariable ifTrue: [ ^aCompiledMethod methodClass withAllSubclasses ]."
	
	self isSuperPseudoVariable ifTrue: [ ^{aCompiledMethod methodClass superclass} ].
	"self isSuperPseudoVariable ifTrue: [ ^aCompiledMethod methodClass superclass withAllSubclasses ]."
	
	self isTruePseudoVariable ifTrue: [ ^`Array withCells: true class` ].
	self isFalsePseudoVariable ifTrue: [ ^`Array withCells: false class` ].
	self isThisContextPseudoVariable ifTrue: [ ^`Array withCells: MethodContext` ]. 
	self isNilPseudoVariable ifTrue: [ ^`Array withCells: nil class` ]. 
	
	self error: 'Unsupported variable node'! !
!DefinedByRulesTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50739610!
testRulesThatInclude

	| set rule1 rule2 |
	
	set := DefinedByRules for: NaturalNumbersTestUniverse new.
	set 
		addRule: (rule1 := SpecificObjectInclusionRule for: 1);
		addRule: (rule2 := SpecificObjectInclusionRule for: 2).
		
	self assert: (set rulesThatInclude: 1) size = 1.
	self assert: ((set rulesThatInclude: 1) includesAllOf: (OrderedCollection withCells: rule1)).

	self assert: (set rulesThatInclude: 2) size = 1.
	self assert: ((set rulesThatInclude: 2) includesAllOf: (OrderedCollection withCells: rule2)).

	self assert: (set rulesThatInclude: 3) isEmpty! !
!GregorianYear class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50738369!
initializeOneYear

	OneYear := TimeUnits year withCells: 1! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50723729!
testIntegerDividedByUnit

	| secondOverMeter |
	secondOverMeter := meterOverSecond reciprocal.
	
	self assert: (5 / meterOverSecond) = (secondOverMeter withCells: 5).
	self assert: (5 / meterOverSecond) numerator = (second withCells: 5).
	self assert: (5 / meterOverSecond) denominator = (meter withCells: 1).
	! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50721397!
testDivideByMinusInfinity

	| kelvin |

	kelvin := BaseUnit named: 'kelvin'.
	self assert: kelvin / minusInfinity = (kelvin withCells: 1 / minusInfinity).
	self assert: (kelvin / minusInfinity) numerator = 0.
	self assert: (kelvin / minusInfinity) denominator = 1.
	self
		should: [minusInfinity / kelvin]
		raise: IndeterminateOperationException
		withExceptionDo: [:anException |
			self assert:
				anException description =
					'The Division operation is indeterminate between Minus Infinity and kelvin']! !
!PlusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50726004!
testEqualsMeasure

	| measure |

	measure := (BaseUnit named: 'peso') withCells: 5.
	self assert: (infinity equalsSimpleMeasure: infinity).
	self deny: (infinity equalsSimpleMeasure: measure)! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 16795583!
moveCategoryTop: catString
	| category newCategories |
	category _ catString asSymbol.
	newCategories _ (Array withCells: category), (categoryArray copyWithout: category).
	self categories: newCategories! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50726846!
testIsFraction

	self deny: (self meter withCells: 1) isFraction.
	self deny: (self centimeter withCells: 12) isFraction.
	self deny: ((self peso * self meter) withCells: 44) isFraction.
	self deny: ((self peso / self meter) withCells: 1234) isFraction.
	self deny: (self meter withCells: 1.05) isFraction.
	self deny: (self centimeter withCells: 1.05) isFraction.
	self deny: ((self peso * self meter) withCells: 1.05) isFraction.
	self deny: ((self peso / self meter) withCells: 1.05) isFraction

! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50743392!
testTimeToEndOfDay

	self assert: januaryFirstOf2004On03Hours timeToEndOfDay = (TimeUnits hour withCells: 21).
	self assert: januaryFirstOf2004 timeToEndOfDay = (TimeUnits hour withCells: 24).
	self assert: januaryFirstOf2004On23Hours59Minutes59Seconds timeToEndOfDay = (TimeUnits second withCells: 1)! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50744294!
ceroMonths
	
	^TimeUnits month withCells: 0! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50745949!
oneYear
	
	^TimeUnits year withCells: 1! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50745955!
tenYears
	
	^TimeUnits year withCells: 10! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50918208!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!ChangeSelectorApplier methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50811279!
handleCanNotChangeSelectorWithNotIncludedTypes: anError

	| errorIcon messageSendWithInvalidReceiverType selection selectionMenu |
	
	errorIcon := Theme current closeIcon.
	selectionMenu := PopUpMenu 
		labelArray: anError messageSendsWithInvalidReceiverTypesAsLabels
		lines: #()  
		icons: ((1 to: anError messageSendsWithInvalidReceiverTypes size) collect: [ :aNumber | errorIcon ]).
		
	selection := selectionMenu startUpWithCaption: anError messageText. 
	selection = 0 ifFalse: [ 
		messageSendWithInvalidReceiverType := anError messageSendsWithInvalidReceiverTypes at: selection.
		MessageSetWindow 
			openMessageList: (Array withCells: (MethodReference method: messageSendWithInvalidReceiverType first)) 
			label: 'Missing implementor types: ', messageSendWithInvalidReceiverType third asCommaStringAnd
			autoSelect: (String streamContents: [ :stream | messageSendWithInvalidReceiverType second printOn: stream indent: 0 ])].
		
	self endRequest 
! !
!DenotativeObjectCompleter methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50816608!
computeMessageEntriesWithoutBinaryMessageForDenotativeObject: aDenotativeObject

	selectorsClasses := Array withCells: aDenotativeObject.
	
	entries := (DenotativeObjectAutoCompleterSelectorsCollector for: prefix) 
		addSelectorsOf: aDenotativeObject upTo: (DenotativeObject class superclass);
		entriesToShow.
	
! !
!DifferenceFinder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 16834207!
lcsAt: i at: j
	| lcs |
	(i = 0 or: [j = 0]) ifTrue: [^Set withCells: #() "EmptyLCS"].
	lcs := matrix i: i j: j.
	lcs ifNil: [
		lcs := self computeLcsAt: i at: j.
		matrix i: i j: j put: lcs].
	^lcs
! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50743326!
testTimeFrom

	self assert: (januaryFirstOf2004On00Hours00Minutes01Seconds distanceFrom: januaryFirstOf2004) = (TimeUnits second withCells: 1).
	self assert: (januarySecondOf2004On23Hours distanceFrom: januaryFirstOf2004) = ((TimeUnits day withCells: 1) + (TimeUnits hour withCells: 23)).
	self  assert: (januarySecondOf2004 distanceFrom: januaryFirstOf2004) = (TimeUnits day withCells: 1).
	self assert: (januaryThirdOf2004 distanceFrom: januaryFirstOf2004) = (TimeUnits day withCells: 2).
	self assert: (januaryFirstOf2004 distanceFrom: januaryFirstOf2004On00Hours00Minutes01Seconds) = (TimeUnits second withCells: -1).
	self assert: (januaryFirstOf2004 distanceFrom: januarySecondOf2004) = (TimeUnits day withCells: -1).
	self assert: (januaryFirstOf2004 distanceFrom: januaryThirdOf2004) = (TimeUnits day withCells: -2)! !
!TrieTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50767346!
testIncludesReturnsTrueForIncludedStrings
	
	self assert: ((Trie withCells: 'hello') includes: 'hello')
	! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50789165!
test07VariablesToParametrizeMustNotBeRepeated

	| orderedDefinitionsWithRepeatedVariableNames |

	orderedDefinitionsWithRepeatedVariableNames := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'variableName'
			useKeyword: #with
			withParameterName: 'p1'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'variableName'
			useKeyword: #with
			withParameterName: 'p2'}.

	self
		should: [VariablesToParametrizeKeywordsDefinitions withCells: orderedDefinitionsWithRepeatedVariableNames]
		raise: RefactoringError
		withMessageText: [VariablesToParametrizeKeywordsDefinitions variableNamesMustNotBeRepeatedErrorMessage].! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50731746 overrides: 50730503!
divideSimpleMeasure: aMeasure

	| numerator denominator |
	
	numerator := aMeasure convertToBaseUnit.
	denominator := self convertToBaseUnit.
	
	^numerator unit / denominator unit 
		withCells: numerator amount / denominator amount! !
!NumeroTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50880441!
test08FraccionAddsWithFraccionCorrectly
"
    La suma de fracciones es:
	 
	a/b + c/d = (a.d + c.b) / (b.d)
	 
	SI ESTAN PENSANDO EN LA REDUCCION DE FRACCIONES NO SE PREOCUPEN!!
	TODAVIA NO SE ESTA TESTEANDO ESE CASO
"
	| sevenTenths |

	sevenTenths := (Entero withCells: 7) / (Entero withCells: 10).

	self assert: oneFifth + oneHalf equals: sevenTenths! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50723588!
testDivideByInfinity

	self assert: meterOverSecond / infinity = (meterOverSecond withCells: 0).
	self assert: (meterOverSecond / infinity) numerator = (meter withCells: 0).
	self assert: (meterOverSecond / infinity) denominator = (second withCells: 1).
	self
		should: [infinity / meterOverSecond]
		raise: IndeterminateOperationException
		withExceptionDo: [:anException |
			self assert:
				anException description =
					'The Division operation is indeterminate between Infinity and meter/second']! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50741521!
zeroDays
	
	^TimeUnits day withCells: 0! !
!WriteStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 16946655!
with: aCollection 
	"Answer an instance of me on the argument, aCollection, positioned to 
	store objects at the end of aCollection."

	^self basicNew withCells: aCollection! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:01' prior: 50743567!
testDaysTo

	self assert: ((GregorianDayOfMonth monthNumber: 12 dayNumber: 31)
		distanceTo: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31)) = (TimeUnits day withCells: 0).
	self assert: ((GregorianDayOfMonth monthNumber: 12 dayNumber: 31)
		distanceTo: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 1).
	self assert: ((GregorianDayOfMonth monthNumber: 1 dayNumber: 1)
		distanceTo: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31)) = (TimeUnits day withCells: 365).
	self assert: ((GregorianDayOfMonth monthNumber: 1 dayNumber: 10)
		distanceTo: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1)) = (TimeUnits day withCells: 357)! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50777129!
test16FailsWhenNewVariableEqualsArgumentOfAMethodInClass

	| selector |

	self createClassToRefactor.
	selector := #m1:.
	classToRefactor compile: selector, newVariable.
	
	self 
		assertCreation: [ RenameInstanceVariable from: oldVariable to: newVariable in: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50724980!
testFloatMultipliedByUnitTwice

	| kelvin |
	kelvin := BaseUnit named: 'kelvin'.

	self assert: (5.5 * kelvin * meterBySecond) = (kelvin * meterBySecond withCells: 5.5).
	self assert: (5.5 * kelvin * meterBySecond) numerator = (kelvin * meterBySecond withCells: 5.5 numerator).
	self assert: (5.5 * kelvin * meterBySecond) denominator = 5.5 denominator! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50723836!
testMultiplyByMinusInfinity

	self assert: meterOverSecond * minusInfinity = (meterOverSecond withCells: minusInfinity).
	self assert: minusInfinity * meterOverSecond = (meterOverSecond withCells: minusInfinity).
	self assert: (meterOverSecond * minusInfinity) numerator = (meter withCells: minusInfinity).
	self assert: (meterOverSecond * minusInfinity) denominator = (second withCells: 1)! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50789189!
test08CreatesVariablesToParametrizeKeywordsDefinitionsWithDefinitions

	| definitions orderedDefinitions |

	orderedDefinitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'v1'
			useKeyword: #k1
			withParameterName: 'p1'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'v2'
			useKeyword: #k2
			withParameterName: 'p2'}.

	definitions := VariablesToParametrizeKeywordsDefinitions withCells: orderedDefinitions.

	self assert: 2 equals: definitions variablesToParametrize size.
	self assert: (definitions variablesToParametrize includesAllOf: #('v1' 'v2')).! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 16869434!
transformWhile: encoder
	(self checkBlock: receiver as: 'receiver' from: encoder maxArgs: 0) ifFalse:
		[^false].
	arguments size = 0 ifTrue:  "transform bodyless form to body form"
		[selector := SelectorNode new
						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])
						code: #macro.
		 arguments := Array withCells: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).
		 receiver noteOptimizedIn: self.
		 ^true].
	^(self transformBoolean: encoder)
	   and: [receiver noteOptimizedIn: self.
			arguments first noteOptimizedIn: self.
			true]! !
!VariablesToParametrizeKeywordsDefinitionsTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50789221!
test10WhenVariablesToParametrizeBuildsSelectorFromKeywordsInOrder

	| definitions orderedDefinitions |

	orderedDefinitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'v1'
			useKeyword: #k1
			withParameterName: 'p1'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'v2'
			useKeyword: #k2
			withParameterName: 'p2'}.

	definitions := VariablesToParametrizeKeywordsDefinitions
		withCells: orderedDefinitions.

	self assert: #k1:k2: equals: definitions selector.! !
!LiteralVariableNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50810472 overrides: 50957691!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^ Array withCells: key value class! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50724943!
testFloatDividedByUnit

	self assert: (5.5 / meterBySecond) = (5.5 / (meterBySecond withCells: 1)).
	self assert: (5.5 / meterBySecond) numerator = 5.5 numerator.
	self assert: (5.5 / meterBySecond) denominator = (meterBySecond withCells: 5.5 denominator)! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 16848115!
makeAllPixelsOpaqueBlack
	"Make all pixels opaque black.
	Useful for preparing 32bpp forms for later stuff.
	Set alpha values to 255 for all pixels.
	Set r, g, b values to zero for all pixels."
	| bitBlt |
	bitBlt _ BitBlt toForm: self.
	bitBlt combinationRule: 3.
	bitBlt fillBitmap: (Bitmap withCells: 16rFF000000).
	bitBlt copyBits! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50785577!
test61MethodObjectClassInstanceCreationMessageParameterNamesAreTheChosenOnes

	| keywordsDefinitions variablesToParametrizeToInstanceVariables refactor methodObjectClass instanceCreationMethod |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'.} asDictionary.
	keywordsDefinitions := {self keyword: #with varName: 'self' paramName: 'aParamName'}.

	refactor := ExtractToMethodObject
				from: self compiledMethodReferencingSelf
				toMethodObjectClassNamed: self methodObjectClassName
				subclassing: self methodObjectSuperclass
				onCategory: self classCategoryOfTestData
				withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
				withInstanceCreationMessageFrom: keywordsDefinitions
				evaluatedWith: self defaultEvaluationSelector.

	refactor apply.

	methodObjectClass := (Smalltalk classNamed: self methodObjectClassName) class.
	instanceCreationMethod := methodObjectClass compiledMethodAt: #withCells:.

	self assert: 'aParamName' equals: instanceCreationMethod methodNode arguments first name.! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50787323 overrides: 50953830!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData ! !
!IsKindOfTypeCastApplierBuilder methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50806756 overrides: 50806552!
buildCastApplierBefore: aPreviousCastingApplier 

	^EffectiveTypeCastApplier 
		casts: (OrderedCollection withCells: self buildTypeCast)
		rejections: OrderedCollection new
		previous: aPreviousCastingApplier
	! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50723617!
testDivideByMinusInfinity

	self assert: meterOverSecond / minusInfinity = (meterOverSecond withCells: 0).
	self assert: (meterOverSecond / minusInfinity) numerator = (meter withCells: 0).
	self assert: (meterOverSecond / minusInfinity) denominator = (second withCells: 1).
	self
		should: [minusInfinity / meterOverSecond]
		raise: IndeterminateOperationException
		withExceptionDo: [:anException |
			self assert:
				anException description =
					'The Division operation is indeterminate between Minus Infinity and meter/second']! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50743192!
testNow

	| now nowInTwoSeconds |
	
	now := GregorianDateTime now.
	(Delay forSeconds: 1) wait.
	nowInTwoSeconds := GregorianDateTime now.
	
	self assert: now < nowInTwoSeconds.
	self assert: ((now distanceTo: nowInTwoSeconds) - (TimeUnits second withCells: 1)) abs <= (TimeUnits millisecond withCells: 10)! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50721575!
testIntegerMultipliedByUnitTwice

	| kelvin meter |
	
	kelvin := BaseUnit named: 'kelvin'.
	meter := BaseUnit named: 'meter'.
	
	self assert: 5 * kelvin * meter = (kelvin * meter withCells: 5).
	self assert: (5 * kelvin * meter) numerator = (kelvin * meter withCells: 5).
	self assert: (5 * kelvin * meter) denominator = 1.
! !
!GregorianDateTimeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50743211!
testReverse

	| collection date hours |
	collection := (januaryFirstOf2004
				to: januarySecondOf2004On23Hours
				by: (TimeUnits hour withCells: 2)) reverse.
	date := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 02.
	hours := 22.
	collection do: [:aGregorianDateTime | 
		self assert: aGregorianDateTime date = date.
		self assert: aGregorianDateTime timeOfDay = (TimeOfDay hours: hours).
		hours := hours - 2.
		hours = -2 
			ifTrue: [
				date := date previous.
				hours := 22]].
	self assert: date = (FixedGregorianDate yearNumber: 2003 monthNumber: 12 dayNumber: 31).
	self assert: hours = 22! !
!TestIntervalAwareMagnitude methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50719500 overrides: 50719458!
defaultIntervalIncrement

	^self class withCells: 1! !
!ProportionalUnitConversionFunctionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50726503!
testValidValues

	| function |
	
	function := ProportionalUnitConversionFunction measure: onePeso isProportionalTo: tenDollars.
	self assert: (function value: (peso withCells: 3)) = (dollar withCells: 30).
	self assert: (function value: onePeso) = tenDollars.

	function := ProportionalUnitConversionFunction measure: tenDollars isProportionalTo: onePeso.
	self assert: (function value:tenDollars) = onePeso.
	self assert: (function value:(dollar withCells: 1)) = (onePeso/10)
	! !
!MinusInfinityTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50724718!
testSameDomainAs

	self assert: (minusInfinity sameDomainAs: 1).
	self deny: (minusInfinity sameDomainAs: ((BaseUnit named: 'peso') withCells: 1))! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:02' prior: 50788351!
test07ParameterNamesMustNotBeEqualToABlockTemporal

	| variablesToParametrizeKeywordsDefinitions sourceWithIf definitions |

	sourceWithIf := 'm1 anInstVar ifNil: [ | tempVar | tempVar := 1 + 1. self isNil].'.
	definitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'self'
			useKeyword: #with
			withParameterName: 'tempVar'}.
	variablesToParametrizeKeywordsDefinitions :=
		VariablesToParametrizeKeywordsDefinitions withCells: definitions.
	self creationFromSource: sourceWithIf withDefinitions: variablesToParametrizeKeywordsDefinitions failsWithMessageText: [
			ReplaceIfNilWithPolymorphismParameters parameterNameMustNotBeEqualToBlockTemporaryErrorMessage].! !
!GregorianDate methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50735908!
to: aGregorianDate everyDayOfMonth: aGregorianDayOfMonth 

	^self to: aGregorianDate everyDayOfMonths: (Array withCells: aGregorianDayOfMonth)! !
!GraphTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50721046!
testRemoveNodeWithInvalidNode

	| graph |

	graph := Graph edges: (Array withCells: (Edge from: 'a' to: 'b')).

	self
		should: [graph removeNode: 'd']
		raise: NodeNotFoundException
		withExceptionDo: [ :anException |
			self
				assert: anException description notEmpty;
				assert: anException node = 'd';
				assert: anException graph = graph]! !
!FixedGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50741507!
tenDays
	
	^TimeUnits day withCells: 10! !
!AddInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50772086!
test05NewVariableNameCanNotBeDefinedInClass

	| classToRefactor |
	
	newVariable := 'a'.
	classToRefactor := self createClassNamed: self classToRefactorName instanceVariableNames: newVariable.
	
	self 
		assertCreation: [AddInstanceVariable named: newVariable to: classToRefactor ]
		failsWith: [NewInstanceVariablePrecondition errorMessageForNewInstanceVariable: newVariable alreadyDefinedInAll: (Array withCells: classToRefactor )]
	! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 16848099!
makeAllPixelsOpaque
	"Fix the alpha channel if the receiver is 32bit
	Set alpha values to 255 for all pixels.
	Note: assumes that a pixel with 0 is meant to be black, not transparent (As Squeak / Cuis usually handles rgb=0 for bpp<=16).
	See #fixAlpha"
	| bitBlt |
	self depth = 32 ifFalse: [ ^self ].
	bitBlt := BitBlt toForm: self.
	bitBlt combinationRule: 7. "bitOr:with:"
	bitBlt fillBitmap: (Bitmap withCells: 16rFF000000).
	bitBlt copyBits! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50720498!
testToNegativeBy

	| interval number |
	
	interval := (TestIntervalAwareMagnitude withCells: 20) to: (TestIntervalAwareMagnitude withCells: 10) by: (TestIntervalAwareMagnitude withCells: -3).
	number := 20.
	interval do: [ :each |
		self assert: each number = number.
		number := number - 3 ].
	
	self assert: number = 8! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50725004!
testIntegerDividedByUnitTwice

	| kelvin |
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5 / kelvin / meterBySecond) = (5 / (kelvin * meterBySecond withCells: 1)).
	self assert: (5 / kelvin / meterBySecond) numerator = 5.
	self assert: (5 / kelvin / meterBySecond) denominator = (kelvin * meterBySecond withCells: 1).
	
! !
!GregorianMonthOfYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50744560!
testNumberOfDays

	self assert: (GregorianMonthOfYear januaryOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31).
	self assert: (GregorianMonthOfYear februaryOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 29).
	self assert: (GregorianMonthOfYear februaryOf: (GregorianYear number: 2003)) numberOfDays = (TimeUnits day withCells: 28).
	self assert: (GregorianMonthOfYear marchOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31).
	self assert: (GregorianMonthOfYear aprilOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 30).
	self assert: (GregorianMonthOfYear mayOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31).
	self assert: (GregorianMonthOfYear juneOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 30).
	self assert: (GregorianMonthOfYear julyOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31).
	self assert: (GregorianMonthOfYear augustOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31).
	self assert: (GregorianMonthOfYear septemberOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 30).
	self assert: (GregorianMonthOfYear octoberOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31).
	self assert: (GregorianMonthOfYear novemberOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 30).
	self assert: (GregorianMonthOfYear decemberOf: (GregorianYear number: 2004)) numberOfDays = (TimeUnits day withCells: 31)! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 16923078!
calcEndianness
	| bytes word blt |
	"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte."
	"Smalltalk endianness"

	bytes _ ByteArray withAll: #(0 0 0 0).  "(1 2 3 4) or (4 3 2 1)"
	word _ WordArray withCells: 16r01020304.
	blt _ (BitBlt toForm: (Form new hackBits: bytes)) 
				sourceForm: (Form new hackBits: word).
	blt combinationRule: Form over.  "store"
	blt sourceY: 0; destY: 0; height: 1; width: 4.
	blt sourceX: 0; destX: 0.
	blt copyBits.  "paste the word into the bytes"
	bytes first = 1 ifTrue: [^ #big].
	bytes first = 4 ifTrue: [^ #little].
	self error: 'Ted is confused'.! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50721512!
testFloatMultipliedByUnitTwice

	| kelvin meter |
	
	kelvin := BaseUnit named: 'kelvin'.
	meter := BaseUnit named: 'meter'.
	
	self assert: 5.5 * kelvin * meter = (kelvin * meter withCells: 5.5).
	self assert: (5.5 * kelvin * meter) numerator = (kelvin * meter withCells: 5.5) numerator.
	self assert: (5.5 * kelvin * meter) denominator = (kelvin * meter withCells: 5.5) denominator! !
!MeasureConverterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50724244!
testDirectSearching

	self assert: (moneyConverter convert: self onePeso to: self dollar) = (self dollar withCells: 1/3).
	self assert: (moneyConverter convert: self oneEuro to: self dollar) = (self dollar withCells: 13/10)! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50725028!
testIntegerMultipliedByUnitTwice

	| kelvin |
	kelvin := BaseUnit named: 'kelvin'.

	self assert: (5 * kelvin * meterBySecond) = (kelvin * meterBySecond withCells: 5).
	self assert: (5 * kelvin * meterBySecond) numerator = (kelvin * meterBySecond withCells: 5).
	self assert: (5 * kelvin * meterBySecond) denominator = 1.
	
	! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50726886!
testRoundTo

	self assert: ((SimpleMeasure amount: 1 unit: self celsius) roundTo: 1) = (self celsius withCells: 1).
	self assert: ((SimpleMeasure amount: 1 unit: self celsius) roundTo: 0.1) = (self celsius withCells: 1).
	self assert: ((SimpleMeasure amount: 1.4 unit: self celsius) roundTo: 1) = (self celsius withCells: 1).
	self assert: ((SimpleMeasure amount: 1.5 unit: self celsius) roundTo: 1) = (self celsius withCells: 2).
	self assert: ((SimpleMeasure amount: 1.09 unit: self celsius) roundTo: 1) = (self celsius withCells: 1).
	self assert: ((SimpleMeasure amount: -1 unit: self celsius) roundTo: 1) = (self celsius withCells: -1).
	self assert: ((SimpleMeasure amount: -1.1 unit: self celsius) roundTo: 1) = (self celsius withCells: -1)! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50746848!
testSubtract

	| time |
	
	time := TimeOfDay hours: 1.

	self assert: (time previous: (TimeUnits hour withCells: 1)) timeFromMidnight = (TimeUnits hour withCells: 0).
	self assert: (time previous: (TimeUnits minute withCells: 1)) timeFromMidnight = (TimeUnits minute withCells: 59).
	self assert: (time previous: (TimeUnits second withCells: 1)) timeFromMidnight = (TimeUnits second withCells: (59*60+59)).
	self assert: (time previous: (TimeUnits millisecond withCells: 1)) timeFromMidnight = (TimeUnits millisecond withCells: (59*60000+59999))
! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50747066!
testToBy

	| interval |
	
	interval := TimeOfDay firstTimeOfDay to: TimeOfDay lastTimeOfDay by: (TimeUnits hour withCells: 1).
	
	self assert: interval from = TimeOfDay firstTimeOfDay.
	self assert: interval to = TimeOfDay lastTimeOfDay.
	self assert: interval by = (TimeUnits hour withCells: 1)! !
!SequenceableCollectionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50752054!
testWithIndexDoSeparatedByDoesNotValueSeparatedBlockForCollectionsOfOneElement

	| collectionToTraverse traversedElements |

	collectionToTraverse := OrderedCollection withCells: $a.
	traversedElements := OrderedCollection new.

	self shouldntFail: [ collectionToTraverse withIndexDo: [ :anElement :index | traversedElements add: anElement  -> index ] separatedBy: [ self fail ] ].

	self assert: 1 equals: traversedElements size.
	self assert: $a->1 equals: traversedElements first! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50784296!
test28MethodObjectClassInstanceCreationMessageCreatesARefactoringInstance

	| refactor methodObjectClass keywordToParametrizedVariable variablesToParametrizeToInstanceVariables newRefactoringSourceCode |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'.} asDictionary.
	keywordToParametrizedVariable := {self keyword: #with varName: 'self' paramName: 'aParamName'}.

	refactor := ExtractToMethodObject
				from: self compiledMethodReferencingSelf
				toMethodObjectClassNamed: self methodObjectClassName
				subclassing: self methodObjectSuperclass
				onCategory: self classCategoryOfTestData
				withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
				withInstanceCreationMessageFrom: keywordToParametrizedVariable
				evaluatedWith: self defaultEvaluationSelector.

	refactor apply.

	methodObjectClass := Smalltalk classNamed: self methodObjectClassName.
	newRefactoringSourceCode := 'with: aParamName',
		String newLineString,
		String tab,
		'^self new initializeWith: aParamName'.
	self assert: newRefactoringSourceCode equals: (methodObjectClass class compiledMethodAt: #withCells:) sourceCode.! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50788093 overrides: 50953830!
allClassCategoriesOfTestData

	^Array withCells: self classCategoryOfTestData ! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 16915444!
findAnySubStr: delimiters startingAt: start 
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min ind |
	min _ self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		delim class == Character 
			ifTrue: [ind _ self indexOfSubCollection: (String withCells: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [ind _ self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
			min _ min min: ind].
	^ min! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50881750 overrides: 50883097!
multiplyByEntero: anEntero 

	^self class withCells: (value * anEntero integerValue)! !
!IntervalAwareMagnitudeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50720395!
testMax

	self assert: ((TestIntervalAwareMagnitude withCells: 10) max: (TestIntervalAwareMagnitude withCells: 11)) = (TestIntervalAwareMagnitude withCells: 11).
	self assert: ((TestIntervalAwareMagnitude withCells: 10) max: (TestIntervalAwareMagnitude withCells: 9)) = (TestIntervalAwareMagnitude withCells: 10).
	self assert: ((TestIntervalAwareMagnitude withCells: 10) max: (TestIntervalAwareMagnitude withCells: 10)) = (TestIntervalAwareMagnitude withCells: 10)! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:03' prior: 50786646!
test23PolymorphicMessageIsAddedToTheConcreteClassWithChosenParameterNames

	| sourceWithIf definitions |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ] ifFalse: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	self assert: 'p1' equals: (self concreteClass compiledMethodAt: #withCells:) methodNode arguments first name.! !
!ConversionTableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50723286!
testDerivedUnitIsEquivalentTo

	| table quarter fortyQuarters |
	
	quarter := units quarter.
	fortyQuarters := quarter withCells: 40.
	
	table := ConversionTable new.
	table measure: self oneHundredCents isEquivalentTo: self tenDollars.
	
	self assert: table unitConversionRules size = 2.
	self shouldnt: [ table unitConversionRuleFrom: self peso to: self dollar ] raise: NoUnitConversionRuleException.
	self shouldnt: [ table unitConversionRuleFrom: self dollar to: self peso ] raise: NoUnitConversionRuleException.
	self shouldnt: [ table unitConversionRuleFrom: self cents to: self dollar ] raise: NoUnitConversionRuleException.
	self shouldnt: [ table unitConversionRuleFrom: self dollar to: self cents ] raise: NoUnitConversionRuleException.
	self shouldnt: [ table unitConversionRuleFrom: self cents to: quarter ] raise: NoUnitConversionRuleException.
	self shouldnt: [ table unitConversionRuleFrom: quarter to: self cents ] raise: NoUnitConversionRuleException.
	
	self assert: ((table unitConversionRuleFrom: self peso to: self dollar) value: self onePeso) = self tenDollars.
	self assert: ((table unitConversionRuleFrom: self peso to: self dollar) value: self oneHundredCents) = self tenDollars.

	self assert: ((table unitConversionRuleFrom: self cents to: self dollar) value: self onePeso) = self tenDollars.
	self assert: ((table unitConversionRuleFrom: self cents to: self dollar) value: self oneHundredCents) = self tenDollars.

	self assert: ((table unitConversionRuleFrom: self dollar to: self peso) value: self tenDollars) = self onePeso.
	self assert: ((table unitConversionRuleFrom: self dollar to: self cents) value: self tenDollars) = self oneHundredCents.

	self assert: ((table unitConversionRuleFrom: quarter to: self peso) value: fortyQuarters) = self onePeso.
	self assert: ((table unitConversionRuleFrom: quarter to: self cents ) value: fortyQuarters) = self oneHundredCents! !
!SafelyRemoveClassTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50778510!
test04CanNotRemoveClassWithReferencesOutsideHierarchy

	| classToRemove classReferencing methodNameReferencingClass | 
	
	classToRemove := self createClassNamed: self classToRemoveName.
	classReferencing := self createClassNamed: #ClassReferencingClassToRemove.
	methodNameReferencingClass := #m1.
	classReferencing compile: methodNameReferencingClass asString, ' ^', classToRemove name asString.
	
	self
		should: [ SafelyRemoveClass of: classToRemove ]
		raise: self canNotRefactorDueToReferencesRefactoringError 
		withExceptionDo: [ :anError | | reference |
			self 
				assert: (SafelyRemoveClass errorMessageForCanNotRemove: classToRemove dueToReferencesToAll: (Array withCells: classToRemove))
				equals: anError messageText.
			self assert: 1 equals: anError numberOfReferences.
			reference := anError anyReference.
			self assert: classReferencing name equals: reference classSymbol.
			self assert: methodNameReferencingClass equals: reference methodSymbol ]! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50777346!
test01MessageWithNoSendersCreatesNewMethodAndRemovesOldOne
	
	| rename |
	
	classToRefactor := self createClassNamed: self classToRefactorName..
	classToRefactor compile: oldSelector asString.
	
	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: #().
	rename apply.
	self deny: (classToRefactor includesSelector: oldSelector).
	self assert: (classToRefactor includesSelector: newSelector) 
! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50731842 overrides: 50730585!
remainderSimpleMeasure: aMeasure

	| numerator denominator |
	
	numerator := aMeasure convertToBaseUnit.
	denominator := self convertToBaseUnit.
	
	^numerator baseUnit withCells: numerator amount \\ denominator amount! !
!ClassDescription methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50618272!
withClassesThatDefineInHierarchyInstanceVariable: aName do: foundBlock ifNone: noneBlock

	^(self classThatDefinesInstanceVariable: aName)
		ifNil: [ self withSubclassesThatDefineInstanceVariable: aName do: foundBlock ifNone: noneBlock ]
		ifNotNil: [ :definingClass | foundBlock value: (Array withCells: definingClass) ]! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 16847474!
convertAlphaToZeroValueTransparency
	"For a 32bpp Form, for each pixel, take the alpha value, and if less than 128
	make the pixel value zero (i.e. transparent for 2, 4, 8 and 16 bpp)
	Side effect: make value of alpha = 0 or 128 for all pixels. Not a problem if we're converting to lower bpp anyway...
	This method also loses the lsb of the color components. Again, not a problem for going to lower bpp.
	"
	"
	| bananas1 |
	bananas1 _ Form fromFileNamed: 'bananas1.png'.
	bananas1 convertAlphaToZeroValueTransparency..
	bananas1 convertAlphaToZeroValueTransparency.
	(bananas1 asFormOfDepth: 16) display
	"
	| bitBlt map multiplier |
	self depth = 32 ifFalse: [
		^self ].
	
	"Prepare multiplier to multiply each pixel by 0.5 or 0 (according to alpha)"
	multiplier _ Form extent: self extent depth: 32.
	map _ ColorMap
		masks: { 16r80000000. 16r80000000. 16r80000000. 16r80000000}
		shifts:  { 0.  -8. -16. -24 }.
	bitBlt _ BitBlt new.
	bitBlt
		setDestForm: multiplier;
		sourceForm: self;
		colorMap: map;
		combinationRule: Form over;
		copyBits.
	"Now fix for the fact that using a ColorMap turns pixelValues 0's into 1's"
	bitBlt
		sourceForm: nil;
		colorMap: nil;
		fillBitmap: (Bitmap withCells: 16rFFFFFFFE);
		combinationRule: Form and;
		copyBits.
	"Apply multiplier to ourselves"
	bitBlt
		fillBitmap: nil;
		setDestForm: self;
		sourceForm: multiplier;
		combinationRule: Form rgbMul;
		copyBits.
	"Now correct for the fact that the multiplier had 0.5's and 0's, not 1's and 0's"
	bitBlt
		sourceForm: self;
		combinationRule: 20; "Form rgbAdd"
		copyBits! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50777146!
test17FailsWhenNewVariableEqualsArgumentOfABlockInAMethodInClass

	| selector |

	self createClassToRefactor.
	selector := #m1.
	classToRefactor compile: selector, ' [ :', newVariable, ' | ] value: 1'.
	
	self 
		assertCreation: [ RenameInstanceVariable from: oldVariable to: newVariable in: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!Parser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50584470!
binaryPattern

	^ self advanceWithRangeDo: [ :selectorAsString :selectorRange | | arguments |
		self argumentNameWithRangeDo: [ :argumentName :argumentRange |
		arguments _ Array withCells: (encoder bindArg: argumentName range: argumentRange).
		{selectorAsString asSymbol. arguments. 2. {selectorRange}}]]! !
!GraphPathFinderTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50720687!
testWithLoops

	| path newGraph newFinder edges |

	"Add a cycle from 2 to 2"
	edges := graph edges.
	edges add: (Edge from: 2 to: 2).
	newGraph := Graph edges: edges.
	newFinder := GraphPathFinder on: newGraph.
	
	path := newFinder pathFrom: 1 to: 2.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 1 to: 2))).

	path := newFinder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollection 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).
		
	path := newFinder pathFrom: 2 to: 2.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 2 to: 2))).

	"To the new graph, add a cycle from 3 to 3"	
	edges := graph edges.
	edges add: (Edge from: 3 to: 3).
	newGraph := Graph edges: edges.
	newFinder := GraphPathFinder on: newGraph.

	path := newFinder pathFrom: 1 to: 3.
	self assert: path = (Graph edges: (OrderedCollection 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3))).
		
	path := newFinder pathFrom: 1 to: 4.
	self assert: path = (Graph edges: (OrderedCollection 
		with: (Edge from: 1 to: 2)
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
		
	path := newFinder pathFrom: 3 to: 3.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 3 to: 3))).
		
	path := newFinder pathFrom: 2 to: 4.
	self assert: path = (Graph edges: (OrderedCollection 
		with: (Edge from: 2 to: 3)
		with: (Edge from: 3 to: 4))).
		
	path := newFinder pathFrom: 3 to: 4.
	self assert: path = (Graph edges: (OrderedCollection 
		withCells: (Edge from: 3 to: 4)))! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50721438!
testDivideByNumber

	| kelvin |
	
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: kelvin / 5 = (kelvin withCells: 1/5).
	self assert: (kelvin / 5) numerator = (kelvin withCells: 1).
	self assert: (kelvin / 5) denominator = 5.
	
	self assert: kelvin / 5.5 = (kelvin withCells: 1/5.5).
	self assert: (kelvin / 5.5) numerator = (kelvin withCells: 1/5.5) numerator.
	self assert: (kelvin / 5.5) denominator = (kelvin withCells: 1/5.5) denominator! !
!String methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 16915555!
findTokens: delimiters
	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."

	| tokens keyStart keyStop separators |

	tokens _ OrderedCollection new.
	separators _ delimiters class == Character 
		ifTrue: [Array withCells: delimiters]
		ifFalse: [delimiters].
	keyStop _ 1.
	[keyStop <= self size] whileTrue:
		[keyStart _ self skipDelimiters: separators startingAt: keyStop.
		keyStop _ self findDelimiters: separators startingAt: keyStart.
		keyStart < keyStop
			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].
	^tokens! !
!TestIntervalStrategy methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50732875 overrides: 50732777!
advanceFrom: from steps: steps by: by

	^TestIntervalAwareMagnitude withCells: from number + (steps * by number)! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50725018!
testIntegerMultipliedByUnit

	self assert: (5 * meterBySecond) = (meterBySecond withCells: 5).
	self assert: (5 * meterBySecond) numerator = (meterBySecond withCells: 5).
	self assert: (5 * meterBySecond) denominator = 1.
! !
!ChangeEvent methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50826299!
timeDifferenceWithPreviousChange
	| previousEvent timeDifference |
	
	previousEvent := self previousEvent.
	previousEvent ifNil: [ ^ '00m00s' ].
	
	timeDifference := self change time distanceFrom: previousEvent change time.

	timeDifference > (TimeUnits hour withCells: 1)
		ifTrue: [ ^ '>1 hour' ] 
		ifFalse: [ ^ (self minutesAsString: timeDifference), 'm', (self secondsAsString: timeDifference), 's' ] ! !
!Object methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 16881831!
perform: aSymbol with: anObject 
	"Send the selector, aSymbol, to the receiver with anObject as its argument.
	Fail if the number of arguments expected by the selector is not one.
	Primitive. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 83>
	^ self perform: aSymbol withArguments: (Array withCells: anObject)! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50881757 overrides: 50883102!
multiplyByFraccion: aFraccion

	| numerator |
	numerator := self class withCells: (value * (aFraccion numerator integerValue)).
	^ numerator / aFraccion denominator.! !
!Entero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50880854!
// aDivisor 
	
	^self class withCells: value // aDivisor integerValue! !
!BlockNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 16790046!
statements: statementsCollection returns: returnBool 
	"Decompile."

	| returnLast |
	returnLast := returnBool.
	returns := false.
	statements := 
		(statementsCollection size > 1 
			and: [(statementsCollection at: statementsCollection size - 1) 
					isReturningIf])
				ifTrue: 
					[returnLast := false.
					statementsCollection allButLast]
				ifFalse: [statementsCollection size = 0
						ifTrue: [Array withCells: NodeNil]
						ifFalse: [statementsCollection]].
	arguments := #().
	temporaries := #().
	optimized := false.
	returnLast ifTrue: [self returnLast]! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50785685!
test64MethodObjectInstanceCreationMessageIsCategorizedAsInstanceCreation

	| keywordsDefinitions variablesToParametrizeToInstanceVariables refactor instanceCreationMethod methodObject |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'.} asDictionary.
	keywordsDefinitions := {self keyword: #with varName: 'self' paramName: 'aParamName'}.

	refactor := ExtractToMethodObject
				from: self compiledMethodReferencingSelf
				toMethodObjectClassNamed: self methodObjectClassName
				subclassing: self methodObjectSuperclass
				onCategory: self classCategoryOfTestData
				withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
				withInstanceCreationMessageFrom: keywordsDefinitions
				evaluatedWith: self defaultEvaluationSelector.

	refactor apply.

	methodObject := Smalltalk classNamed: self methodObjectClassName.
	instanceCreationMethod := methodObject class compiledMethodAt: #withCells:.

	self assert: #'instance creation' equals: instanceCreationMethod category.! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:04' prior: 50786748!
test27ReplacesIfNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!GregorianDateTime methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50736501 overrides: 50735685!
next: aTimeMeasure

	| timeToAdd daysToAdd newTime |
	
	timeToAdd := timeOfDay timeFromMidnight + aTimeMeasure.
	daysToAdd := TimeUnits day withCells: (timeToAdd // GregorianDay oneDay).
	newTime := timeToAdd \\ GregorianDay oneDay. 
	
	^self class date: (date next: daysToAdd) timeOfDay: (TimeOfDay timeFromMidnight: newTime)
	

	
! !
!MeasureConverterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50724253!
testIndirectSearching

	self assert: (moneyConverter convert: self onePeso to: self euro) = (self euro withCells: 10/39).
	self assert: (moneyConverter convert: self oneEuro to: self peso) = (self peso withCells: 39/10)! !
!ObjectFinalizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 16883631!
receiver: aReceiver selector: aSelector argument: anObject
	receiver := aReceiver.
	selector := aSelector.
	arguments := Array withCells: anObject! !
!RobotTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50918196!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot withCells: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RelativeGregorianDateTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50740211 overrides: 16927572!
setUp

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
	timeLineFilter addDayRule: GregorianDay sunday.

	relativeDate :=
		RelativeGregorianDate
			timespan: (
				GregorianTimespan
					from: (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01)
					duration: (TimeUnits hour withCells: 72))
			using: timeLineFilter negated.

	absoluteDate := FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 06! !
!DropFilesAction methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50649154!
createMenuFor: options

	| icons lines labels |

	"options is a small collection, no problem to collect twice - Hernan"	
	labels := options collect: [ :option | option label ].
	icons := options collect: [ :option | option iconSpec ].

	shouldAskToStop 
		ifTrue: [
			lines := Array withCells: labels size.
			labels add: 'stop here'.
			icons add: #cancelIcon ]
		ifFalse: [ lines := #() ].
		
	^PopUpMenu labelArray: labels lines: lines icons: icons! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 16868064!
printIfNil: aStream indent: level

	self printReceiver: receiver on: aStream indent: level.

	^self printKeywords: selector key
		arguments: (Array withCells: arguments first)
		on: aStream indent: level! !
!ChangeSelectorApplier methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50616902!
createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor 
		
	implementors := Array withCells: anImplementor.
	senders := #().
	shouldShowChanges := false.
	
	self createAndApplyRefactoring ! !
!GregorianDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:05' prior: 50744052!
testDaysFrom

	self assert: (GregorianDay monday distanceFrom: GregorianDay monday) = GregorianDay zeroDays.
	self assert: (GregorianDay monday distanceFrom: GregorianDay tuesday) = (TimeUnits day withCells: 6).
	self assert: (GregorianDay monday distanceFrom: GregorianDay wednesday) = (TimeUnits day withCells: 5).
	self assert: (GregorianDay monday distanceFrom: GregorianDay thursday) = (TimeUnits day withCells: 4).
	self assert: (GregorianDay monday distanceFrom: GregorianDay friday) = (TimeUnits day withCells: 3).
	self assert: (GregorianDay monday distanceFrom: GregorianDay saturday) = GregorianDay twoDays.
	self assert: (GregorianDay monday distanceFrom: GregorianDay sunday) = GregorianDay oneDay.
! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50786720!
test26ReplacesIfNotNilIfNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNotNil: [ self isNil ] ifNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!Class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 16802935!
addSubclass: aSubclass 
	"Make the argument, aSubclass, be one of the subclasses of the receiver. 
	Create an error notification if the argument's superclass is not the receiver."
	
	aSubclass superclass ~~ self 
		ifTrue: [^self error: aSubclass name , ' is not my subclass'].
	subclasses ifNil: [
		subclasses _ Array withCells: aSubclass.
		^self].
	subclasses do:[:cl| cl == aSubclass ifTrue:[^self]]. "Already my subclass"
	subclasses _ subclasses copyWith: aSubclass.! !
!NegatedTimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50739905!
testNextPositiveDuration

	| timeLineFilter date |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
		
	date := (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 01).
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day withCells: 1))) = date next.
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day withCells: 2))) = (date next: (TimeUnits day withCells: 3)).
	self assert: (timeLineFilter negated next: (GregorianTimespan from: date duration: (TimeUnits day withCells: 0))) = date! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50736653!
initializeOneDay

	OneDay := TimeUnits day withCells: 1! !
!MessageSend class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 16869790!
receiver: anObject selector: aSymbol argument: aParameter
	^ self receiver: anObject selector: aSymbol arguments: (Array withCells: aParameter)! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 16795559!
moveCategoryBottom: catString
	| category newCategories |
	category _ catString asSymbol.
	newCategories _ (categoryArray copyWithout: category), (Array withCells: category).
	self categories: newCategories.
	^ newCategories size! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50731808 overrides: 50730551!
quoFrom: aNumber

	^NullUnit new / unit withCells: (aNumber quo: amount)! !
!Numero methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50880721!
negated
	
	^self * (Entero withCells: -1)! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50724894!
testDivideByMinusInfinity

	self assert: meterBySecond / minusInfinity = (meterBySecond withCells: 0).
	self
		should: [minusInfinity / meterBySecond]
		raise: IndeterminateOperationException
		withExceptionDo: [:anException |
			self assert:
				anException description =
					'The Division operation is indeterminate between Minus Infinity and meter.second'].
	self assert: (meterBySecond / minusInfinity) numerator = (meterBySecond withCells: 0).
	self assert: (meterBySecond / minusInfinity) denominator = 1! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50745231!
oneMonth

	^TimeUnits month withCells: 1! !
!GregorianYearTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50745965!
zeroYears
	
	^TimeUnits year withCells: 0! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 16868768!
sizeCodeForRepeat: encoder value: forValue 
	"L1: ... Jmp(L1) nil (nil for value only);"
	| loopSize |
	"We assume long backward branches are always maximal size branches."
	loopSize := (receiver sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: -1).
	sizes := Array withCells: loopSize.
	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !
!WriteStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 16946663!
with: aCollection from: firstIndex to: lastIndex 
	"Answer an instance of me on the subcollection of the argument, 
	aCollection, determined by the indices firstIndex and lastIndex. Position 
	the instance to store at the end of the subcollection."

	^self basicNew withCells: (aCollection copyFrom: firstIndex to: lastIndex)! !
!LiteralNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50810349 overrides: 50810339!
typesIn: aCompiledMethod addingIncompleteTypeInfoTo: incompleteTypeInfoReasons  
	
	^Array withCells: self literalValue class! !
!Symbol methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50818806!
asMessageWith: aCollaborator

	^self asMessageWithAll: (Array withCells: aCollaborator)! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:06' prior: 50726752!
testRemainderByMeasure

	self assert: (self tenMeters \\ self tenMeters) = (self meter withCells: 10\\10).
	self assert: (self oneMeter \\ self tenMeters) = (self meter withCells: 1\\10).
	self assert: (self tenMeters \\ self oneSecond) = (self meter withCells: 10\\1).
	self assert: (self tenMeters \\ self threeSeconds) = (self meter withCells: 10\\3).

	
! !
!Categorizer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 16795781!
setDefaultList: anArray

	categoryArray _ Array withCells: Default.
	categoryStops _ Array withCells: anArray size.
	elementArray _ anArray! !
!ProportionalUnitConversionFunctionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50726430 overrides: 16927572!
setUp

	peso := BaseUnit named: 'peso'.
	dollar := BaseUnit named: 'dollar'.	
	onePeso := peso withCells: 1.
	tenDollars := dollar withCells: 10! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 16830124!
newStack: stack
	| oldStack diff |
	oldStack _ contextStack.
	contextStack _ stack.
	(oldStack == nil or: [oldStack last ~~ stack last])
		ifTrue: [contextStackList _ contextStack collect: [:ctx | ctx printString].
				^ self].
	"May be able to re-use some of previous list"
	diff _ stack size - oldStack size.
	contextStackList _ diff <= 0
		ifTrue: [contextStackList copyFrom: 1-diff to: oldStack size]
		ifFalse: [diff > 1
				ifTrue: [contextStack collect: [:ctx | ctx printString]]
				ifFalse: [(Array withCells: stack first printString) , contextStackList]]! !
!EvaluationTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50723996!
twentyPesos

	^peso withCells: 20! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50726802!
testAbs

	self assert: self onePeso abs = self onePeso.
	self assert: (self onePeso unit withCells: 0)  abs = (self onePeso unit withCells: 0).
	self assert: (self onePeso unit withCells: -1)  abs = (self onePeso unit withCells: 1)! !
!SafelyRemoveClassTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50778651!
test10WarnWhenHasReferencesToName

	| classToRemove classReferencing methodNameReferencingClass | 
	
	classToRemove := self createClassNamed: self classToRemoveName.
	classReferencing := self createClassNamed: #ClassReferencingClassToRemove.
	methodNameReferencingClass := #m1.
	classReferencing compile: methodNameReferencingClass asString, ' ^#', classToRemove name asString.
	
	self
		should: [ SafelyRemoveClass of: classToRemove ]
		raise: self referencesRefactoringWarning 
		withExceptionDo: [ :aWarning | | reference |
			self 
				assert: (SafelyRemoveClass warningMessageForReferencesToNames: (Array withCells: classToRemove))
				equals: aWarning messageText.
			self assert: 1 equals: aWarning numberOfReferences.
			reference := aWarning anyReference.
			self assert: classReferencing name equals: reference classSymbol.
			self assert: methodNameReferencingClass equals: reference methodSymbol ]! !
!BaseUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50721613!
testMultiplyByMinusInfinity

	| kelvin |

	kelvin := BaseUnit named: 'kelvin'.
	self assert: kelvin * minusInfinity = (kelvin withCells: minusInfinity).
	self assert: minusInfinity * kelvin = (kelvin withCells: minusInfinity).
	self assert: (kelvin * minusInfinity) numerator = (kelvin withCells: minusInfinity).
	self assert: (kelvin * minusInfinity) denominator = 1! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50777164!
test18FailsWhenNewVariableEqualsTemporaryOfABlockInAMethodInClass

	| selector |

	self createClassToRefactor.
	selector := #m1.
	classToRefactor compile: selector, ' [ | ', newVariable, ' | ] value'.
	
	self 
		assertCreation: [ RenameInstanceVariable from: oldVariable to: newVariable in: classToRefactor ]
		failsWith: [ NewInstanceVariablePrecondition errorMessageForNewVariable: newVariable willBeHiddenAtAll: (Array withCells: (classToRefactor>>selector)) ].
	! !
!MessageNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 16868429!
printWithClosureAnalysisToDoOn: aStream indent: level

	| limitNode |
	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.

	limitNode := (arguments last == nil
				or: [arguments last isAssignmentNode not])
					ifTrue: [arguments first]
					ifFalse: [arguments last value].
	(selector key = #to:by:do:
	 and: [(arguments at: 2) isConstantNumber
	 and: [(arguments at: 2) key = 1]])
		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:
					arguments: (Array with: limitNode with: (arguments at: 3))
					on: aStream indent: level]
		ifFalse: [self printWithClosureAnalysisKeywords: selector key
					arguments: (Array withCells: limitNode) , arguments allButFirst
					on: aStream indent: level]! !
!RenameSelectorTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50777363!
test02SendersOfMessageAreRenamed
	
	| rename senderMethod |
	
	self createClassToRefactor.
	
	rename := RenameSelector from: oldSelector to: newSelector implementors: (Array withCells: classToRefactor>>oldSelector) senders: (Array withCells: classToRefactor>>senderOfOldSelector).
	rename apply.
	
	senderMethod := classToRefactor compiledMethodAt: senderOfOldSelector.
	self deny: (senderMethod sendsOrRefersTo: oldSelector).
	self assert: (senderMethod sendsOrRefersTo: newSelector)! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 16897035!
fileOutMethod: selector

	DirectoryEntry smalltalkImageDirectory // (name,'-', selector asFileName, '.st') writeStreamDo: [ :f |
		self fileOutMethods: (Array withCells: selector) on: f ]! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50747077!
testToByDo

	| interval hour |
	
	interval := TimeOfDay firstTimeOfDay to: TimeOfDay lastTimeOfDay by: (TimeUnits hour withCells: 1).
	hour := 0.
	interval do: [ :aTimeOfDay |
		self assert: aTimeOfDay = (TimeOfDay hours: hour).
		hour := hour + 1 ].
	
	self assert: hour = 24! !
!GregorianMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50745238!
twoMonths
	
	^TimeUnits month withCells: 2! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50786801!
test29ReplacesIsNilIfTrueWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' isNil ifTrue: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!SimpleMeasureTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50727861!
testDivisionFloatByMeasure

	self assert: (1.01 / self tenPesos) = ((NullUnit new / self peso) withCells: 1.01/10)

! !
!ReplaceIfNilWithPolymorphismParametersTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:07' prior: 50788253!
test04AllKeywordsMustHaveACorrespondingVariableToParametrize

	| variablesToParametrizeKeywordsDefinitions sourceWithIf definitions |

	sourceWithIf := 'm1 anInstVar ifNil: [self isNil].'.
	definitions := {
		VariableToParametrizeKeywordDefinition
			forVariable: 'self'
			useKeyword: #with
			withParameterName: 'pSelf'.
		VariableToParametrizeKeywordDefinition
			forVariable: 'inexistentVar'
			useKeyword: #with
			withParameterName: 'pInexistentVar'}.
	variablesToParametrizeKeywordsDefinitions :=
		VariablesToParametrizeKeywordsDefinitions withCells: definitions.

	self creationFromSource: sourceWithIf withDefinitions: variablesToParametrizeKeywordsDefinitions failsWithMessageText: [
			ReplaceIfNilWithPolymorphismParameters allKeywordsMustHaveACorrespondingVariableToParametrizeErrorMessage].! !
!Parser methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50682698!
cascade
	" {; message} => CascadeNode."

	| receiverNode messageNodes |
	parseNode canCascade ifFalse:
		[^self expected: 'Cascading not'].
	parseNode ensureCanCascade: encoder.
	receiverNode := parseNode cascadeReceiver.
	messageNodes := OrderedCollection withCells: parseNode.
	[self match: #semicolon]
		whileTrue: 
			[parseNode := receiverNode.
			(self messagePart: 3 repeat: false)
				ifFalse: [^self expected: 'Cascade'].
			parseNode canCascade ifFalse:
				[^self expected: '<- No special messages'].
			parseNode ensureCanCascade: encoder.
				parseNode cascadeReceiver.
			messageNodes addLast: parseNode].
	self createCascadeNodeWith: receiverNode and: messageNodes! !
!TestIntervalStrategy methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50732870 overrides: 50732771!
advanceFrom: from by: by

	^TestIntervalAwareMagnitude withCells: from number + by number! !
!GregorianDay class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50736671!
initializeThreeHundredSixtyDays

	ThreeHundredSixtyDays := TimeUnits day withCells: 360! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50776983!
test08NewVariableNameCanNotBeDefinedInAnySubclass

	| classToRefactorSubclass |

	self createClassToRefactor.
	classToRefactorSubclass := self createClassNamed: #SubclassWithInstVar subclassOf: classToRefactor instanceVariableNames: newVariable.
	
	self assertRenameCreationFailsWith: [NewInstanceVariablePrecondition errorMessageForNewInstanceVariable: newVariable alreadyDefinedInAll: (Array withCells: classToRefactorSubclass)]
	
		! !
!BlockClosure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50649986 overrides: 16881992!
objectForDataStream: refStrm
	"I am about to be written on an object file.
	Write a textual reference if possible. If not, attempt converting to a serializable object.
	This might also fail. See #onBlockClosure:"

	self isCleanClosure ifTrue: [
		^ DiskProxy
			global: #Compiler
			selector: #evaluate:
			args: (Array withCells: self decompile decompileString) ].
	^self asSerializable! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50725163!
testMeasureCreation

	self assert: (meterBySecond withCells: 10) = (SimpleMeasure amount: 10 unit: meterBySecond)! !
!NullUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50725548!
testMeasureCreation

	self assert: (nullUnit withCells: 10) = 10! !
!TimeLineFilterTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50741193!
testNextNegativeDuration

	| timeLineFilter date |

	timeLineFilter := TimeLineFilter new.
	timeLineFilter addDayRule: GregorianDay saturday.
			
	date := (FixedGregorianDate yearNumber: 2004 monthNumber: 01 dayNumber: 31).
	self assert: (timeLineFilter next: (GregorianTimespan from: date duration: (TimeUnits day withCells: -1))) =
		(date previousDay: GregorianDay saturday).
	self assert: (timeLineFilter next: (GregorianTimespan from: date duration: (TimeUnits day withCells: -2))) =
		((date previousDay: GregorianDay saturday) previousDay: GregorianDay saturday)! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50723607!
testDivideByInteger

	self assert: (meterOverSecond / 5) = (meterOverSecond withCells: 1/5).
	self assert: (meterOverSecond / 5) numerator = (meter withCells: 1).
	self assert: (meterOverSecond / 5) denominator = (second withCells: 5).
! !
!TestCaseTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50770789!
testAssertDoeNotChangePassesWhenConditionIsNotAlteredByAction

	|aCollection|

	aCollection := OrderedCollection withCells: 1.
	
	self assert: [ aCollection sum ] doesNotChange: [ aCollection size ]! !
!ProportionalUnitConversionFunctionTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50726473!
testInvalidValues

	| cent |
	
	self 
		should: [ ProportionalUnitConversionFunction measure: (peso withCells:0) isProportionalTo: tenDollars ] 
		raise: InvalidProportionalUnitConversionFunctionException
		withExceptionDo: [ :anException |
			self assert: anException sourceMeasure = (peso withCells: 0).
			self assert: anException equivalentMeasure = tenDollars.
			self assert: anException description notNil ].
		
	cent := ProportionalDerivedUnit baseUnit: peso conversionFactor: 1/100 named: 'cent'.
	self 
		should: [ ProportionalUnitConversionFunction measure: onePeso isProportionalTo: (cent withCells: 100) ] 
		raise: InvalidProportionalUnitConversionFunctionException
		withExceptionDo: [ :anException |
			self assert: anException sourceMeasure = onePeso.
			self assert: anException equivalentMeasure = (cent withCells: 100).
			self assert: anException description notNil ]! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50743672!
testNumberOfDaysToEndOfMonth

	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1) numberOfDaysToEndOfMonth = (TimeUnits day withCells: 30).
	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 31) numberOfDaysToEndOfMonth = (TimeUnits day withCells: 0).
	self assert: (GregorianDayOfMonth monthNumber: 2 dayNumber: 28) numberOfDaysToEndOfMonth = (TimeUnits day withCells: 1)! !
!ObjectExplorer methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 16883201!
getList

	^Array withCells: (ObjectExplorerWrapper with: rootObject name: 'root' model: self parent: nil)
! !
!IntroduceNullObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50786571!
test20WhenIfNilCheckHasTwoKeywordsReplacesIfNilWithPolymorphicMessageSend

	| sourceWithIf definitions actualRefactoredSourceCode expectedRefactoredSourceCode |

	sourceWithIf := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' ifNil: [ self isNil ] ifNotNil: [ self isNil ]'.
	definitions := VariablesToParametrizeKeywordsDefinitions withCells: {
		VariableToParametrizeKeywordDefinition forVariable: 'self' useKeyword: #with withParameterName: 'p1'}.

	self applyRefactoringOn: sourceWithIf using: definitions.

	expectedRefactoredSourceCode := self methodToRefactorSelector asString, ' ', self defaultInstVarName, ' with: self'.
	actualRefactoredSourceCode := self compiledMethodToRefactor sourceCode.
	self assert: expectedRefactoredSourceCode equals: actualRefactoredSourceCode.! !
!PseudoClass methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 16896979!
fileInMethod: selector
	^self fileInMethods: (Array withCells: selector)! !
!RenameInstanceVariableTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50776951!
test06NewVariableNameCanNotBeDefinedInClass

	newVariable := oldVariable.
	self createClassToRefactorAndAssertRenameCreationFailsWith: [NewInstanceVariablePrecondition errorMessageForNewInstanceVariable: newVariable alreadyDefinedInAll: (Array withCells: classToRefactor )]
	! !
!TextEditor methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50603274!
firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine _ textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine _ currentLine first.
	endOfIndentation _ self privateCurrentString
		skipDelimiters: (String withCells: Character tab)
		startingAt: beginningOfLine.
		
	stops _ OrderedCollection with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!MultipliedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50724866!
testDivideByInfinity
 
	self assert: meterBySecond / infinity = (meterBySecond withCells: 0).
	self
		should: [infinity / meterBySecond]
		raise: IndeterminateOperationException
		withExceptionDo: [:anException |
			self assert:
				anException description =
					'The Division operation is indeterminate between Infinity and meter.second'].
	self assert: (meterBySecond / infinity) numerator = (meterBySecond withCells: 0).
	self assert: (meterBySecond / infinity) denominator = 1! !
!MinusInfinity methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50732145!
divideByUnit: aUnit

	^aUnit withCells: 1 / self! !
!SafelyRemoveClassTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50778576!
test07CanNotRemoveClassWhenSubclassesHaveReferencesOutsideTheHierarchy

	| classToRemove classToRemoveSubclass classReferencing methodNameReferencingClass | 
	
	classToRemove := self createClassNamed: self classToRemoveName.
	classToRemoveSubclass := self createClassNamed: 'ClassToRemoveSubclass' asSymbol subclassOf: classToRemove.
	classReferencing := self createClassNamed: #ClassReferencingClassToRemoveSubclass.
	methodNameReferencingClass := #m1.
	classReferencing compile: methodNameReferencingClass asString, ' ^', classToRemoveSubclass name asString.
	
	self
		should: [ SafelyRemoveClass of: classToRemove ]
		raise: self canNotRefactorDueToReferencesRefactoringError 
		withExceptionDo: [ :anError | | reference |
			self 
				assert: (SafelyRemoveClass errorMessageForCanNotRemove: classToRemove dueToReferencesToAll: (Array withCells: classToRemoveSubclass))
				equals: anError messageText.
			self assert: 1 equals: anError numberOfReferences.
			reference := anError anyReference.
			self assert: classReferencing name equals: reference classSymbol.
			self assert: methodNameReferencingClass equals: reference methodSymbol ]	
! !
!SimpleMeasure methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 50731798 overrides: 50730546!
multiplySimpleMeasure: aMeasure

	| leftFactor rightFactor |
	
	leftFactor := aMeasure convertToBaseUnit.
	rightFactor := self convertToBaseUnit.
	
	^leftFactor unit * rightFactor unit 
		withCells: leftFactor amount * rightFactor amount! !
!BraceNode methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 16791024!
sizeCodeForValue: encoder

	(encoder supportsClosureOpcodes
		"Hack; we have no way of knowing how much stack space is available"
	 and: [elements size <= self maxElementsForConsArray]) ifTrue:
		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
		  + (encoder sizePushConsArray: elements size)].
	emitNode := elements size <= 4
		ifTrue: ["Short form: Array braceWith: a with: b ... "
				MessageNode new
					receiver: (encoder encodeVariable: #Array)
					selector: (self selectorForShortForm: elements size)
					arguments: elements precedence: 3 from: encoder]
		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"
				CascadeNode new
					receiver: (MessageNode new
								receiver: (encoder encodeVariable: #Array)
								selector: #braceStream:
								arguments: (Array withCells: (encoder encodeLiteral: elements size))
								precedence: 3 from: encoder)
					messages: ((elements collect: [:elt | MessageNode new receiver: nil
														selector: #nextPut:
														arguments: (Array withCells: elt)
														precedence: 3 from: encoder])
								copyWith: (MessageNode new receiver: nil
														selector: #braceArray
														arguments: (Array new)
														precedence: 1 from: encoder))].
	^emitNode sizeCodeForValue: encoder! !
!Class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 16802517!
addSharedPool: aSharedPool 
	"Add the argument, aSharedPool, as one of the receiver's shared pools. 
	Create an error if the shared pool is already one of the pools.
	This method will work with shared pools that are plain Dictionaries or thenewer SharedPool subclasses"

	(self sharedPools includes: aSharedPool)
		ifTrue: [^self error: 'This is already in my shared pool list'].
	sharedPools
		ifNil: [sharedPools _ OrderedCollection withCells: aSharedPool]
		ifNotNil: [sharedPools add: aSharedPool]! !
!WeakMessageSend class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:08' prior: 16944270!
receiver: anObject selector: aSymbol argument: aParameter
	^ self receiver: anObject selector: aSymbol arguments: (Array withCells: aParameter)
! !
!GregorianDayOfMonthTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50743686!
testNumberOfDaysToEndOfYear

	self assert: (GregorianDayOfMonth monthNumber: 1 dayNumber: 1) numberOfDaysToEndOfYear = (TimeUnits day withCells: 365).
	self assert: (GregorianDayOfMonth monthNumber: 12 dayNumber: 31) numberOfDaysToEndOfYear = (TimeUnits day withCells: 0)! !
!MeasureConverter class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50729178!
on: aConvertionTable 

	^self withCells: (self defaultGraphPathFinder on: (aConvertionTable graph))! !
!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50809885!
browseAllActualImplementorsOf: aSelector for: aClass

	self browseAllActualImplementorsOf: aSelector forAll: (Array withCells: aClass)
! !
!Form methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50678381!
primCountBits
	"Count the non-zero pixels of this form."
	self depth > 8 ifTrue: [
		^(self asFormOfDepth: 8) primCountBits].
	^ (BitBlt toForm: self)
		fillColor: (Bitmap withCells: 0);
		destRect: self boundingBox;
		combinationRule: 32;
		copyBits! !
!GregorianDate methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50735895!
to: aGregorianDate everyDayNumber: aDayNumber

	^self to: aGregorianDate everyDayNumbers: (Array withCells: aDayNumber)! !
!DividedUnitTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50723769!
testIntegerMultipliedByUnitTwice

	| kelvin |
	kelvin := BaseUnit named: 'kelvin'.
	
	self assert: (5 * kelvin * meterOverSecond) = (kelvin * meterOverSecond withCells: 5).
	self assert: (5 * kelvin * meterOverSecond) numerator = (kelvin * meter withCells: 5).
	self assert: (5 * kelvin * meterOverSecond) denominator = (second withCells: 1).
	
! !
!TimeOfDayTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50746936!
testCreationMilliseconds

	| time |
	
	time := TimeOfDay hours: 1 minutes: 1 seconds: 1 milliseconds: 1.
	
	self assert: time hours = (TimeUnits hour withCells: 1).
	self assert: time minutes = (TimeUnits minute withCells: 1).
	self assert: time seconds = (TimeUnits second withCells: 1).
	self assert: time milliseconds = (TimeUnits millisecond withCells: 1)
! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50785494!
test58MethodObjectInstanceCreationMessageParameterNamesMustNotContainSeparators

	| keywordsDefinitions variablesToParametrizeToInstanceVariables aParameterName |

	variablesToParametrizeToInstanceVariables := {'self' -> 'thePreviousSelf'} asDictionary.
	aParameterName := 'a Parameter Name'.
	keywordsDefinitions := {self keyword: #with varName: 'self' paramName: aParameterName.}.

	self
		creationFrom: self compiledMethodReferencingSelf
		withExtractedVariablesToInstanceVariables: variablesToParametrizeToInstanceVariables
		withInstanceCreationMessageFrom: keywordsDefinitions
		failsWithMessageText: [
			ExtractToMethodObject invalidParameterNamesErrorMessage: (Array withCells: aParameterName) ].! !
!ExtractToMethodObjectTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50783717!
test07AllInstanceVariableNamesMustCorrespondToVariableToParametrize

	| keywordToParametrizedVariable variablesToParametrizeWithoutInstVarName namesForParametrizedVariables |

	namesForParametrizedVariables := {
		'self' -> 'oldSelf'.
		'inexistentVariableToParametrize' -> 'anInstVarName'
	} asDictionary.
	keywordToParametrizedVariable := {self keyword: #with varName: 'self' paramName: 'aParamName'}.
	variablesToParametrizeWithoutInstVarName := Set withCells: 'inexistentVariableToParametrize'.

	self
		creationWithExtractedVariablesToInstanceVariables: namesForParametrizedVariables
		withInstanceCreationMessageFrom: keywordToParametrizedVariable
		failsWithMessageText: [ ExtractToMethodObject
			unknownVariablesToParametrizeErrorMessage: variablesToParametrizeWithoutInstVarName].! !
!WriteStream class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:34:09' prior: 50949606!
withCells: aCollection 
	"Answer an instance of me on the argument, aCollection, positioned to 
	store objects at the end of aCollection."

	^self basicNew withCells: aCollection! !

!methodRemoval: SimpleUnit #with: stamp: 'eb 10/22/2020 20:34:09'!
with: aNumber

	^SimpleMeasure amount: aNumber unit: self!

!methodRemoval: TestIntervalAwareMagnitude class #with: stamp: 'eb 10/22/2020 20:34:09'!
with: aNumber

	^self new initializeWith: aNumber!

!methodRemoval: Collection class #with: stamp: 'eb 10/22/2020 20:34:09'!
with: anObject 
	"Answer an instance of me containing anObject."

	^ self new
		add: anObject;
		yourself!

!methodRemoval: ArrayedCollection class #with: stamp: 'eb 10/22/2020 20:34:09'!
with: anObject 
	"Answer a new instance of me, containing only anObject."

	| newCollection |
	newCollection _ self new: 1.
	newCollection at: 1 put: anObject.
	^newCollection!

!methodRemoval: CompoundUnit #with: stamp: 'eb 10/22/2020 20:34:09'!
with: aNumber

	^SimpleMeasure amount: aNumber unit: self!

!methodRemoval: WriteStream class #with: stamp: 'eb 10/22/2020 20:34:09'!
with: aCollection 
	"Answer an instance of me on the argument, aCollection, positioned to 
	store objects at the end of aCollection."

	^self basicNew withCells: aCollection!

!methodRemoval: Robot class #with: stamp: 'eb 10/22/2020 20:34:09'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer!

!methodRemoval: Entero class #with: stamp: 'eb 10/22/2020 20:34:09'!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	^self new initalizeWith: aValue!

!methodRemoval: GameOfLife class #with: stamp: 'eb 10/22/2020 20:34:10'!
with: aCellCollection
	
	self new initializeWith: aCellCollection .!

!methodRemoval: Unit #with: stamp: 'eb 10/22/2020 20:34:10'!
with: aNumber

	self subclassResponsibility!

!methodRemoval: ListItemWrapper class #with: stamp: 'eb 10/22/2020 20:34:10'!
with: anObject

	^self new setItem: anObject!

!methodRemoval: WriteStream #with: stamp: 'eb 10/22/2020 20:34:10'!
with: aCollection

	super on: aCollection.
	position _ readLimit _ writeLimit _ aCollection size!

!methodRemoval: MeasureConverter class #with: stamp: 'eb 10/22/2020 20:34:10'!
with: aGraphPathFinder

	^self new initializeWith: aGraphPathFinder!

!methodRemoval: NullUnit #with: stamp: 'eb 10/22/2020 20:34:10'!
with: aNumber

	^aNumber!

!methodRemoval: VariablesToParametrizeKeywordsDefinitions class #with: stamp: 'eb 10/22/2020 20:34:10'!
with: someDefinitions

	self assertKeywordMustStartWithValidStartOfSelector: someDefinitions first keyword.
	self assertParameterNamesAreNotRepeated: someDefinitions.
	self assertVariableNamesAreNotRepeated: someDefinitions.

	^self new initializeWith: someDefinitions !

!methodRemoval: StateTransitionEvent class #with: stamp: 'eb 10/22/2020 20:34:10'!
with: aTDDState
	^ self new tddState: aTDDState !

!methodRemoval: CanNotChangeSelectorWithNotIncludedTypes class #with: stamp: 'eb 10/22/2020 20:34:10'!
with: messageSendsWithInvalidReceiverTypes
 
	^self new initializeWith: messageSendsWithInvalidReceiverTypes!

----STARTUP---- (22 October 2020 20:34:27) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #GameOfLifeTest category: #'ISW1-2020-2C-Parcial-Enunciado' stamp: 'eb 10/22/2020 20:43:45'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #GameOfLifeTest stamp: 'eb 10/22/2020 20:43:50'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLifeTest category: #GameOfLife stamp: 'eb 10/22/2020 20:44:19'!
TestCase subclass: #GameOfLifeTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

Object subclass: #GameOfLife
	instanceVariableNames: 'aliveCells diedCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLife category: #GameOfLife stamp: 'eb 10/22/2020 20:44:53'!
Object subclass: #GameOfLife
	instanceVariableNames: 'aliveCells diedCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLife class methodsFor: 'nil' stamp: 'eb 10/22/2020 20:46:13'!
withAliveCells: aCellCollection ofSize: aSize
	
	self new initializeWithAliveCells: aCellCollection ofSize: aSize! !

Object subclass: #GameOfLife
	instanceVariableNames: 'aliveCells diedCells size'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!

!classDefinition: #GameOfLife category: #GameOfLife stamp: 'eb 10/22/2020 20:46:29'!
Object subclass: #GameOfLife
	instanceVariableNames: 'aliveCells diedCells size'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'GameOfLife'!
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 20:46:56'!
initializeWithAliveCells: aCellCollection ofSize: aSize

	aliveCells _ aCellCollection .
	
	diedCells _ Set new .
	
	size _ aSize .! !
!GameOfLifeTest methodsFor: 'nil' stamp: 'eb 10/22/2020 20:48:34'!
test01
	
	| gameOfLife |
	
	gameOfLife _ GameOfLife withAliveCells: { 1@1 } ofSize: { 3@3 } .
	
	gameOfLife nextGeneration .
	
	self assert! !
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 20:48:53'!
nextGeneration
	
	self shouldBeImplemented .! !
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:50:31' prior: 50960627!
test01
	
	| gameOfLife |
	
	gameOfLife _ GameOfLife withAliveCells: { 1@1 } ofSize: { 3@3 } .
	
	gameOfLife nextGeneration .
	
	self assert: (gameOfLife stateOf: 1@1) equals: #Died.! !
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 20:50:56'!
stateOf: aCell
	
	^ #Died .! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:51:01'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:51:01'!
ERROR!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:51:23' prior: 50960634!
nextGeneration
	
	^ self .! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:51:26'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:51:26'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:52:00'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:52:00'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:52:38'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:52:38'!
ERROR!
!GameOfLife class methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:53:29' prior: 50960602!
withAliveCells: aCellCollection ofSize: aSize
	
	^ self new initializeWithAliveCells: aCellCollection ofSize: aSize! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:53:31'!
PASSED!
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:54:53'!
test02
	
	| gameOfLife |
	
	gameOfLife _ GameOfLife withAliveCells: { 1@1, 1@2, 2@1 } ofSize: { 3@3 } .
	
	gameOfLife nextGeneration .
	
	self assert: (gameOfLife stateOf: 1@1) equals: #Alive.! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:55:02'!
PASSED!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 20:55:02'!
ERROR!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 20:55:02'!
ERROR!
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 20:55:24' prior: 50960684!
test02
	
	| gameOfLife |
	
	gameOfLife _ GameOfLife withAliveCells: { 1@1. 1@2. 2@1. } ofSize: { 3@3 } .
	
	gameOfLife nextGeneration .
	
	self assert: (gameOfLife stateOf: 1@1) equals: #Alive.! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 20:55:26'!
PASSED!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 20:55:26'!
FAILURE!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 20:55:26'!
FAILURE!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:00:12' prior: 50960656!
nextGeneration
	
	aliveCells do: [ :aCell |
		(((aCell eightNeighbors) intersection: aliveCells) size > 1) 
			ifFalse: [].
	].
	
	^ self .! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:01:25' prior: 50960718!
nextGeneration
	
	aliveCells do: [ :aCell |
		(((aCell eightNeighbors) intersection: aliveCells) size > 1) 
			ifFalse: [ 
				aliveCells remove: aCell.
				diedCells add: aCell.
			].
	].! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:02:09' prior: 50960647!
stateOf: aCell
	
	^ aliveCells containsPoint: aCell.! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:03:27' prior: 50960735!
stateOf: aCell
	
	(aliveCells includes: aCell) ifTrue: [ ^#Alive ].
	
	^ #Died .
	
	! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:03:32'!
ERROR!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:03:32'!
PASSED!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:03:32'!
ERROR!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:05:41' prior: 50960726!
nextGeneration
	
	aliveCells do: [ :aCell |
		(((aCell eightNeighbors) intersection: aliveCells) size > 1) 
			ifFalse: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | ((aCell eightNeighbors) intersection: aliveCells) size > 1 ].! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:06:07'!
PASSED!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:06:07'!
PASSED!
!GameOfLifeTest methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:07:50'!
test03
	
	| gameOfLife |
	
	gameOfLife _ GameOfLife withAliveCells: { 1@1. 1@2. 2@1. 0@1. 1@0. } ofSize: { 3@3 } .
	
	gameOfLife nextGeneration .
	
	self assert: (gameOfLife stateOf: 1@1) equals: #Died.! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:07:55'!
PASSED!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:07:55'!
PASSED!

!testRun: #GameOfLifeTest #test03 stamp: 'eb 10/22/2020 21:07:55'!
FAILURE!

!testRun: #GameOfLifeTest #test03 stamp: 'eb 10/22/2020 21:07:55'!
FAILURE!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:10:21' prior: 50960753!
nextGeneration
	
	| neighbours |
	
	neighbours _ [ :aCell | aCell eightNeighbors intersection: aliveCells ] .
	
	aliveCells do: [ :aCell |
		(((aCell eightNeighbors) intersection: aliveCells) size > 1) 
			ifFalse: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | ((aCell eightNeighbors) intersection: aliveCells) size > 1 ].! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:10:54' prior: 50960788!
nextGeneration
	
	| xxx |
	
	xxx _ [ :aCell | aCell eightNeighbors intersection: aliveCells ] .
	
	aliveCells do: [ :aCell |
		(((aCell eightNeighbors) intersection: aliveCells) size > 1) 
			ifFalse: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | ((aCell eightNeighbors) intersection: aliveCells) size > 1 ].! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:13:18' prior: 50960803!
nextGeneration
	
	| xxx xxx2 |
	
	xxx _ [ :aCell | aCell eightNeighbors intersection: aliveCells ] .
	
	xxx2 _ [ :aCell | (xxx value: aCell) size < 2 or: (xxx value: aCell) size > 3 ].
	
	aliveCells do: [ :aCell | 
		(xxx2 value: aCell)
			ifTrue: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | ((aCell eightNeighbors) intersection: aliveCells) size > 1 ].! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:13:26' prior: 50960817!
nextGeneration
	
	| xxx xxx2 |
	
	xxx _ [ :aCell | aCell eightNeighbors intersection: aliveCells ] .
	
	xxx2 _ [ :aCell | (xxx value: aCell) size < 2 or: (xxx value: aCell) size > 3 ].
	
	aliveCells do: [ :aCell | (xxx2 value: aCell) ifTrue: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | ((aCell eightNeighbors) intersection: aliveCells) size > 1 ].! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:13:43' prior: 50960833!
nextGeneration
	
	| xxx xxx2 |
	
	xxx _ [ :aCell | aCell eightNeighbors intersection: aliveCells ] .
	
	xxx2 _ [ :aCell | (xxx value: aCell) size < 2 or: (xxx value: aCell) size > 3 ].
	
	aliveCells do: [ :aCell | (xxx2 value: aCell) ifTrue: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | xxx2 value: aCell ].! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:14:15'!
FAILURE!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:14:15'!
FAILURE!

!testRun: #GameOfLifeTest #test03 stamp: 'eb 10/22/2020 21:14:15'!
FAILURE!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:14:20'!
FAILURE!
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 21:15:34'!
neighboursOf: aCell 
	! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:15:48' prior: 50960872!
neighboursOf: aCell 
	
	^ aCell eightNeighbors intersection: aliveCells .! !
!GameOfLife methodsFor: 'nil' stamp: 'eb 10/22/2020 21:17:09'!
shouldLiveInNextGeneration: aCell
	
	| neighboursCount |
	
	neighboursCount _ self neighboursOf: aCell.
	
	^neighboursCount >= 2 and: neighboursCount <= 3.! !
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:17:54' prior: 50960849!
nextGeneration

	
	aliveCells do: [ :aCell | (self shouldLiveInNextGeneration: aCell) ifFalse: [ 
				diedCells add: aCell.
			].
	].

	aliveCells _ aliveCells select: [ :aCell | self shouldLiveInNextGeneration: aCell].! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:17:57'!
ERROR!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:17:57'!
ERROR!

!testRun: #GameOfLifeTest #test03 stamp: 'eb 10/22/2020 21:17:57'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:17:59'!
ERROR!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:18:20' prior: 50960881!
shouldLiveInNextGeneration: aCell
	
	| neighboursCount |
	
	neighboursCount _ self neighboursOf: aCell size.
	
	^neighboursCount >= 2 and: neighboursCount <= 3.! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:18:23'!
ERROR!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:18:23'!
ERROR!

!testRun: #GameOfLifeTest #test03 stamp: 'eb 10/22/2020 21:18:23'!
ERROR!

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:18:24'!
ERROR!
!GameOfLife methodsFor: 'as yet unclassified' stamp: 'eb 10/22/2020 21:18:53' prior: 50960909!
shouldLiveInNextGeneration: aCell
	
	| neighboursCount |
	
	neighboursCount _ (self neighboursOf: aCell) size.
	
	^neighboursCount >= 2 and: neighboursCount <= 3.! !

!testRun: #GameOfLifeTest #test01 stamp: 'eb 10/22/2020 21:18:57'!
PASSED!

!testRun: #GameOfLifeTest #test02 stamp: 'eb 10/22/2020 21:18:57'!
PASSED!

!testRun: #GameOfLifeTest #test03 stamp: 'eb 10/22/2020 21:18:57'!
PASSED!

----QUIT----(23 October 2020 09:09:39) CuisUniversity-4365.image priorSource: 19689051!

----STARTUP---- (25 October 2020 12:26:01) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Program Files\CuisUniversity\IngSof1-2019-2C-1Parcial-Singleton.st----!

----QUIT----(25 October 2020 18:36:04) CuisUniversity-4365.image priorSource: 20137321!

----STARTUP---- (26 October 2020 17:38:28) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Documents\Personal\Facultad\Ingenieria de software 1\Ejercicios propios\16-MarsRover\MarsRover-Exercise.st----!
!MarsRoverTest methodsFor: 'testing-composed movements' stamp: 'eb 10/26/2020 18:01:11' prior: 50961783!
test08ComposedMovementIsExecutedUntilInvalidCommandFound
	
	| marsRoverThatWillReceiveInvalidCommand marsRoverThatWillNotReceiveInvalidCommand |
	marsRoverThatWillReceiveInvalidCommand _ MarsRover inPosition: (0@0) andDirection: $N.
	marsRoverThatWillNotReceiveInvalidCommand _ MarsRover inPosition: (0@0) andDirection: $N.	
	marsRoverThatWillNotReceiveInvalidCommand move: 'frr'.
	self should:  [marsRoverThatWillReceiveInvalidCommand move: 'frrjb'. self fail] 
	      raiseInvalidCommandErrorAsserting: [
		self  assert: marsRoverThatWillReceiveInvalidCommand = marsRoverThatWillNotReceiveInvalidCommand ].
! !

----QUIT----(26 October 2020 19:33:50) CuisUniversity-4365.image priorSource: 20162153!

----STARTUP---- (27 October 2020 20:25:32) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


----End fileIn of C:\Users\ebonansea\Desktop\entrega isw1\ISW1-2020-2C-Parcial-Enunciado.st----!

----QUIT----(27 October 2020 20:53:14) CuisUniversity-4365.image priorSource: 20184361!

----STARTUP---- (29 October 2020 17:21:42) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!


TestCase subclass: #TerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 17:22:19'!
TestCase subclass: #TerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classDefinition: #TerniLapilliTest category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 17:22:23'!
TestCase subclass: #TerniLapilliTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classRemoval: #TerniLapilli stamp: 'eb 10/29/2020 17:22:27'!
TestCase subclass: #TerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilliTest methodsFor: 'no messages' stamp: 'eb 10/29/2020 17:26:13'!
test01AtTheBegginingBoardIsEmpty
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:27:08'!
test02XCloudBePlacedIntoBoard
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:27:21'!
test03OCouldBePlacedIntoBoard
	! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:27:32'!
test02XCouldBePlacedIntoBoard
	! !

!methodRemoval: TerniLapilliTest #test02XCloudBePlacedIntoBoard stamp: 'eb 10/29/2020 17:27:32'!
test02XCloudBePlacedIntoBoard
	!

Object subclass: #TerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 17:27:48'!
Object subclass: #TerniLapilli
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:28:25' prior: 50963723!
test01AtTheBegginingBoardIsEmpty
	
	| game |
	
	game _ TerniLapilli new .
	
	game board isEmpty.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:28:37' prior: 50963756!
test01AtTheBegginingBoardIsEmpty
	
	| game |
	
	game _ TerniLapilli new .
	
	self assert: game board isEmpty.
	
	! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:28:42'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:28:42'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:29:04'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:29:04'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:29:07'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:29:07'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:29:19'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:29:20'!
ERROR!
!TerniLapilli methodsFor: 'accessing' stamp: 'eb 10/29/2020 17:29:32'!
board
	self shouldBeImplemented.! !

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 17:29:52'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'board'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilli methodsFor: 'accessing' stamp: 'eb 10/29/2020 17:29:48' prior: 50963795!
board

	^ board .! !

!classDefinition: #TerniLapilliBoard category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 17:31:02'!
Object subclass: #TerniLapilliBoard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilli methodsFor: 'nil' stamp: 'eb 10/29/2020 17:30:59' overrides: 16896425!
initialize
	
	board _ TerniLapilliBoard new .! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:31:12'!
ERROR!

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:31:12'!
ERROR!
!TerniLapilliBoard methodsFor: 'testing' stamp: 'eb 10/29/2020 17:31:31'!
isEmpty
	self shouldBeImplemented.! !
!TerniLapilliBoard methodsFor: 'testing' stamp: 'eb 10/29/2020 17:31:38' prior: 50963830!
isEmpty
	
	^ true .! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 17:33:03'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:49:07'!
test02XCanInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingX .! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:49:21'!
test03OCanInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingX .! !

!methodRemoval: TerniLapilliTest #test02XCouldBePlacedIntoBoard stamp: 'eb 10/29/2020 17:49:24'!
test02XCouldBePlacedIntoBoard
	!

!methodRemoval: TerniLapilliTest #test03OCouldBePlacedIntoBoard stamp: 'eb 10/29/2020 17:49:25'!
test03OCouldBePlacedIntoBoard
	!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:49:52' prior: 50963850!
test03OCanInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	game putOAt: 0@0 .
	
	self assert: game isPlayingX .! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:52:05'!
test03OCanotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	self should: [ game putOAt: 0@0. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .! !

!methodRemoval: TerniLapilliTest #test03OCanInitGame stamp: 'eb 10/29/2020 17:52:09'!
test03OCanInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	game putOAt: 0@0 .
	
	self assert: game isPlayingX .!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 17:52:11'!
ERROR!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 17:52:11'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 17:52:30'!
isPlayingX
	self shouldBeImplemented.! !

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 17:52:58'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'board isPlayingX'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 17:52:57' prior: 50963900!
isPlayingX

	^ isPlayingX.! !

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 17:53:06'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 17:53:53' prior: 50963819 overrides: 16896425!
initialize
	
	board _ TerniLapilliBoard new .
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:14:27'!
ERROR!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:14:27'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 18:14:50'!
isPlayingO
	self shouldBeImplemented.! !

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 18:15:10'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'board isPlayingX isPlayingO'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 18:15:07' prior: 50963930!
isPlayingO
	
	^ isPlayingO.! !

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:15:15'!
ERROR!
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:15:42' prior: 50963920 overrides: 16896425!
initialize
	
	board _ TerniLapilliBoard new .
	
	isPlayingX _ false .
	
	isPlayingO _ false .! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 18:15:47'!
PASSED!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:15:48'!
ERROR!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:15:48'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:16:02'!
putXAt: aPoint 
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:16:16' prior: 50963965!
putXAt: aPoint 
	
	^ self.! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 18:16:20'!
PASSED!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:16:20'!
FAILURE!

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:16:20'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:16:46' prior: 50963970!
putXAt: aPoint 
	
	isPlayingX _ true .
	
	^ self.! !

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:16:52'!
PASSED!

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:16:58'!
ERROR!

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:16:58'!
ERROR!
!TerniLapilli class methodsFor: '*Chalten-Time Extensions' stamp: 'eb 10/29/2020 18:17:23'!
onlyXCanInitGameError
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: '*Chalten-Time Extensions' stamp: 'eb 10/29/2020 18:17:41' prior: 50963997!
onlyXCanInitGameError
	
	^ 'Only X can init game' .! !

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:17:58'!
FAILURE!

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:17:58'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:18:22' prior: 50963876!
test03OCanotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .! !

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:18:23'!
FAILURE!

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:18:23'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:19:30'!
putOAt: aPoint 
	
	board isEmpty ifTrue: [ self error: self class onlyXCanInitGameError. ].
	
	^ self .
	
	! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:19:42' prior: 50964029!
putOAt: aPoint 
	
	board isEmpty ifTrue: [ self error: self class onlyXCanInitGameError. ].
	
	! !

!testRun: #TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:19:45'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:20:42'!
test03OCannotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .! !

!methodRemoval: TerniLapilliTest #test03OCanotInitGame stamp: 'eb 10/29/2020 18:20:42'!
test03OCanotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:24:26'!
test04XCannotPlayTwice
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	self should: [ game putXAt: 0@1. self fail. ]
		raise: Error
		withMessageText: game class playerCannotPlayTwiceError .! !

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 18:24:38'!
ERROR!

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 18:24:38'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 18:24:48'!
playerCannotPlayTwiceError
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 18:25:00' prior: 50964082!
playerCannotPlayTwiceError

	^ 'Player cannot play twice'.! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 18:25:03'!
PASSED!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:25:03'!
PASSED!

!testRun: #TerniLapilliTest #test03OCannotInitGame stamp: 'eb 10/29/2020 18:25:03'!
PASSED!

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 18:25:03'!
FAILURE!

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 18:25:03'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:26:02' prior: 50963983!
putXAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerCannotPlayTwiceError ] .
	
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 18:26:07'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:26:23'!
test05OCannotPlayTwice
	
	| game |
	
	game _ TerniLapilli new.
	
	game putOAt: 0@0 .
	
	self should: [ game putXAt: 0@1. self fail. ]
		raise: Error
		withMessageText: game class playerCannotPlayTwiceError .! !

!testRun: #TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 18:26:25'!
PASSED!

!testRun: #TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 18:26:25'!
PASSED!

!testRun: #TerniLapilliTest #test03OCannotInitGame stamp: 'eb 10/29/2020 18:26:25'!
PASSED!

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 18:26:25'!
PASSED!

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:26:25'!
ERROR!

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:26:25'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:26:57' prior: 50964116!
test05OCannotPlayTwice
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self should: [ game putOAt: 0@1. self fail. ]
		raise: Error
		withMessageText: game class playerCannotPlayTwiceError .! !

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:27:01'!
ERROR!

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:27:01'!
ERROR!

Object subclass: #TerniLapilliBoard
	instanceVariableNames: 'XTokens OTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classDefinition: #TerniLapilliBoard category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 18:28:36'!
Object subclass: #TerniLapilliBoard
	instanceVariableNames: 'XTokens OTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilliBoard methodsFor: 'nil' stamp: 'eb 10/29/2020 18:29:06' overrides: 16896425!
initialize
	
	XTokens _ OrderedCollection new .
	
	OTokens _ OrderedCollection new .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:29:53' prior: 50964107!
putXAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerCannotPlayTwiceError ] .
	
	isPlayingX _ true .
	
	board addXToken: aPoint.! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:30:08' prior: 50964180!
putXAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerCannotPlayTwiceError ] .
	
	isPlayingX _ true .
	
	board addX: aPoint.! !

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:30:16'!
ERROR!

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:30:16'!
ERROR!
!TerniLapilliBoard methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:30:28'!
addX: aPoint 
	self shouldBeImplemented.! !
!TerniLapilliBoard methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:30:41' prior: 50964201!
addX: aPoint 
	
	XTokens add: aPoint .! !

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:30:46'!
ERROR!

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:30:46'!
ERROR!
!TerniLapilliBoard methodsFor: 'testing' stamp: 'eb 10/29/2020 18:31:06' prior: 50963834!
isEmpty
	
	^ XTokens isEmpty and: [ OTokens  isEmpty ].! !

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:31:12'!
FAILURE!

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:31:12'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 18:32:03' prior: 50964036!
putOAt: aPoint 
	
	board isEmpty ifTrue: [ self error: self class onlyXCanInitGameError. ].
	
	isPlayingO ifTrue: [ self error: self class playerCannotPlayTwiceError. ].
	
	isPlayingO _ true .
	! !

!testRun: #TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 18:32:08'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:43:45'!
test06XCanInitGameAnywhereOnTheBoard! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:48:57' prior: 50964239!
test06XCanInitGameAnywhereOnTheBoard

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board availablePositions) equals: (-1@1 corner: 1@-1)! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:50:27'!
test06AtTheBegginingAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board availablePositions) equals: (-1@1 corner: 1@-1)! !

!methodRemoval: TerniLapilliTest #test06XCanInitGameAnywhereOnTheBoard stamp: 'eb 10/29/2020 18:50:30'!
test06XCanInitGameAnywhereOnTheBoard

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board availablePositions) equals: (-1@1 corner: 1@-1)!

!testRun: #TerniLapilliTest #test06AtTheBegginingAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:50:34'!
ERROR!

!testRun: #TerniLapilliTest #test06AtTheBegginingAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:50:34'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:50:52'!
test01AtTheBeginningBoardIsEmpty
	
	| game |
	
	game _ TerniLapilli new .
	
	self assert: game board isEmpty.
	
	! !

!methodRemoval: TerniLapilliTest #test01AtTheBegginingBoardIsEmpty stamp: 'eb 10/29/2020 18:50:52'!
test01AtTheBegginingBoardIsEmpty
	
	| game |
	
	game _ TerniLapilli new .
	
	self assert: game board isEmpty.
	
	!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:50:58'!
test06AtTheBeginningAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board availablePositions) equals: (-1@1 corner: 1@-1)! !

!methodRemoval: TerniLapilliTest #test06AtTheBegginingAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:50:58'!
test06AtTheBegginingAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board availablePositions) equals: (-1@1 corner: 1@-1)!

!testRun: #TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:51:01'!
ERROR!

!testRun: #TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:51:01'!
ERROR!
!TerniLapilliBoard methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:51:13'!
availablePositions
	self shouldBeImplemented.! !
!TerniLapilliBoard methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 18:51:24' prior: 50964314!
availablePositions

	^ -1@1 corner: 1@-1 .! !

!testRun: #TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:51:26'!
PASSED!

!testRun: #TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 18:51:30'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:58:17'!
test07TokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardError.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 18:59:01' prior: 50964331!
test07TokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardError.
		
	self should: [ game putXAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardError.
		
	self should: [ game putXAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardError.
		
	self should: [ game putXAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardError.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:16:38'!
test01AtTheBeginningBoardIsEmptyAndXShouldPlay
	
	| game |
	
	game _ TerniLapilli new .
	
	self assert: game boardIsEmpty.
	
	self assert: game isPlayingX .
	! !
!TerniLapilli methodsFor: 'initialization' stamp: 'eb 10/29/2020 19:17:09' prior: 50963951 overrides: 16896425!
initialize
		
	isPlayingX _ false .
	
	isPlayingO _ false .! !

!classRemoval: #TerniLapilliBoard stamp: 'eb 10/29/2020 19:17:12'!
Object subclass: #TerniLapilliBoard
	instanceVariableNames: 'XTokens OTokens'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

Object subclass: #TerniLapilli
	instanceVariableNames: 'XTokens OTokens isPlayingX isPlayingO'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 19:17:17'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'XTokens OTokens isPlayingX isPlayingO'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilli methodsFor: 'initialization' stamp: 'eb 10/29/2020 19:17:43' prior: 50964370 overrides: 16896425!
initialize

	XTokens _ OrderedCollection new .
	
	OTokens _ OrderedCollection new .
		
	isPlayingX _ false .
	
	isPlayingO _ false .! !
!TerniLapilli methodsFor: 'initialization' stamp: 'eb 10/29/2020 19:17:46' prior: 50964397 overrides: 16896425!
initialize

	XTokens _ OrderedCollection new .
	
	OTokens _ OrderedCollection new .
		
	isPlayingX _ true .
	
	isPlayingO _ false .! !

!methodRemoval: TerniLapilliTest #test01AtTheBeginningBoardIsEmpty stamp: 'eb 10/29/2020 19:17:54'!
test01AtTheBeginningBoardIsEmpty
	
	| game |
	
	game _ TerniLapilli new .
	
	self assert: game board isEmpty.
	
	!

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:17:57'!
ERROR!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 19:18:12'!
boardIsEmpty
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 19:18:33' prior: 50964422!
boardIsEmpty
	
	^ XTokens isEmpty and: [ OTokens  isEmpty ] .! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:18:39'!
PASSED!

!methodRemoval: TerniLapilliTest #test02XCanInitGame stamp: 'eb 10/29/2020 19:18:55'!
test02XCanInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingX .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:19:13'!
test02OCannotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .! !

!methodRemoval: TerniLapilliTest #test03OCannotInitGame stamp: 'eb 10/29/2020 19:19:13'!
test03OCannotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self deny: game isPlayingX. 
	
	self deny: game isPlayingO.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:19:27' prior: 50964443!
test02OCannotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class onlyXCanInitGameError .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:19:42' prior: 50964464!
test02OCannotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class playerXShouldPlay .! !

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:19:46'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:19:46'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:19:48'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:19:48'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:19:49'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:19:49'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:20:01'!
ERROR!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:20:01'!
ERROR!
!TerniLapilli class methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 19:20:09'!
playerXShouldPlay
	self shouldBeImplemented.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:20:17' prior: 50964473!
test02OCannotInitGame
	
	| game |
	
	game _ TerniLapilli new.
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class playerXShouldPlayErrorDescription .! !

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:20:21'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 19:20:29'!
playerXShouldPlayErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 19:20:44' prior: 50964522!
playerXShouldPlayErrorDescription

	^ 'X player should play' .! !

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:20:48'!
FAILURE!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:20:48'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:21:33' prior: 50964227!
putOAt: aPoint 
	
	isPlayingX ifTrue: [ self class playerXShouldPlayErrorDescription ].! !

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:21:37'!
FAILURE!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:21:37'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:21:57' prior: 50964539!
putOAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].! !

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:22:00'!
PASSED!

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 19:22:19'!
ERROR!

!testRun: #TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 19:22:19'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:23:28'!
test03OPlaysAfterX
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingO .! !

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:23:35'!
ERROR!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:23:35'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:23:55' prior: 50964188!
putXAt: aPoint 
	
	isPlayingO _ true .! !

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:23:58'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:24:17'!
test03XPlaysAfterO
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self assert: game isPlayingX .! !

!testRun: #TerniLapilliTest #test03XPlaysAfterO stamp: 'eb 10/29/2020 19:24:18'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:24:36'!
test04XPlaysAfterO
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self assert: game isPlayingX .! !

!methodRemoval: TerniLapilliTest #test03XPlaysAfterO stamp: 'eb 10/29/2020 19:24:39'!
test03XPlaysAfterO
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self assert: game isPlayingX .!

!methodRemoval: TerniLapilliTest #test04XCannotPlayTwice stamp: 'eb 10/29/2020 19:24:41'!
test04XCannotPlayTwice
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	self should: [ game putXAt: 0@1. self fail. ]
		raise: Error
		withMessageText: game class playerCannotPlayTwiceError .!

!methodRemoval: TerniLapilliTest #test05OCannotPlayTwice stamp: 'eb 10/29/2020 19:24:44'!
test05OCannotPlayTwice
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self should: [ game putOAt: 0@1. self fail. ]
		raise: Error
		withMessageText: game class playerCannotPlayTwiceError .!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:24:58' prior: 50964551!
putOAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:25:02'!
ERROR!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:25:02'!
ERROR!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:25:06'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:25:08'!
ERROR!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:25:08'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:25:42' prior: 50964578!
putXAt: aPoint 
	
	isPlayingX _ false .
	
	isPlayingO _ true .! !

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:25:47'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:26:05' prior: 50964595!
test04XPlaysAfterO
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self assert: game isPlayingX .
	
	self deny: game isPlayingO .! !

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:26:06'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:26:26' prior: 50964629!
putOAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	isPlayingO _ false .
	
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:26:29'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:26:29'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:26:29'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:26:29'!
PASSED!

!testRun: #TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:26:29'!
ERROR!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:26:29'!
ERROR!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:26:33'!
PASSED!

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:26:36'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:26:37'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:26:38'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:26:39'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:27:02' prior: 50964566!
test03OPlaysAfterX
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingO .
	
	self deny: game isPlayingX .! !

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:27:04'!
PASSED!

Object subclass: #TerniLapilli
	instanceVariableNames: 'XTokens OTokens isPlayingX'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!

!classDefinition: #TerniLapilli category: #'TerniLapilli-Exercise' stamp: 'eb 10/29/2020 19:28:06'!
Object subclass: #TerniLapilli
	instanceVariableNames: 'XTokens OTokens isPlayingX'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TerniLapilli-Exercise'!
!TerniLapilli methodsFor: 'initialization' stamp: 'eb 10/29/2020 19:28:15' prior: 50964405 overrides: 16896425!
initialize

	XTokens _ OrderedCollection new .
	
	OTokens _ OrderedCollection new .
		
	isPlayingX _ true .! !
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/29/2020 19:28:36' prior: 50963943!
isPlayingO
	
	^ isPlayingX not .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:29:05' prior: 50964669!
putOAt: aPoint 
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
		
	isPlayingX _ true .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:29:10' prior: 50964650!
putXAt: aPoint 
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:29:13'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:29:14'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:29:15'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:29:16'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:29:36' prior: 50964289!
test06AtTheBeginningAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board) equals: (-1@1 corner: 1@-1)! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:29:40'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:29:40'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:29:40'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:29:40'!
PASSED!

!testRun: #TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:29:40'!
FAILURE!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:29:40'!
ERROR!

!methodRemoval: TerniLapilli #board stamp: 'eb 10/29/2020 19:29:49'!
board

	^ board .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:30:01'!
test05AtTheBeginningAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board) equals: (-1@1 corner: 1@-1)! !

!methodRemoval: TerniLapilliTest #test06AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:30:01'!
test06AtTheBeginningAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board) equals: (-1@1 corner: 1@-1)!

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:30:07'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:30:07'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:30:07'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:30:07'!
PASSED!

!testRun: #TerniLapilliTest #test05AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:30:07'!
ERROR!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:30:07'!
ERROR!

!testRun: #TerniLapilliTest #test05AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:30:10'!
ERROR!

!testRun: #TerniLapilliTest #test05AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:30:10'!
ERROR!
!TerniLapilli methodsFor: 'accessing' stamp: 'eb 10/29/2020 19:30:22'!
board
	self shouldBeImplemented.! !
!TerniLapilli methodsFor: 'accessing' stamp: 'eb 10/29/2020 19:30:34' prior: 50964843!
board
	
	^ -1@1 corner: 1@-1 .! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 19:30:37'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 19:30:37'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 19:30:37'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 19:30:37'!
PASSED!

!testRun: #TerniLapilliTest #test05AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:30:37'!
PASSED!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:30:37'!
ERROR!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:30:37'!
ERROR!

!testRun: #TerniLapilliTest #test05AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 19:30:48'!
PASSED!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:31:10'!
ERROR!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:31:10'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:31:34' prior: 50964341!
test07TokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:32:54'!
ERROR!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:32:54'!
ERROR!
!TerniLapilli class methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 19:33:02'!
playerIsOutsideBoardErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 19:33:28' prior: 50964913!
playerIsOutsideBoardErrorDescription
	
	^ 'Player is outside board'.! !

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:33:33'!
FAILURE!

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:33:33'!
FAILURE!

!methodRemoval: TerniLapilli class #onlyXCanInitGameError stamp: 'eb 10/29/2020 19:37:39'!
onlyXCanInitGameError
	
	^ 'Only X can init game' .!

!methodRemoval: TerniLapilli class #playerCannotPlayTwiceError stamp: 'eb 10/29/2020 19:37:46'!
playerCannotPlayTwiceError

	^ 'Player cannot play twice'.!

!methodRemoval: TerniLapilli class #playerXShouldPlay stamp: 'eb 10/29/2020 19:38:09'!
playerXShouldPlay
	self shouldBeImplemented.!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 19:38:22' prior: 50964528!
playerXShouldPlayErrorDescription

	^ 'Player X should play' .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 19:38:42' prior: 50964754!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:38:51'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:39:30'!
test07XTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!methodRemoval: TerniLapilliTest #test07TokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:39:30'!
test07TokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:39:57'!
test06XTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!methodRemoval: TerniLapilliTest #test07XTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:39:57'!
test07XTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:40:26'!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putOAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:40:30'!
FAILURE!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:40:30'!
FAILURE!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 19:40:56' prior: 50965049!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	self should: [ game putOAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:41:00'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:41:00'!
ERROR!

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:41:11'!
PASSED!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:41:13'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 19:41:13'!
ERROR!

self board!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:24:56' prior: 50965078!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: -1@1 .
	
	self should: [ game putOAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:24:59'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:24:59'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:25:39' prior: 50965118!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: -0.9@0.9 .
	
	self should: [ game putOAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:25:41'!
ERROR!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:25:41'!
ERROR!

rectangle!

rectangle _ -1@1 corner: 1@-1.!

rectangle _ -1@1 corner: 1@-1.
!

rectangle _ -1@1 corner: 1@-1.
!

rectangle !

rectangle area !

rectangle _ -1@1 corner: 1@1.
!

rectangle _ -1@1 corner: 1@1.
!

rectangle!

rectangle area !

(-1@1 corner: 1@1) area !

(-1@1 corner: 1@-1) area  !

(-2@2 corner: 2@-2) area  !

(0@0) corner: (10@10)!

(0@0) corner: (10@10) area!

((0@0) corner: (10@10)) area!

((-10@10) corner: (10@10)) area !

(0@0 corner: 2@2) area !

(0@0 corner: 2@2) containsPoint: 0@0!

(0@0 corner: 2@2) containsPoint: 0@1!

(0@0 corner: 2@2) containsPoint: 0@2!

(0@0 corner: 3@3) containsPoint: 0@2!

(0@0 corner: 3@3) containsPoint: 1@0!

(0@0 corner: 3@3) containsPoint: 2@0!

(0@0 corner: 3@3) containsPoint: 3@0!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:33:56' prior: 50964801!
test05AtTheBeginningAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board) equals: (0@0 corner: 3@3)! !
!TerniLapilli methodsFor: 'accessing' stamp: 'eb 10/29/2020 20:34:03' prior: 50964847!
board
	
	^ 0@0 corner: 3@3 .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:34:39' prior: 50965005!
test06XTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!methodRemoval: TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:34:45'!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: -0.9@0.9 .
	
	self should: [ game putOAt: -2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 2@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@2. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.!

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:34:48'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:35:23'!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:35:25'!
FAILURE!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:35:25'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:35:50' prior: 50964747!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
		
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:35:58'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:39:53' prior: 50965261!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:40:00'!
test06XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:41:20' prior: 50965327!
test06XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class canNotLeaveFromEmptySlotErrorDescription.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:41:23' prior: 50965350!
test06XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:41:35' prior: 50965377!
test06XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:41:38'!
ERROR!

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:41:39'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 20:41:52'!
playerPositionIsInvalidErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 20:42:06' prior: 50965443!
playerPositionIsInvalidErrorDescription

	^ 'Player position is invalid'.
! !

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:42:10'!
FAILURE!

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:42:10'!
FAILURE!

!methodRemoval: TerniLapilliTest #test06XTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:42:15'!
test06XTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.!

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:42:17'!
FAILURE!

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:42:17'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:44:00' prior: 50964950!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [].
	
	isPlayingX _ false .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:44:17' prior: 50965492!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 20:44:24'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:44:42' prior: 50965305!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
		self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:44:45' prior: 50965516!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:45:00'!
test07OTokensShouldBePlacedIntoBoardnAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !

!methodRemoval: TerniLapilliTest #test07OTokensShouldBePlacedIntoBoard stamp: 'eb 10/29/2020 20:45:00'!
test07OTokensShouldBePlacedIntoBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 20:45:31' prior: 50965579!
test07OTokensShouldBePlacedIntoBoardnAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putOAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 20:45:37'!
FAILURE!

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 20:45:37'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:46:00' prior: 50965291!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
		
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test07OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 20:46:05'!
PASSED!
!TerniLapilliTest methodsFor: 'nil' stamp: 'eb 10/29/2020 20:48:47'!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	self should: [ game putOAt: 0@0 ]
		raise: Error
		withMessageText: game class positionIsnAvailableErrorDescription.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:48:55' prior: 50965699!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	self should: [ game putOAt: 0@0 ]
		raise: Error
		withMessageText: game class positionIsntAvailableErrorDescription.! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:49:01'!
ERROR!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:49:01'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 20:49:11'!
positionIsntAvailableErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 20:49:37' prior: 50965728!
positionIsntAvailableErrorDescription
	
	^ 'Position isnt available'.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 20:49:54'!
positionIsNotAvailableErrorDescription
	
	^ 'Position isnt available'.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:49:54' prior: 50965710!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	self should: [ game putOAt: 0@0 ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!methodRemoval: TerniLapilli class #positionIsntAvailableErrorDescription stamp: 'eb 10/29/2020 20:49:54'!
positionIsntAvailableErrorDescription
	
	^ 'Position isnt available'.!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 20:50:12' prior: 50965739!
positionIsNotAvailableErrorDescription
	
	^ 'Position is not available'.! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:50:16'!
FAILURE!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:50:16'!
FAILURE!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:50:29' prior: 50965745!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:50:31'!
FAILURE!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:50:31'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:50:51' prior: 50965501!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:52:05' prior: 50965682!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
		
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:52:15'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:52:48' prior: 50965776!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	self should: [ game putXAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:52:57' prior: 50965807!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
		
	isPlayingX _ true .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:53:04' prior: 50965795!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:53:09'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:53:19' prior: 50965828!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	self should: [ game putXAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putXAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:53:20'!
FAILURE!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:53:20'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:53:43' prior: 50965854!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:53:49'!
FAILURE!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:53:49'!
FAILURE!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:54:01'!
FAILURE!

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:54:01'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:54:27' prior: 50965840!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	OTokens add: aPoint .
		
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:54:32'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:55:10'!
test09OTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	game putXAt: 1@1 .
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putXAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!testRun: #TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:55:12'!
FAILURE!

!testRun: #TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:55:12'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:55:35' prior: 50965931!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	OTokens add: aPoint .
		
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:55:40'!
PASSED!
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/29/2020 20:55:51' prior: 50965949!
test09OTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	game putXAt: 1@1 .
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putOAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!testRun: #TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:55:52'!
FAILURE!

!testRun: #TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:55:52'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 20:56:13' prior: 50965973!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	OTokens add: aPoint .
		
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 20:56:21'!
PASSED!

!methodRemoval: TerniLapilliTest #test05AtTheBeginningAllBoardPositionsAreAvailable stamp: 'eb 10/29/2020 21:00:08'!
test05AtTheBeginningAllBoardPositionsAreAvailable

	| game |
	
	game _ TerniLapilli new .
	
	self assert: (game board) equals: (0@0 corner: 3@3)!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:03:30'!
test05XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !

!methodRemoval: TerniLapilliTest #test06XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 21:03:30'!
test06XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:03:42'!
test06OTokensShouldBePlacedIntoBoardnAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putOAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.! !

!methodRemoval: TerniLapilliTest #test07OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 21:03:42'!
test07OTokensShouldBePlacedIntoBoardnAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.
	
	self should: [ game putOAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class playerPositionIsInvalidErrorDescription.!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:03:49'!
test07XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	self should: [ game putXAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putXAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!methodRemoval: TerniLapilliTest #test08XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:03:49'!
test08XTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	self should: [ game putXAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putXAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:03:58'!
test08OTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	game putXAt: 1@1 .
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putOAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.! !

!methodRemoval: TerniLapilliTest #test09OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:03:58'!
test09OTokensShouldBePlacedIntoAvailablePositions
	
	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 1@0.
	
	game putXAt: 1@1 .
	
	self should: [ game putOAt: 0@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.
		
	self should: [ game putOAt: 1@0. self fail. ]
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription.!

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:04:02'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:04:02'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:08:08'!
test09XTokensShouldNotBeMoreThanThree

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 1@2 .
	
	game putOAt: 2@1 .
	
	self should: [ game putXAt: 2@2. self fail.]
		raise: Error
		withMessageText: game class cannotPutMoreThanThreeXTokensErrorDescription .! !

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:08:12'!
ERROR!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:08:12'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 21:08:24'!
cannotPutMoreThanThreeXTokensErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 21:08:44' prior: 50966293!
cannotPutMoreThanThreeXTokensErrorDescription
	
	^ 'Cannot put more than three X tokens into board' .! !

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:08:47'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 21:10:01' prior: 50965897!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(XTokens length = 3) ifTrue: [self error: self class cannotPutMoreThanThreeXTokensErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:10:16'!
ERROR!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:10:16'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 21:10:39' prior: 50966309!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class playerPositionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(XTokens size = 3) ifTrue: [self error: self class cannotPutMoreThanThreeXTokensErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:10:45'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:16:07'!
test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 1@2 .
	
	game putOAt: 2@1 .
	
	self should: [ game putXAt: 2@2. self fail.]
		raise: Error
		withMessageText: game class cannotPutMoreThanThreeXTokensErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:19:09' prior: 50966363!
test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	self should: [ game moveXTokenFrom: 0@0 to: 0@1] 
		raise: Error
		withMessageText: game class movementsCanOnlyBeDoneWithThreeTokens .! !

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:19:44'!
ERROR!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:19:44'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 21:19:58'!
movementsCanOnlyBeDoneWithThreeTokens
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/29/2020 21:20:13' prior: 50966399!
movementsCanOnlyBeDoneWithThreeTokens
	
	^ 'Movements can only be done with three tokens'.! !

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:20:32'!
FAILURE!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:20:32'!
FAILURE!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:20:53' prior: 50966378!
test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	self should: [ game moveXTokenFrom: 0@0 to: 0@1. self fail. ] 
		raise: Error
		withMessageText: game class movementsCanOnlyBeDoneWithThreeTokens .! !

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:20:56'!
FAILURE!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:20:56'!
FAILURE!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:21:47'!
FAILURE!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:21:47'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 21:22:50'!
moveXTokenFrom: aSourcePoint to: aTargetPoint
	
	self error: self class ! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 21:23:05' prior: 50966448!
moveXTokenFrom: aSourcePoint to: aTargetPoint
	
	self error: self class movementsCanOnlyBeDoneWithThreeTokens.! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:23:08'!
PASSED!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:23:08'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:23:58'!
test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 2@0.
	
	self should: [ game moveXTokenFrom: 0@0 to: 0@1. self fail. ] 
		raise: Error
		withMessageText: game class movementsCanOnlyBeDoneWithThreeTokens .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/29/2020 21:24:08' prior: 50966495!
test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 2@0.
	
	self should: [ game moveOTokenFrom: 0@2 to: 0@1. self fail. ] 
		raise: Error
		withMessageText: game class movementsCanOnlyBeDoneWithThreeTokens .! !

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/29/2020 21:24:12'!
FAILURE!

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/29/2020 21:24:12'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/29/2020 21:24:25'!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	self error: self class movementsCanOnlyBeDoneWithThreeTokens.! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/29/2020 21:24:27'!
PASSED!

----QUIT----(29 October 2020 21:45:07) CuisUniversity-4365.image priorSource: 20225119!

----STARTUP---- (31 October 2020 14:08:29) as C:\Program Files\CuisUniversity\CuisUniversity-4365.image!

!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:17:27' prior: 50966509!
test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	self should: [ game moveOTokenFrom: 0@2 to: 1@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsCanOnlyBeDoneWithThreeTokens .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:18:00'!
test12XTokensCannotBeMovedToPositionsWithOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	self should: [ game moveOTokenFrom: 0@2 to: 1@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsCanOnlyBeDoneWithThreeTokens .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:20:48' prior: 50966596!
test12XTokensCannotBeMovedToPositionsWithOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	self should: [ game moveXTokenFrom: 1@0 to: 1@1. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:20:51'!
FAILURE!

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:20:51'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:24:12' prior: 50966454!
moveXTokenFrom: aSourcePoint to: aTargetPoint
	
	self error: self class movementsCanOnlyBeDoneWithThreeTokens.
	
	(OTokens includes: aTargetPoint) ifTrue: [ ^ self error: self class positionIsNotAvailableErrorDescription .]! !

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:24:14'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:24:38' prior: 50966632!
moveXTokenFrom: aSourcePoint to: aTargetPoint
	
	(OTokens includes: aTargetPoint) ifTrue: [ ^ self error: self class positionIsNotAvailableErrorDescription .] .
	
	self error: self class movementsCanOnlyBeDoneWithThreeTokens.
! !

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:24:41'!
PASSED!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:26:14' prior: 50966646!
moveXTokenFrom: aSourcePoint to: aTargetPoint
	
	[ XTokens remove: aSourcePoint . self putXAt: aTargetPoint ] on: Error do: [ self putXAt: aSourcePoint ].
		
	self error: self class movementsCanOnlyBeDoneWithThreeTokens.
! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:26:56' prior: 50966660!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	[ XTokens remove: aSourcePoint . self putXAt: aTargetPoint ] on: Error do: [ self putXAt: aSourcePoint ].
		
	
! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/31/2020 14:27:05'!
PASSED!

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:27:05'!
FAILURE!

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:27:05'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:27:58' prior: 50966670!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	self putXAt: aTargetPoint .
	
	XTokens remove: aSourcePoint .
		
	
! !

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:28:06'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:28:55'!
test13XTokensCannotBeMovedToPositionsWithXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	self should: [ game moveXTokenFrom: 1@0 to: 0@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !

!testRun: #TerniLapilliTest #test13XTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:28:57'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:29:27'!
test14OTokensCannotBeMovedToPositionsWithOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	self should: [ game moveXTokenFrom: 1@0 to: 0@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:30:41' prior: 50966758!
test14OTokensCannotBeMovedToPositionsWithOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveXTokenFrom: 1@0 to: 0@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:32:22' prior: 50966773!
test14OTokensCannotBeMovedToPositionsWithOTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 1@1 to: 1@2. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:32:24'!
ERROR!

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:32:24'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:33:37' prior: 50966530!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	(OTokens size < 3) ifTrue: [self error: self class movementsCanOnlyBeDoneWithThreeTokens.] .
	
	self error: self class positionIsNotAvailableErrorDescription .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:34:57' prior: 50966812!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	(OTokens size < 3) ifTrue: [self error: self class movementsCanOnlyBeDoneWithThreeTokens.] .
	
	self error: self class positionIsNotAvailableErrorDescription .! !

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:35:17'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:38:19' prior: 50966727!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	self putXAt: aTargetPoint .
	
	XTokens remove: aSourcePoint .
		
	
! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:38:45' prior: 50966835!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
		
	
! !

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:38:55'!
PASSED!

!testRun: #TerniLapilliTest #test13XTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:38:56'!
PASSED!

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:38:58'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:40:03'!
test14OTokensCannotBeMovedToPositionsWithXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 1@1 to: 1@2. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:40:17' prior: 50966876!
test14OTokensCannotBeMovedToPositionsWithXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 1@1 to: 1@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:40:19'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:40:29'!
test15OTokensCannotBeMovedToPositionsWithXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 1@1 to: 1@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !

!methodRemoval: TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:40:29'!
test14OTokensCannotBeMovedToPositionsWithXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 1@1 to: 1@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:45:17'!
test03OPutsAfterX
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingO .
	
	self deny: game isPlayingX .! !

!methodRemoval: TerniLapilliTest #test03OPlaysAfterX stamp: 'eb 10/31/2020 14:45:17'!
test03OPlaysAfterX
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	self assert: game isPlayingO .
	
	self deny: game isPlayingX .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:45:26'!
test04XPutsAfterO
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self assert: game isPlayingX .
	
	self deny: game isPlayingO .! !

!methodRemoval: TerniLapilliTest #test04XPlaysAfterO stamp: 'eb 10/31/2020 14:45:26'!
test04XPlaysAfterO
	
	| game |
	
	game _ TerniLapilli new.
	
	game putXAt: 0@0 .
	
	game putOAt: 0@1 .
	
	self assert: game isPlayingX .
	
	self deny: game isPlayingO .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:46:57'!
test16XCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveXTokenFrom: 2@0 to: 2@1. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .! !

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:47:26'!
ERROR!

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:47:26'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 14:47:48'!
cannotMoveTwiceErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 14:48:02' prior: 50966995!
cannotMoveTwiceErrorDescription

	^ 'Player cannot move twice'.! !

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test03OPutsAfterX stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test04XPutsAfterO stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test13XTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:48:05'!
PASSED!

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:48:05'!
FAILURE!

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:48:05'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:49:08' prior: 50966850!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
		
	
! !

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:49:13'!
FAILURE!

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:49:14'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:49:37' prior: 50967066!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
	
	isPlayingX _ false .
	
! !

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:49:41'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:49:53'!
test16OCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveXTokenFrom: 2@0 to: 2@1. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:50:00'!
test17OCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveXTokenFrom: 2@0 to: 2@1. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .! !

!methodRemoval: TerniLapilliTest #test16OCannotMoveTwice stamp: 'eb 10/31/2020 14:50:02'!
test16OCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveXTokenFrom: 2@0 to: 2@1. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:53:45' prior: 50967125!
test17OCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	game moveOTokenFrom: 1@1 to: 2@1.
	
	self should: [ game moveOTokenFrom: 1@1 to: 3@1. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .! !

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:53:46'!
ERROR!

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:53:46'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:54:06' prior: 50967155!
test17OCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	game moveOTokenFrom: 1@1 to: 2@1.
	
	self should: [ game moveOTokenFrom: 1@1 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .! !

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:54:09'!
ERROR!

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:54:09'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:54:23' prior: 50967177!
test17OCannotMoveTwice

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	game moveOTokenFrom: 1@1 to: 2@1.
	
	self should: [ game moveOTokenFrom: 2@1 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class cannotMoveTwiceErrorDescription .! !

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:54:25'!
ERROR!

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:54:25'!
ERROR!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:56:27' prior: 50966822!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	XTokens remove: aSourcePoint .! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:57:09' prior: 50967089!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].

	(XTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
	
	isPlayingX _ false .
	
! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 14:57:59' prior: 50967221!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	isPlayingX ifTrue: [ self error: self class cannotMoveTwiceErrorDescription ].

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	OTokens remove: aSourcePoint .
	
	OTokens add: aTargetPoint .
	
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:58:04'!
PASSED!

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test03OPutsAfterX stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test04XPutsAfterO stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test13XTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 14:58:28'!
PASSED!

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:58:28'!
FAILURE!

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 14:58:29'!
PASSED!

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 14:58:29'!
PASSED!

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:58:29'!
FAILURE!

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:58:48'!
FAILURE!

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:58:48'!
FAILURE!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 14:59:06' prior: 50966911!
test15OTokensCannotBeMovedToPositionsWithXTokens

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 1@1 to: 2@0. self fail. ] 
		raise: Error
		withMessageText: game class positionIsNotAvailableErrorDescription .! !

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 14:59:08'!
PASSED!

!testRun: #TerniLapilliTest #test01AtTheBeginningBoardIsEmptyAndXShouldPlay stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test02OCannotInitGame stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test03OPutsAfterX stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test04XPutsAfterO stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test05XTokensShouldBePlacedIntoBoardInAValidPosition stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test06OTokensShouldBePlacedIntoBoardnAValidPosition stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test07XTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test08OTokensShouldBePlacedIntoAvailablePositions stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test09XTokensShouldNotBeMoreThanThree stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test10XTokensCanBeMovedOnlyWhenThereAreThreeXTokens stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test11OTokensCanBeMovedOnlyWhenThereAreThreeOTokens stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test12XTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test13XTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test14OTokensCannotBeMovedToPositionsWithOTokens stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test15OTokensCannotBeMovedToPositionsWithXTokens stamp: 'eb 10/31/2020 15:00:13'!
PASSED!

!testRun: #TerniLapilliTest #test16XCannotMoveTwice stamp: 'eb 10/31/2020 15:00:14'!
PASSED!

!testRun: #TerniLapilliTest #test17OCannotMoveTwice stamp: 'eb 10/31/2020 15:00:14'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:08:15'!
test18MovementsLengthIsOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 1@0 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:08:23'!
test18MovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 1@0 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !

!methodRemoval: TerniLapilliTest #test18MovementsLengthIsOne stamp: 'eb 10/31/2020 15:08:25'!
test18MovementsLengthIsOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 1@0 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .!

!testRun: #TerniLapilliTest #test18MovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:08:35'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:12:47'!
test18XMovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 1@0 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !

!methodRemoval: TerniLapilliTest #test18MovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:12:49'!
test18MovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 1@0 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 15:13:41' prior: 50967237!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(XTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
	
	isPlayingX _ false .
	
! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 15:16:58' prior: 50967500!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(XTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].
	
	self assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint.
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
	
	isPlayingX _ false .
	
! !

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:08'!
ERROR!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:08'!
ERROR!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:09'!
ERROR!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:09'!
ERROR!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:24'!
ERROR!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:24'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:17:38'!
movementsLengthShouldBeOneErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:17:55' prior: 50967558!
movementsLengthShouldBeOneErrorDescription

	^ 'Movements length should be one'.! !

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:17:59'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/31/2020 15:23:27'!
assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint
	
	| dX dY verticalDistanceIsOne horizontalDistanceIsOne diagonalDistanceIsOne |
	
	dX _ (aSourcePoint x - aTargetPoint x) abs.
	
	dY _ (aSourcePoint y - aTargetPoint y) abs.
	
	verticalDistanceIsOne _ (dX = 0 and: [dY = 1]) .
	
	horizontalDistanceIsOne _ (dX = 1 and: [dY = 0]).
	
	diagonalDistanceIsOne _ (dX = 1 and: [dY = 1]).
	
	^ (dX = 0 and: (dY = 1)) or:
	    (dX = 1 and: (dY = 0)) or:
	    [dX = 1 and: [dY = 1]]! !
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/31/2020 15:23:51' prior: 50967573!
assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint
	
	| dX dY verticalDistanceIsOne horizontalDistanceIsOne diagonalDistanceIsOne |
	
	dX _ (aSourcePoint x - aTargetPoint x) abs.
	
	dY _ (aSourcePoint y - aTargetPoint y) abs.
	
	verticalDistanceIsOne _ (dX = 0 and: [dY = 1]) .
	
	horizontalDistanceIsOne _ (dX = 1 and: [dY = 0]).
	
	diagonalDistanceIsOne _ (dX = 1 and: [dY = 1]).
	
	^verticalDistanceIsOne or: horizontalDistanceIsOne or: diagonalDistanceIsOne .! !

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:24:03'!
FAILURE!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:24:03'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/31/2020 15:24:57' prior: 50967591!
assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint
	
	| dX dY verticalDistanceIsOne horizontalDistanceIsOne diagonalDistanceIsOne |
	
	dX _ (aSourcePoint x - aTargetPoint x) abs.
	
	dY _ (aSourcePoint y - aTargetPoint y) abs.
	
	verticalDistanceIsOne _ (dX = 0 and: [dY = 1]) .
	
	horizontalDistanceIsOne _ (dX = 1 and: [dY = 0]).
	
	diagonalDistanceIsOne _ (dX = 1 and: [dY = 1]).
	
	(verticalDistanceIsOne or: horizontalDistanceIsOne or: diagonalDistanceIsOne) ifTrue: 
		[ self error: self class movementsLengthShouldBeOneErrorDescription .]! !

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:25:03'!
FAILURE!

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:25:03'!
FAILURE!
!TerniLapilli methodsFor: 'testing' stamp: 'eb 10/31/2020 15:25:37' prior: 50967616!
assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint
	
	| dX dY verticalDistanceIsOne horizontalDistanceIsOne diagonalDistanceIsOne |
	
	dX _ (aSourcePoint x - aTargetPoint x) abs.
	
	dY _ (aSourcePoint y - aTargetPoint y) abs.
	
	verticalDistanceIsOne _ (dX = 0 and: [dY = 1]) .
	
	horizontalDistanceIsOne _ (dX = 1 and: [dY = 0]).
	
	diagonalDistanceIsOne _ (dX = 1 and: [dY = 1]).
	
	(verticalDistanceIsOne or: horizontalDistanceIsOne or: diagonalDistanceIsOne) ifFalse: 
		[ self error: self class movementsLengthShouldBeOneErrorDescription .]! !

!testRun: #TerniLapilliTest #test18XMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:25:43'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:26:01'!
test19OMovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 1@0 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:26:53' prior: 50967667!
test19OMovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0 .
		
	self should: [ game moveOTokenFrom: 0@2 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:27:24' prior: 50967682!
test19OMovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0 .
		
	self should: [ game moveOTokenFrom: 0@2 to: 0@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !

!testRun: #TerniLapilliTest #test19OMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:27:28'!
FAILURE!

!testRun: #TerniLapilliTest #test19OMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:27:28'!
FAILURE!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:27:47' prior: 50967698!
test19OMovementsLengthShouldBeOne

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
	
	game moveXTokenFrom: 1@0 to: 2@0 .
		
	self should: [ game moveOTokenFrom: 0@2 to: 2@2. self fail. ] 
		raise: Error
		withMessageText: game class movementsLengthShouldBeOneErrorDescription .! !

!testRun: #TerniLapilliTest #test19OMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:27:48'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 15:28:11' prior: 50967255!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	isPlayingX ifTrue: [ self error: self class cannotMoveTwiceErrorDescription ].

	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	self assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint.
	
	OTokens remove: aSourcePoint .
	
	OTokens add: aTargetPoint .
	
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test19OMovementsLengthShouldBeOne stamp: 'eb 10/31/2020 15:28:21'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:33:11'!
test20XTokensMovementsSourcesAreAlreadyInBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 2@2 to: 2@1 . self fail. ] 
		raise: Error
		withMessageText: game class movementSourceHasNotTokenErrorDescription .! !

!testRun: #TerniLapilliTest #test20XTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:33:19'!
ERROR!

!testRun: #TerniLapilliTest #test20XTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:33:19'!
ERROR!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:33:29'!
movementSourceHasNotTokenErrorDescription
	self shouldBeImplemented.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:33:43' prior: 50967784!
movementSourceHasNotTokenErrorDescription

	^ 'Movement source has no token'.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:33:58' prior: 50967790!
movementSourceHasNotTokenErrorDescription

	^ 'Movement source has not token'.! !

!testRun: #TerniLapilliTest #test20XTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:34:04'!
FAILURE!

!testRun: #TerniLapilliTest #test20XTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:34:04'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 15:35:03' prior: 50967518!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(XTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].
	
	self assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint.
		
	XTokens remove: aSourcePoint ifAbsent: [ self error: self class movementSourceHasNotTokenErrorDescription ].
	
	XTokens add: aTargetPoint .
	
	isPlayingX _ false .
	
! !
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 15:38:03' prior: 50967809!
moveXTokenFrom: aSourcePoint to: aTargetPoint

	(XTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifFalse: [ self error: self class cannotMoveTwiceErrorDescription ].
	
	self assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint.
	
	((XTokens includes: aSourcePoint ) or: [ OTokens includes: aSourcePoint ]) 
		ifFalse: [ self error: self class movementSourceHasNotTokenErrorDescription ].
		
	XTokens remove: aSourcePoint .
	
	XTokens add: aTargetPoint .
	
	isPlayingX _ false .
	
! !

!testRun: #TerniLapilliTest #test20XTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:38:16'!
PASSED!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:38:30'!
test21OTokensMovementsSourcesAreAlreadyInBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	self should: [ game moveXTokenFrom: 2@2 to: 2@1 . self fail. ] 
		raise: Error
		withMessageText: game class movementSourceHasNotTokenErrorDescription .! !
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:39:13' prior: 50967861!
test21OTokensMovementsSourcesAreAlreadyInBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	game moveXTokenFrom: 0@1 to: 0@2.
	
	self should: [ game moveOTokenFrom: 2@2 to: 2@1. self fail. ] 
		raise: Error
		withMessageText: game class movementSourceHasNotTokenErrorDescription .! !

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:39:16'!
ERROR!

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:39:16'!
ERROR!
!TerniLapilliTest methodsFor: 'testing' stamp: 'eb 10/31/2020 15:40:10' prior: 50967876!
test21OTokensMovementsSourcesAreAlreadyInBoard

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0 .
	
	game putOAt: 0@2 .
	
	game putXAt: 1@0.
	
	game putOAt: 1@1 .
	
	game putXAt: 0@1.
	
	game putOAt: 1@2.
		
	game moveXTokenFrom: 1@0 to: 2@0.
	
	self should: [ game moveOTokenFrom: 2@2 to: 2@1. self fail. ] 
		raise: Error
		withMessageText: game class movementSourceHasNotTokenErrorDescription .! !

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:40:11'!
FAILURE!

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:40:11'!
FAILURE!

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:40:31'!
FAILURE!

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:40:31'!
FAILURE!
!TerniLapilli methodsFor: 'playing' stamp: 'eb 10/31/2020 15:41:51' prior: 50967739!
moveOTokenFrom: aSourcePoint to: aTargetPoint
	
	(OTokens size < 3) ifTrue: [ self error: self class movementsCanOnlyBeDoneWithThreeTokens. ].
	
	((XTokens includes: aTargetPoint ) or: [ OTokens includes: aTargetPoint ]) 
		ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class cannotMoveTwiceErrorDescription ].
		
	self assertThat: aSourcePoint isWithinOneUnitDistanceTo: aTargetPoint.
	
	((XTokens includes: aSourcePoint ) or: [ OTokens includes: aSourcePoint ]) 
		ifFalse: [self error: self class movementSourceHasNotTokenErrorDescription ].
	
	OTokens remove: aSourcePoint .
	
	OTokens add: aTargetPoint .
	
	isPlayingX _ true .! !

!testRun: #TerniLapilliTest #test21OTokensMovementsSourcesAreAlreadyInBoard stamp: 'eb 10/31/2020 15:41:54'!
PASSED!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:44:56' prior: 50965449!
playerPositionIsInvalidErrorDescription

	^ 'Position is invalid'.
! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:44:58'!
positionIsInvalidErrorDescription

	^ 'Position is invalid'.
! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:44:58' prior: 50966115!
test06OTokensShouldBePlacedIntoBoardnAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.
	
	self should: [ game putOAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:44:58' prior: 50966052!
test05XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class playerIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:44:58' prior: 50966338!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class positionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(XTokens size = 3) ifTrue: [self error: self class cannotPutMoreThanThreeXTokensErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:44:58' prior: 50966019!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class playerIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class positionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	OTokens add: aPoint .
		
	isPlayingX _ true .! !

!methodRemoval: TerniLapilli class #playerPositionIsInvalidErrorDescription stamp: 'eb 10/31/2020 15:44:58'!
playerPositionIsInvalidErrorDescription

	^ 'Position is invalid'.
!
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:45:22' prior: 50964919!
playerIsOutsideBoardErrorDescription
	
	^ 'Position is outside board'.! !
!TerniLapilli class methodsFor: 'error descriptions' stamp: 'eb 10/31/2020 15:45:39'!
positionIsOutsideBoardErrorDescription
	
	^ 'Position is outside board'.! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:45:39' prior: 50968055!
putOAt: aPoint 

	(self board containsPoint: aPoint) ifFalse: [ self error: self class positionIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class positionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
		
	isPlayingX ifTrue: [ self error: self class playerXShouldPlayErrorDescription ].
	
	OTokens add: aPoint .
		
	isPlayingX _ true .! !
!TerniLapilli methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:45:39' prior: 50968033!
putXAt: aPoint 
	
	(self board containsPoint: aPoint) ifFalse: [ self error: self class positionIsOutsideBoardErrorDescription ].
	
	(aPoint isIntegerPoint) ifFalse: [self error: self class positionIsInvalidErrorDescription ].
	
	(XTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(OTokens includes: aPoint) ifTrue: [self error: self class positionIsNotAvailableErrorDescription ].
	
	(XTokens size = 3) ifTrue: [self error: self class cannotPutMoreThanThreeXTokensErrorDescription ].
	
	XTokens add: aPoint .
	
	isPlayingX _ false .! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:45:39' prior: 50967970!
test06OTokensShouldBePlacedIntoBoardnAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	game putXAt: 0@0.
	
	self should: [ game putOAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putOAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.
	
	self should: [ game putOAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.! !
!TerniLapilliTest methodsFor: 'as yet unclassified' stamp: 'eb 10/31/2020 15:45:39' prior: 50968002!
test05XTokensShouldBePlacedIntoBoardInAValidPosition

	| game |
	
	game _ TerniLapilli new .
	
	self should: [ game putXAt: -1@0. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@-1. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 3@0. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0@3. self fail.]
		raise: Error
		withMessageText: game class positionIsOutsideBoardErrorDescription.
		
	self should: [ game putXAt: 0.5@1. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.
	
	self should: [ game putXAt: 1@0.5. self fail.]
		raise: Error
		withMessageText: game class positionIsInvalidErrorDescription.! !

!methodRemoval: TerniLapilli class #playerIsOutsideBoardErrorDescription stamp: 'eb 10/31/2020 15:45:39'!
playerIsOutsideBoardErrorDescription
	
	^ 'Position is outside board'.!